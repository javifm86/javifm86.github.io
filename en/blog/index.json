[{"url":"/en/blog/using-tailwindcss-with-angular/","title":"Using TailwindCSS with Angular","content":"In this article we are going to explain how to set up an Angular application with Angular CLI in order to integrate TailwindCSS. With this approach the CSS written in our components will be very little because most of the time we will be using Tailwind classes.\nAngular CLI Angular CLI is the recommended command line interface for generating Angular applications. It uses webpack under the hood, but we can´t access directly to webpack settings so if we want to customize any behaviour we can use a package called @angular-builders/custom-webpack. This package will allow us extend webpack config.\nSetting up TailwindCSS TailwindCSS works regardless of CSS preprocessor we use in our application (if we use one). To make the development experience as productive as possible, we will run PurgeCSS just when building for production. Let´s see step by step guide for adding Tailwind:\nFirst of all we will install dependencies:\nnpm install tailwindcss --save npm install --save-dev @angular-builders/custom-webpack @fullhuman/postcss-purgecss Generate an empty Tailwind config file:\nnpx tailwind init Create a new file, and give it the extension depending on the preprocessor you are using. In my case scss, so the file will be src/tailwind.scss where we will insert Tailwind directives. We can also add custom styles using Tailwind directives in this file.\n@tailwind base; @tailwind components; /* Custom CSS */ a.tag { @apply bg-gray-200 rounded-full px-3 py-1 font-semibold text-gray-700; } a.tag:hover { @apply underline; } /* Custom CSS end */ @tailwind utilities; Next step is creating extra-webpack.config.js file on folder root with this content:\nconst purgecss = require(\u0026#39;@fullhuman/postcss-purgecss\u0026#39;)({ // Specify the paths to all of the template files in your project  content: [\u0026#39;./src/**/*.html\u0026#39;, \u0026#39;./src/**/*.component.ts\u0026#39;], // Include any special characters you\u0026#39;re using in this regular expression  defaultExtractor: content =\u0026gt; content.match(/[\\w-/:]+(?\u0026lt;!:)/g) || [] }); module.exports = (config, options) =\u0026gt; { console.log(`Using \u0026#39;${config.mode}\u0026#39; mode`); config.module.rules.push({ test: /tailwind\\.scss$/, use: [ { loader: \u0026#39;postcss-loader\u0026#39;, options: { plugins: [ require(\u0026#39;tailwindcss\u0026#39;)(\u0026#39;./tailwind.config.js\u0026#39;), require(\u0026#39;autoprefixer\u0026#39;), ...(config.mode === \u0026#39;production\u0026#39; ? [purgecss] : []) ] } } ] }); return config; };  angular.json Now we need to edit angular.json config file so that we can customize ng serve and ng build commands. We must search projects.architect.build.builder key and replace @angular-devkit/build-angular:browser with @angular-builders/custom-webpack:browser. It´s neccessary add a new object customWebpackConfig at architect.build.options with key path and extra-webpack.config.js as its value.\nWe must do same changes in projects.architect.serve.builder replacing @angular-devkit/build-angular:dev-server with @angular-builders/custom-webpack:dev-server. It´s neccessary again adding a new object customWebpackConfig at architect.serve.options with key path and extra-webpack.config.js as its value.\nFinally we will add our src/tailwind.scss stylesheet to the array in architect.build.options.styles. Let´s see all the changes together:\n\u0026#34;architect\u0026#34;: { \u0026#34;build\u0026#34;: { \u0026#34;builder\u0026#34;: \u0026#34;@angular-builders/custom-webpack:browser\u0026#34;,  \u0026#34;options\u0026#34;: { \u0026#34;customWebpackConfig\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;extra-webpack.config.js\u0026#34; },  // ... \u0026#34;styles\u0026#34;: [ \u0026#34;src/tailwind.scss\u0026#34;,  \u0026#34;src/styles.css\u0026#34; ], // ... } }, \u0026#34;serve\u0026#34;: { \u0026#34;builder\u0026#34;: \u0026#34;@angular-builders/custom-webpack:dev-server\u0026#34;,  \u0026#34;options\u0026#34;: { \u0026#34;customWebpackConfig\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;extra-webpack.config.js\u0026#34; },  // ... } } } Once these changes are applied we can init server in development mode with ng serve as usual. All the Tailwind classes will be available. When compiling for production with ng build --prod we can check in dist folder that styles files is generated with only classes that are used in our application.\nchunk {4} styles.847663bf210845648553.css (styles) 5.51 kB [initial] [rendered] PurgeCSS with Tailwind From Tailwind 1.4.0 PurgeCSS is integrated into Tailwind config file. This way we can remove @fullhuman/postcss-purgecss dependency in our project and leave extra-webpack.config.js with this content:\nmodule.exports = (config, options) =\u0026gt; { console.log(`Using \u0026#39;${config.mode}\u0026#39; mode`); config.module.rules.push({ test: /tailwind\\.scss$/, use: [ { loader: \u0026#39;postcss-loader\u0026#39;, options: { plugins: [ require(\u0026#39;tailwindcss\u0026#39;)(\u0026#39;./tailwind.config.js\u0026#39;) ] } } ] }); return config; };  We just move routes to tailwind.config.js file:\nmodule.exports = { purge: [\u0026#39;./src/**/*.html\u0026#39;, \u0026#39;./src/**/*.component.ts\u0026#39;], theme: { extend: {}, }, variants: {}, plugins: [], };  We must compile with NODE_ENV variable set to production so that Tailwind automatically purges unused styles. To achieve this with a multiplatform solution I like using cross-env package. We just install it:\nnpm install cross-env --save-dev After the installation we can create a script in package.json to launch the build:\n{ // ... \u0026#34;scripts\u0026#34;: { \u0026#34;ng\u0026#34;: \u0026#34;ng\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;ng serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;ng build\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;ng test\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;ng lint\u0026#34;, \u0026#34;e2e\u0026#34;: \u0026#34;ng e2e\u0026#34;, \u0026#34;build:prod\u0026#34;: \u0026#34;cross-env NODE_ENV=production ng build --prod\u0026#34;  }, // ... } Now we run the script and check that everything is working as expected:\nnpm run build:prod chunk {4} styles.847663bf210845648553.css (styles) 5.51 kB [initial] [rendered] With these simple steps you are ready to go with Tailwind in your Angular projects.\n","summary":"In this article we are going to explain how to set up an Angular application with Angular CLI in order to integrate TailwindCSS."},{"url":"/en/blog/using-tailwind-css-with-hugo/","title":"Using Tailwind CSS with Hugo","content":"In this article we are going to see how can we build our Hugo site with TailwindCSS. Hugo is very flexible and allows us setting up our site easily as we want. In this web, I have a baseof.html file as template for the site. Inside this file I have a partial (an include in Hugo) file, head.html.\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;es\u0026#34;\u0026gt; \u0026lt;head\u0026gt; {{partial\u0026#34;head.html\u0026#34;.}} \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; We import styles.css file from css folder and call absURL Hugo function, so it will return us the absolute path file.\n\u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1, shrink-to-fit=no\u0026#34;\u0026gt; {{$css:=\u0026#34;css/styles.css\u0026#34;|absURL}} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{$css}}\u0026#34;\u0026gt; Static files in Hugo are saved by default in static folder so that is the first step, having styles.css in /static/css/. As this file is going to be generated, what I have done has been to create a folder called static-src where to have sources of my static files that I will subsequently process.\nBefore continuing, we will install the dependencies that we will need with npm.\nnpm install tailwindcss --save npm install postcss postcss-cli @fullhuman/postcss-purgecss autoprefixer watch cross-env cssnano --save-dev Let´s see what are these dependencies:\n tailwindcss: CSS framework. postcss postcss-cli: Tailwind uses PostCSS to get compiled and also we will add some plugins to CSS process. @fullhuman/postcss-purgecss: Tailwind generates thousands of utility classes, most of which we probably don´t use. We will use this plugin for removing CSS that we are not actually using in our project. autoprefixer: Optional, prefix for our stylesheets. watch: Node package which allows us running tasks when any file is modified. It includes a cli that we will use on npm script. cross-env: Package that allow us setting and using environment variables across platforms. NODE_ENV in our case. cssnano: CSS minifier.  With all these dependencies we are ready to generate a CSS file with just the utility classes used and not the whole framework. Let´s generate an empty Tailwind config file so that we can customize default settings in the framework. We simply run:\nnpx tailwind init A tailwind.config.js file will be generated:\nmodule.exports = { theme: { extend: {} }, variants: {}, plugins: [] }  Finally we can create our /static-src/styles.css file invoking Tailwind directives. Besides, we can add custom styles we want, using Tailwind or not.\n@tailwind base; @tailwind components; /* Custom CSS */ a.tag { @apply bg-gray-200 rounded-full px-3 py-1 font-semibold text-gray-700; } a.tag:hover { @apply underline; } /* Custom CSS end */ @tailwind utilities; Tailwind is compiled using PostCSS, so adding new plugins is very easy. We are going to add autoprefixer in order to auto generate prefixes for CSS properties that need them. Besides when compiling for production, we will use purgecss and cssnano for reducing the file size for our stylesheet. Let´s see PostCSS config file (postcss.config.js in the root folder):\nconst purgecss = require(\u0026#39;@fullhuman/postcss-purgecss\u0026#39;)({ content: [\u0026#39;../../content/**/*.md\u0026#39;, \u0026#39;./layouts/**/*.html\u0026#39;], defaultExtractor: content =\u0026gt; content.match(/[A-Za-z0-9-_:/]+/g) || [] }); module.exports = { plugins: [ require(\u0026#39;tailwindcss\u0026#39;), require(\u0026#39;autoprefixer\u0026#39;), ...(process.env.NODE_ENV === \u0026#39;production\u0026#39; ? [purgecss, require(\u0026#39;cssnano\u0026#39;)] : []) ] };  When using purgecss, we will search for files with .md extension inside content folder and .html in layouts. If you are working with javascript files or any other paths where you add CSS classes, you will have to adjust the array of paths to suit your needs. In this snippet of code we are considering that we are working with a theme inside /themes/themename/ folder. If we are working directly in layouts folder (as I do in this blog), we should adjust the paths:\nconst purgecss = require(\u0026#39;@fullhuman/postcss-purgecss\u0026#39;)({ content: [\u0026#39;./content/**/*.md\u0026#39;, \u0026#39;./layouts/**/*.html\u0026#39;, \u0026#39;./static/**/*.js\u0026#39;], defaultExtractor: content =\u0026gt; content.match(/[A-Za-z0-9-_:/]+/g) || [] });  With all this we can generate our npm scripts in package.json file:\n{ \u0026#34;name\u0026#34;: \u0026#34;hugo-tailwindcss\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;css:watch\u0026#34;: \u0026#34;node_modules/.bin/watch \\\u0026#34;npm run css:build:dev\\\u0026#34; ./static-src/css\u0026#34;, \u0026#34;css:build:dev\u0026#34;: \u0026#34;cross-env NODE_ENV=development npm run css:build\u0026#34;, \u0026#34;css:build:prod\u0026#34;: \u0026#34;cross-env NODE_ENV=production npm run css:build\u0026#34;, \u0026#34;css:build\u0026#34;: \u0026#34;node_modules/.bin/postcss static-src/css/styles.css -o static/css/styles.css\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;tailwindcss\u0026#34;: \u0026#34;^1.1.4\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@fullhuman/postcss-purgecss\u0026#34;: \u0026#34;^2.0.5\u0026#34;, \u0026#34;autoprefixer\u0026#34;: \u0026#34;^9.7.4\u0026#34;, \u0026#34;cross-env\u0026#34;: \u0026#34;^6.0.3\u0026#34;, \u0026#34;cssnano\u0026#34;: \u0026#34;^4.1.10\u0026#34;, \u0026#34;postcss\u0026#34;: \u0026#34;^7.0.26\u0026#34;, \u0026#34;postcss-cli\u0026#34;: \u0026#34;^7.1.0\u0026#34;, \u0026#34;watch\u0026#34;: \u0026#34;^1.0.2\u0026#34; } } There are 3 tasks:\n css:build:dev: Compile CSS in development mode, for greater agility we will have all Tailwind utilities by default without need to minimize and purge classes. css:build:prod: Compile, purge and minify CSS file in order to get optimized stylesheet for production. css:watch: Watch ./static-src/css folder. If it detects any change, it compiles CSS file again. It avoids tediously launching manually css:build:dev task on each change we do in our CSS.  With these tasks we can finally generate our stylesheet. I have created a Github repository with a theme which incorporates these scripts as a starting point to create your own theme for Hugo. You can try it out with some example content that I have created in other repository.\nNOTE: It is possible to integrate the whole process thanks to Hugo pipe postCSS. You need to install globally postcss-cli in addition to any other plugins you use. I personally prefer not having global packages installed and being able to customize the process, but it´s an option that Hugo gives us.\n","summary":"In this article we are going to see how can we build our Hugo site with TailwindCSS."},{"url":"/en/blog/new-website-with-hugo/","title":"New website with Hugo","content":"I have a new web with a single purpose: create articles with content about things I am learning. I have migrated the old posts from my Wordpress blog. I always wanted to create a design for my blog from scratch and finally I did it!\nIn the next articles I am going to show some things I have learnt creating this website. First of all I had to choose which tool to use for managing my personal website. I always thought in creating my own Wordpress theme but nowadays there a lot of alternatives and I decided finally using a Static Site Generator.\nSearching on the Internet I found an open-source static site generator written in Go: Hugo. I started testing Hugo, I felt very comfortable and I decided Hugo was the tool I needed.\nIn order to work with hugo, first thing I did was installing it on my PC and following this great guide for creating a blog with Hugo from scratch. Hugo is very flexible and allows us to do everything we can imagine, using themes and shortcodes for syntax highlighting, embed content from popular services such as Youtube, Twitter, Instagram\u0026hellip;\nWorking with a static site allows me using Github pages as hosting. When I want to deploy a new version I just need to copy public folder into the repository, commit, push and the website is deployed automatically.\nFinally, I had the decision of how I was going to organize the web layout. I could have developed everything on my own with CSS or SASS, but I have been hearing about Tailwind CSS, a CSS framework that implements \u0026ldquo;utility first\u0026rdquo; concept. After having worked with Bootstrap, I didn´t want to start learning another framework but I decided to give it a shot. First day I thought that HTML was very dirty with so many classes, but after a couple of days I decided it was very useful and now I love it.\nTailwind is not a framework like Boostrap, you don´t have components with a given markup. Tailwind provides low-level utility classes that let you build completely custom designs without ever leaving your HTML. You can focus on creating, you don´t have to invert time in naming classes and you don´t repeat every time the same CSS properties that make CSS files size growing without control.\nTailwind provides you with a set of possibilities to choose from, different text sizes, color palette, shadow, scale for margins and paddings\u0026hellip; And it is completely customizable, Tailwind is built with PostCSS and you can overwrite or extend everything you want. Tailwind gives you a base on which can create your design system for a fully customized website. Try it.\nIn my next articles I will show how I have configured Hugo, things I have learnt in which I spent a lot of time to get resolved.\n","summary":"I have a new web with a single purpose: create articles with content about things I am learning."}]