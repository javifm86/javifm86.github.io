[{"url":"/en/blog/monorepo-simple-starter-workflow/","title":"Monorepo simple starter workflow","content":"In my current job, I have had to configure a monorepo with git hooks, ESLint, Prettier and some custom actions. I want to register the process, for future reference. This is the use case:\n backend folder, with NestJS project. NestJS is a backend framework for Node, it uses Typescript. frontend folder, with React + Typescript project. Global Prettier config, shared between both projects. ESLint for linting, each project will have its own config. In addition to ESLint, tsc for type check. Git pre-commit hook: will run eslint --fix and prettier --write on files committed. If ESLint or tsc reports any error, commit will be aborted. Git pre-push hook: will run unit testing, if any file was changed on backend project, it will run just backend tests. Same for frontend, and if there are changes on both projects, it will run both. Git push will be aborted if tests fail.  Let\u0026rsquo;s start explaining step by step.\nBootstrapping backend folder with NestJS As mentioned at the beginning, we will use NestJS for backend. First step will be installing Nest CLI to scaffold the project. Thereafter, we will create a new project:\nnpm i -g @nestjs/cli nest new backend As this will be backend part of the monorepo, we will remove the .git folder created inside backend folder.\nBootstrapping frontend folder Once backend is created, we will proceed creating frontend with React + Typescript using create-react-app:\nnpx create-react-app frontend --template typescript Install prettier Both projects will use Prettier. We will install it inside frontend and backend folder.\ncd backend npm install --save-dev --save-exact prettier cd ../frontend npm install --save-dev --save-exact prettier Now we can create a .prettierrc config file in the root folder (config will be shared with both projects). We can configure with our preferred rules, for example:\n{ \u0026#34;printWidth\u0026#34;: 80, \u0026#34;tabWidth\u0026#34;: 2, \u0026#34;trailingComma\u0026#34;: \u0026#34;all\u0026#34;, \u0026#34;singleQuote\u0026#34;: true, \u0026#34;semi\u0026#34;: true } And now we will create npm scripts for running prettier. In frontend/package.json:\n\u0026#34;scripts\u0026#34;: { // ...  \u0026#34;format\u0026#34;: \u0026#34;prettier --write \u0026#39;src/**/*.{js,jsx,ts,tsx,json,css,scss,md}\u0026#39;\u0026#34; }, In backend/package.json:\n\u0026#34;scripts\u0026#34;: { // ...  \u0026#34;format\u0026#34;: \u0026#34;prettier --write \u0026#39;src/**/*.ts\\\u0026#39; \u0026#39;test/**/*.ts\u0026#39;\u0026#34;, }, Configuring ESLint Presently, we will configure ESLint for linting. We are using Prettier, so we will install a package that will turn off rules that are unnecessary or might conflict with Prettier. Thereafter, we will install a plugin for auto ordering imports, but let\u0026rsquo;s see the basic configuration first.\nWe will go with frontend first:\ncd frontend npm i -D eslint eslint-config-prettier @typescript-eslint/parser Besides, we will create a .eslintrc.js file inside frontend folder:\nmodule.exports = { extends: [ \u0026#39;react-app\u0026#39;, \u0026#39;react-app/jest\u0026#39;, \u0026#39;prettier\u0026#39;, ], parser: \u0026#39;@typescript-eslint/parser\u0026#39;, ignorePatterns: [\u0026#39;.eslintrc.js\u0026#39;], rules: { \u0026#39;no-console\u0026#39;: \u0026#39;warn\u0026#39;, \u0026#39;no-debugger\u0026#39;: \u0026#39;warn\u0026#39;, \u0026#39;no-alert\u0026#39;: \u0026#39;warn\u0026#39;, }, }; This is the most basic configuration for React with Typescript. Conflicts with Prettier are avoided, it\u0026rsquo;s a great starting point for customizing or extending with any config you like.\nAs a bonus, in our project we introduced eslint-plugin-import plugin for sorting the imports following the same criteria. If you are not interested, you can skip this config. We must install these packages:\nnpm i -D eslint-import-resolver-typescript eslint-plugin-import And the final config (you can customize a dozen of rules):\nmodule.exports = { extends: [ \u0026#39;react-app\u0026#39;, \u0026#39;react-app/jest\u0026#39;, \u0026#39;plugin:import/recommended\u0026#39;, \u0026#39;plugin:import/typescript\u0026#39;, \u0026#39;prettier\u0026#39;, ], plugins: [\u0026#39;import\u0026#39;], parser: \u0026#39;@typescript-eslint/parser\u0026#39;, ignorePatterns: [\u0026#39;.eslintrc.js\u0026#39;], rules: { \u0026#39;no-console\u0026#39;: \u0026#39;warn\u0026#39;, \u0026#39;no-debugger\u0026#39;: \u0026#39;warn\u0026#39;, \u0026#39;no-alert\u0026#39;: \u0026#39;warn\u0026#39;, \u0026#39;import/order\u0026#39;: [ \u0026#39;error\u0026#39;, { groups: [\u0026#39;builtin\u0026#39;, \u0026#39;external\u0026#39;, \u0026#39;parent\u0026#39;, \u0026#39;sibling\u0026#39;, \u0026#39;index\u0026#39;], pathGroups: [ { pattern: \u0026#39;react**\u0026#39;, group: \u0026#39;builtin\u0026#39;, position: \u0026#39;after\u0026#39;, }, { pattern: \u0026#39;*.scss\u0026#39;, patternOptions: { matchBase: true }, group: \u0026#39;index\u0026#39;, position: \u0026#39;after\u0026#39;, }, ], pathGroupsExcludedImportTypes: [\u0026#39;react\u0026#39;], \u0026#39;newlines-between\u0026#39;: \u0026#39;always\u0026#39;, alphabetize: { order: \u0026#39;asc\u0026#39;, caseInsensitive: true, }, warnOnUnassignedImports: true, }, ], }, settings: { \u0026#39;import/parsers\u0026#39;: { \u0026#39;@typescript-eslint/parser\u0026#39;: [\u0026#39;.ts\u0026#39;, \u0026#39;.tsx\u0026#39;], }, }, }; Now, when eslint --fix is executed, all the imports should be auto-formatted.\n NOTE: No named imports can be auto-ordered because, in this kind of imports, the order matters. These imports will be marked as error, but must be reordered manually.\nExample: import \u0026lsquo;./App.scss\u0026rsquo;;\n Finally, we can remove from package.json the ESLint config that was created by create-react-app:\n\u0026#34;eslintConfig\u0026#34;: { \u0026#34;extends\u0026#34;: [ \u0026#34;react-app\u0026#34;, \u0026#34;react-app/jest\u0026#34; ] }, Once ESLint is running in frontend, let\u0026rsquo;s dig into the backend. NestJS comes with a default config, which is a great starting point. We will tweak it, and install eslint-plugin-import.\ncd backend npm i -D eslint-import-resolver-typescript eslint-plugin-import And the final .eslintrc.js config file, with prettier plugin and imports config:\nmodule.exports = { parser: \u0026#39;@typescript-eslint/parser\u0026#39;, plugins: [\u0026#39;@typescript-eslint/eslint-plugin\u0026#39;, \u0026#39;import\u0026#39;], extends: [ \u0026#39;plugin:@typescript-eslint/recommended\u0026#39;, \u0026#39;plugin:import/recommended\u0026#39;, \u0026#39;plugin:import/typescript\u0026#39;, \u0026#39;prettier\u0026#39;, ], root: true, env: { node: true, jest: true, }, ignorePatterns: [\u0026#39;.eslintrc.js\u0026#39;], rules: { \u0026#39;no-console\u0026#39;: \u0026#39;warn\u0026#39;, \u0026#39;no-debugger\u0026#39;: \u0026#39;warn\u0026#39;, \u0026#39;@typescript-eslint/interface-name-prefix\u0026#39;: \u0026#39;off\u0026#39;, \u0026#39;@typescript-eslint/explicit-function-return-type\u0026#39;: \u0026#39;off\u0026#39;, \u0026#39;@typescript-eslint/explicit-module-boundary-types\u0026#39;: \u0026#39;off\u0026#39;, \u0026#39;@typescript-eslint/no-explicit-any\u0026#39;: \u0026#39;off\u0026#39;, \u0026#39;@typescript-eslint/ban-ts-comment\u0026#39;: \u0026#39;off\u0026#39;, \u0026#39;import/order\u0026#39;: [ \u0026#39;error\u0026#39;, { groups: [\u0026#39;builtin\u0026#39;, \u0026#39;external\u0026#39;, \u0026#39;parent\u0026#39;, \u0026#39;sibling\u0026#39;, \u0026#39;index\u0026#39;], pathGroups: [ { pattern: \u0026#39;@nestjs**\u0026#39;, group: \u0026#39;builtin\u0026#39;, position: \u0026#39;after\u0026#39;, }, ], pathGroupsExcludedImportTypes: [\u0026#39;@nestjs\u0026#39;], \u0026#39;newlines-between\u0026#39;: \u0026#39;always\u0026#39;, alphabetize: { order: \u0026#39;asc\u0026#39;, caseInsensitive: true, }, warnOnUnassignedImports: true, }, ], }, settings: { \u0026#39;import/parsers\u0026#39;: { \u0026#39;@typescript-eslint/parser\u0026#39;: [\u0026#39;.ts\u0026#39;, \u0026#39;.tsx\u0026#39;], }, }, }; Git pre-commit hook We want to perform some operations on files committed, such as format with prettier and lint with eslint --fix. To achieve this, we will use Husky to run this actions with git hooks.\nInstalling husky We must create a package.json file in the root folder, to install husky dependency. We will run:\nnpm init -y Thereafter, we can fill the fields we want, and now, we will install husky and create and run the prepare script:\nnpm i -D husky npm set-script prepare \u0026#34;husky install\u0026#34; npm run prepare prepare is a lifecycle script, and will be executed after we execute npm install in a repository. If we are using Yarn, maybe husky is not installed automatically after install. In that case, we should manually run:\nnpm run prepare Finally, we can add pre-commit hook. We will run npm run lint on pre-commit (we will define this script in a while).\nnpx husky add .husky/pre-commit \u0026#34;npm run lint\u0026#34; A file named pre-commit under .husky folder will appear with this content:\n#!/bin/sh . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; npm run lint  NOTE: If you run Git from an app like Sourcetree, and get an error about command not found, you must create a ~/.huskyrc file to load the necessary before running hooks (described here). For example, for nvm:\n# ~/.huskyrc # This loads nvm.sh and sets the correct PATH before running hook export NVM_DIR=\u0026#34;$HOME/.nvm\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34;  Adding npm scripts in root package.json Once defined the hook, we must create lint script in the root package.json. This script will run 2 scripts, one for backend linting, and the other for frontend. These are the lines added:\n\u0026#34;scripts\u0026#34;: { // ...  \u0026#34;lint\u0026#34;: \u0026#34;npm-run-all lint:backend lint:frontend\u0026#34;, \u0026#34;lint:backend\u0026#34;: \u0026#34;cd backend \u0026amp;\u0026amp; npm run lint:staged\u0026#34;, \u0026#34;lint:frontend\u0026#34;: \u0026#34;cd frontend \u0026amp;\u0026amp; npm run lint:staged\u0026#34;, }, We are using npm-run-all on lint script for executing the other 2 scripts, so we will install this dependency in root package.json:\nnpm i -D npm-run-all The next step, is defining lint:staged script in backend/package.json and in frontend/package.json as well, but before that, we will install another dependency for linting.\nInstalling tsc-files tsc-files is a tiny tool to run tsc on specific files without ignoring tsconfig.json. This package was created because passing specific files like tsc --noEmit file1.ts file2.ts will cause TypeScript to simply ignore the tsconfig.json.\nWe install tsc-files, which will be needed in the following step:\ncd backend npm i -D tsc-files cd ../frontend npm i -D tsc-files lint-staged in backend and frontend lint-staged is a package that allows us to run linters on staged git files. This way, we won\u0026rsquo;t let bugs slip into our code base, and we will take the opportunity to format committed files.\nWe will install this development dependency in backend and frontend:\ncd backend npm i -D lint-staged cd ../frontend npm i -D lint-staged Now, we will define lint-staged config for running our tasks. We can define config inside package.json or in a separate file. For both projects, we will run eslint --fix, tsc for type check and prettier for format.\nFurthermore, we have to add a script called lint:staged, which is called from root package.json.\nWe will go with the first one, so:\nbackend/package.json\n\u0026#34;scripts\u0026#34;: { // ...  \u0026#34;lint:staged\u0026#34;: \u0026#34;lint-staged\u0026#34;, // ... } // ... \u0026#34;lint-staged\u0026#34;: { \u0026#34;src/**/*.+(ts)\u0026#34;: [ \u0026#34;eslint --fix\u0026#34;, \u0026#34;tsc-files --noEmit\u0026#34; ], \u0026#34;src/**/*.{ts,json,md}\u0026#34;: [ \u0026#34;prettier --write\u0026#34; ] } frontend/package.json\n\u0026#34;scripts\u0026#34;: { // ...  \u0026#34;lint:staged\u0026#34;: \u0026#34;lint-staged\u0026#34;, // ... } // ... \u0026#34;lint-staged\u0026#34;: { \u0026#34;src/**/*.+(ts|tsx)\u0026#34;: [ \u0026#34;eslint --fix\u0026#34;, \u0026#34;tsc-files --noEmit\u0026#34; ], \u0026#34;src/**/*.{js,jsx,ts,tsx,json,css,scss,md}\u0026#34;: [ \u0026#34;prettier --write\u0026#34; ], \u0026#34;*.js\u0026#34;: \u0026#34;eslint --cache --fix\u0026#34; } pre-commit summary Once we have completed these steps, we have finished the configuration for pre-commit hook. This is the flow that will be triggered when we make a git commit:\n pre-commit husky script will execute npm run lint defined in root package.json. lint script will go to both backend and frontend folder, and will execute npm run lint:staged. lint-staged will be called and will receive the list of files involved in the commit. If no file match, no action will be executed. If any error is found, commit will be aborted until solved.  Git pre-push hook With this hook, we want to make sure that we don\u0026rsquo;t push any code that can break our unit testing. We will use husky for this purpose too, using the same strategy as pre-commit hook. Let\u0026rsquo;s get right into it. In the root folder:\nnpx husky add .husky/pre-push \u0026#34;npm run pre-push\u0026#34; A file named pre-push under .husky folder will appear with this content:\n#!/bin/sh . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; npm run pre-push Adding npm scripts in root package.json Once defined the hook, we must create pre-push script in the root package.json. This script will run 2 scripts, , one for backend, and the other for frontend. These are the lines added:\n\u0026#34;scripts\u0026#34;: { // ...  \u0026#34;pre-push\u0026#34;: \u0026#34;npm-run-all pre-push:backend pre-push:frontend\u0026#34;, \u0026#34;pre-push:frontend\u0026#34;: \u0026#34;cd frontend \u0026amp;\u0026amp; npm run pre-push\u0026#34;, \u0026#34;pre-push:backend\u0026#34;: \u0026#34;cd backend \u0026amp;\u0026amp; npm run pre-push\u0026#34;, }, The next step, is defining pre-push script in backend/package.json and in frontend/package.json as well.\nprepush-if-changed in backend and frontend prepush-if-changed is a package similar to lint-staged but for git push. It is not as popular as lint-staged, but I tested it, and it works properly. We want to launch unit testing and linting, but only if any file related to backend or frontend is involved in files pushed.\nFor example, if we are pushing changes for frontend, only frontend tests and linting will be launched. Same for backend, and in case both projects have changes, both will be checked.\nWe will install this development dependency in backend and frontend:\ncd backend npm i -D prepush-if-changed cd ../frontend npm i -D prepush-if-changed Now, we will define prepush-if-changed config for running our tasks. We can define config inside package.json or in a separate file.\nBesides, we have to add a script called pre-push (and some other dependents for the task), which is called from root package.json. If any test or linting process fails, git push will be aborted.\nWe will go with the first one, so:\nbackend/package.json\n\u0026#34;scripts\u0026#34;: { // ...  \u0026#34;pre-push\u0026#34;: \u0026#34;npm-run-all pre-push:test lint\u0026#34;, \u0026#34;pre-push:test\u0026#34;: \u0026#34;prepush-if-changed\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;npm-run-all lint:eslint lint:tsc\u0026#34;, \u0026#34;lint:eslint\u0026#34;: \u0026#34;eslint \u0026#39;src/**/*.ts\u0026#39;\u0026#34;, \u0026#34;lint:tsc\u0026#34;: \u0026#34;tsc -p tsconfig.json\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;npm run test:unit \u0026amp;\u0026amp; npm run test:e2e\u0026#34;, \u0026#34;test:unit\u0026#34;: \u0026#34;jest --runInBand\u0026#34;, \u0026#34;test:e2e\u0026#34;: \u0026#34;jest --config ./test/jest-e2e.json\u0026#34;, // ... } // ...  \u0026#34;prepush-if-changed\u0026#34;: { \u0026#34;src/**/*.+(ts)\u0026#34;: \u0026#34;echo \u0026#39;Files changed on backend. Launching tests.\u0026#39; \u0026amp;\u0026amp; npm run test\u0026#34; }, A brief explanation of the process:\n pre-push script will launch pre-push:test that runs prepush-if-changed with the shown config, and after that, lint. If prepush-if-changed config finds any match, will launch test script. test script will launch test:unit and test:e2e. Finally, lint script executes lint:eslint and lint:tsc.  frontend/package.json\n\u0026#34;scripts\u0026#34;: { // ...  \u0026#34;pre-push\u0026#34;: \u0026#34;npm-run-all pre-push:test lint\u0026#34;, \u0026#34;pre-push:test\u0026#34;: \u0026#34;prepush-if-changed\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;npm-run-all lint:eslint lint:tsc\u0026#34;, \u0026#34;lint:eslint\u0026#34;: \u0026#34;eslint \u0026#39;src/**/*.{ts,tsx}\u0026#39;\u0026#34;, \u0026#34;lint:tsc\u0026#34;: \u0026#34;tsc -p tsconfig.json\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;react-scripts test\u0026#34;, // ... } // ...  \u0026#34;prepush-if-changed\u0026#34;: { \u0026#34;src/**/*.+(ts|tsx)\u0026#34;: \u0026#34;echo \u0026#39;Files changed on frontend. Launching tests.\u0026#39; \u0026amp;\u0026amp; npm run test -- --watchAll=false\u0026#34; }, Note for frontend:\n pre-push script will launch pre-push:test that runs prepush-if-changed with the shown config, and after that, lint. If prepush-if-changed config finds any match, will launch npm run test -- --watchAll=false. Finally, lint script executes lint:eslint and lint:tsc.  Wow this was a huge post, very interesting for future reference. A lot of topics, I published the final result in Github. In my team we have been using this config for the last 3 months, and we are pleased with the result. Thanks for reading.\n","summary":"In my current job, I have had to configure a monorepo with git hooks, ESLint, Prettier and some custom actions."},{"url":"/en/blog/2021-in-review/","title":"2021 in review","content":"I have never done this before, but I think having my own blog is a good opportunity to start reviewing my year, in personal and professional environment.\nPersonal highlights Coming back to exercise After more than 1 year without exercising, I went back to the swimming pool. Once my family got vaccinated, I started going to the swimming pool again. I had different pains in my body, and, 2020 caused me a lot of stress because of work and some personal situations. I started once or twice per week, and I finished with 3 seasons per week. Likewise, I am delighted I did it!\nImproving my English This was a goal pending since some years ago, I could write and read in English without problems, but listening and specially speaking were my weak points. It\u0026rsquo;s something you can practice, so I started English conversation classes once per week.\nBesides, I started watching series in English with subtitles. I watched the 10 seasons of Friends, and I started Downtown Abbey. I don\u0026rsquo;t know if I will be able to watch entirely without peeking the subtitles, but I will try.\nA nice tool I am using for checking my posts, emails, etc. is LanguageTool. I got a subscription for 1 year, and I am pleased.\nChange in my career After almost 4 years working in Renta 4 bank, I started searching for a new job. I had always been working in consultancy, and this was my first opportunity in a final client. I never regret about my decisions, and with the information I had, it seemed a good opportunity.\nAfter 2 years, I realized that I was stuck in a place with old technology and with no perspective of evolution. I almost changed my job in March 2019, I had a superb opportunity, but then the pandemic started, everything was delayed and when they contacted me again, I preferred not moving in a time.\nI thought that working in a final client was the right step, a position stable with a constant salary evolution perhaps, but I realized that we spend a lot of time working, so it is crucial being happy with what you have to do day to day.\nNowadays, for me, it is essential having the possibility of remote working, for organizing my schedule and being able to enjoy as much time as possible with my kid.\nFinally, I started as Frontend Developer at Cognizant, I think it is a good opportunity for learning, working in team in international projects and improving my English, so I am very thrilled with the movement. At this moment, I am working 100% full remote, but in the future I will assist a couple of mornings per week to the office.\nCovid-19 vaccine I got vaccinated with Pfizer 💉💉. Everybody is fed up with the pandemic, there is a lot of information, and sometimes we doubt about if it will finish any day. Now I am waiting for the third dose, but nowadays is difficult escaping from Omicron.\nProfessional/Work skills highlights I started 2021 with the objective of learning Vue 3. I created a personal invented project called financial-bank. I didn\u0026rsquo;t finish it, but I learnt and played with Tailwind, Vue and Typescript. It\u0026rsquo;s in develop branch, if I have time in the future I have several things in my head I wanted to apply.\nIn the last 3 months, I have been learning React. React is one of the most popular frameworks, many people use it, write libraries and articles about it, maybe it will be the most used library soon when jQuery leaves the first place.\nI didn\u0026rsquo;t know anything about React, I try not to drive myself crazy about learning constantly new frameworks. Knowing Angular and Vue was enough for me, but I was assigned to a React project, so here I am, now I have some experience with the big three!\nI created some repos and Github (216 contributions in the last year), and I wrote 6 blogs post in 2021. Moreover, I created a theme for VSCode called Oceanic Wind, I love it, you should try it.\nGoals for 2022 These are my goals for 2022:\n  Making more exercise and gain a bit of muscle (I think it will help me with some of my chronic pain). I am changing my diet with 8fit and exercising sometimes at home.\n  Elevating my swimming skills with different kind of workouts. I purchased Garmin Swim 2 to track my sessions. Swimming 3 times per week is my objective.\n  Reading more. In English and in Spanish, I hope I can have a couple of hours per week.\n  Getting C1 certificate in English.\n  Converting myself into a Javascript fullstack developer.\n  Publishing more posts in the blog.\n  💪🏻💪🏻\n","summary":"I have never done this before, but I think having my own blog is a good opportunity to start reviewing my year, in personal and professional environment."},{"url":"/en/blog/restore-grub-after-installing-windows/","title":"Restore grub after installing Windows","content":"In this article, we are going to cover how to restore grub after installing Windows. I had Windows 7 and Ubuntu on my laptop, so after a long time thinking in upgrading to Windows 10, finally, I decided to do it. It is a good practice when setting up a computer, installing Windows and thereafter Linux. This way, Linux will take care of configuring grub.\nIf you have to install Windows after Linux, Windows will remove grub, and you must restore it. Here are the steps for recovering grub in an easy way.\nBoot repair to the rescue Boot repair disk is a rescue tool that will help us in a very straightforward way to bring back grub. Just download the iso for your computer and burn it into a live USB with Rufus. Reboot the system and make sure that USB source is on the top of the list for booting devices in your BIOS.\nOnce Boot repair is loaded, you can connect to internet in order to download the latest version, click on \u0026ldquo;Recommended repair\u0026rdquo; and reboot.\nThat\u0026rsquo;s it! When you reboot, you should see the screen for selecting which operative system you would like to run.\n","summary":"In this article, we are going to cover how to restore grub after installing Windows."},{"url":"/en/blog/integrate-stylelint-in-vue-project/","title":"Integrate stylelint in Vue project","content":"Stylelint is to CSS the equivalent to ESLint to Javascript. Until today, I was using CSS validation integrated in VSCode, but if we want to go further preventing errors or getting a better style consistency, a linter to CSS is the best option.\nDependencies Let\u0026rsquo;s see how we can configure Stylelint to get validations and turn off default warnings from VSCode.\nFirst, we will need adding some dependencies to our project:\n stylelint: The linter. stylelint-config-standard: Base config. We can configure our own base from scratch or choosing another option as stylelint-config-recommended. stylelint-config-recommended-vue: Vue config with some rules, it adds support for some vue custom CSS selectors, for example ::v-slotted. It automatically adds an override for vue files using postcss-html as custom syntax. postcss-html: Necessary to be able to lint .vue files.  Therefore, we install them: npm install stylelint stylelint-config-standard stylelint-config-recommended-vue postcss-html --save-dev\nStylelint in VSCode The next step is installing official Stylelint extension for VSCode.\nWe will add the following settings in our VSCode workspace settings (or global) in order to disable CSS built-in lint. If we are using Vetur, we also need to disable style validation.\nMoreover, since Stylelint version 14, we must specify different styling languages to be linted, in our case vue.\nAdditionally, I have fixAll to be executed on save.\n{ \u0026#34;css.validate\u0026#34;: false, // Disable built-in lint \u0026#34;less.validate\u0026#34;: false, // Disable built-in lint \u0026#34;scss.validate\u0026#34;: false, // Disable built-in lint \u0026#34;stylelint.enable\u0026#34;: true, // Enable stylelint \u0026#34;stylelint.validate\u0026#34;: [\u0026#34;css\u0026#34;, \u0026#34;less\u0026#34;, \u0026#34;postcss\u0026#34;, \u0026#34;vue\u0026#34;], // Add vue files \u0026#34;vetur.validation.style\u0026#34;: false, // Disable vetur style validation \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.fixAll.stylelint\u0026#34;: true }, } Stylelint config file Last but not least, we must create Stylelint config file at our project root. .stylelintrc:\n{ \u0026#34;extends\u0026#34;: [ \u0026#34;stylelint-config-standard\u0026#34;, \u0026#34;stylelint-config-recommended-vue\u0026#34; ], \u0026#34;rules\u0026#34;: { } } If we don\u0026rsquo;t add stylelint-config-recommended-vue, we will have to put the override to lint vue files:\n{ \u0026#34;extends\u0026#34;: [ \u0026#34;stylelint-config-standard\u0026#34;, \u0026#34;stylelint-config-recommended-vue\u0026#34; ], \u0026#34;overrides\u0026#34;: [ { \u0026#34;files\u0026#34;: [ \u0026#34;**/*.vue\u0026#34; ], \u0026#34;customSyntax\u0026#34;: \u0026#34;postcss-html\u0026#34; } ], \u0026#34;rules\u0026#34;: { } } With all this configuration, our project is ready to use Stylelint for CSS linting.\nAdding own rules We can specify our custom rules. For example, in a project where we are using Tailwind CSS, we avoid the following warning when using @apply: Unknown at rule @applycss(unknownAtRules). This crucial if we are working with PostCSS plugins and want to avoid some warnings. Example for Tailwind CSS syntax:\n{ \u0026#34;extends\u0026#34;: [ \u0026#34;stylelint-config-standard\u0026#34;, \u0026#34;stylelint-config-recommended-vue\u0026#34; ], \u0026#34;rules\u0026#34;: { \u0026#34;at-rule-no-unknown\u0026#34;: [ true, { \u0026#34;ignoreAtRules\u0026#34;: [ \u0026#34;tailwind\u0026#34;, \u0026#34;apply\u0026#34;, \u0026#34;variants\u0026#34;, \u0026#34;responsive\u0026#34;, \u0026#34;screen\u0026#34; ] } ], \u0026#34;block-no-empty\u0026#34;: null, \u0026#34;declaration-block-trailing-semicolon\u0026#34;: null, \u0026#34;no-descending-specificity\u0026#34;: null } } Useful links:\n Stylelint stylelint-config-recommended-vue PostCSS HTML Syntax  Happy CSS linting!\n","summary":"Stylelint is to CSS the equivalent to ESLint to Javascript. Until today, I was using CSS validation integrated in VSCode, but if we want to go further preventing errors or getting a better style consistency, a linter to CSS is the best option."},{"url":"/en/blog/oceanic-wind-for-vscode/","title":"Oceanic Wind for VSCode","content":" I have created a VSCode dark theme called Oceanic Wind, but, why did I do that? Well, I have been using Oceanic Next theme for many years, first time I used it with Sublime Text, and I wanted to tweak it.\nIt is based on color combinations from Oceanic Next replaced and customized with Tailwind CSS color palette.\nI\u0026rsquo;m a person who usually needs time to get used to changes, and, since I moved to VSCode, there were not many ports for the theme (nowadays there are much more), and I felt that which I was using didn\u0026rsquo;t convince me at all. So, I decided creating my own theme with good contrast.\nWhen I started creating the theme I didn\u0026rsquo;t know there were so many colors and possibilities to customize VSCode. I decided to customize every color I could find, in most cases I just changed the default color from VSCode with one picked from the Tailwind palette.\nCreate your own theme If you want to create your own theme you can follow the steps from Visual Studio Code guide. This is what I did:\nFirst, you have to install Yeoman extension generator and run it:\nnpm install -g yo generator-code yo code Select New color theme and No, start fresh. Give a name and identifier for your extension, and select a base theme to be used as starting point. Now you can open the folder with VSCode.\ncd your-theme code . If you want to test your theme, just press F5 and a new window will be open where you will be able to see the result.\nThe official documentation is the perfect starting point. As you can see, there are dozens of colors available, sometimes finding the color for a setting can be difficult despite the description, there are a few I couldn\u0026rsquo;t find.\nFinding colors Press Ctrl + Shift + P to get the command palette and type Inspect Editor Tokens and Scopes. Now you can click anywhere, and you will see a pop-up with color, font type and scope to target. You have also information about contrast ratio, I always try getting 4.5 as minimum value.\nVSCode has Developer tools you can use to inspect any information you want. Press Ctrl + Shift + P and type Toggle Developer Tools to open theme.\nVery useful if you want to quickly find any color from any theme you are peeking for inspiration. I used this method at the beginning in order to find default VSCode colors, but there are some elements difficult to inspect as minimap.\nFinally, I ended searching default colors in VSCode Github repository. Just search the setting name (without the dot), activityBar inactiveForeground for example, and dig into the different files.\nI created a gist with all dark default colors in VSCode, some values are not 100% accurate because sometimes they use a darken or lighten function to get some colors, or they apply a transparency to a color that has already transparency, but you can save time if you need default colors, I couldn\u0026rsquo;t find any reference with all the values.\nAccent color You can overwrite colors for a given theme in VSCode settings. I have created a different set of colors to provide accent color to VSCode. If you would like to try another color instead of blue for the accent of your IDE, you can use these different combinations:\n Indigo Green Rose Teal Fuchsia Amber Esmerald Sky  I tested the contrast ratio for the different accent colors and there should not be any big issue with contrast. I must review it because I didn\u0026rsquo;t test it yet with Warm and Cool version of the theme.\nCreating with a defined color palette Once I finished the theme, I could easily generate numerous variations. Just replacing the gray with the 5 different kind of grays from Tailwind, I can generate 40 different variations (8 accent colors x 5 kind of grays = 40). That is just a possibility, I decided going with neutral gray for the default, warm gray for the warm version and blue gray for the cool version.\nI wanted to avoid polluting the theme selector on VSCode with 40+ variations, so I just left 3 versions with blue as accent color, and if anybody wants to customize further can copy/paste the setting from different accent colors. It\u0026rsquo;s so easy generating different color schemes when you have a color palette!\nTesting The default way of testing your theme can be insufficient for some cases. In these cases, I used this trick: You can just copy your folder with you extension files into .vscode folder. In Windows for example:\nC:\\Users\\your-user\\.vscode This way you can enable locally your theme and test it in any workspace you want.\nYou can make changes in the theme folder, but be sure to reload VSCode instance to be able to see your changes (you can press Ctrl + Shift + P and type Reload window).\nYou can also go to your user settings, and overwrite colors for your theme to get instant feedback of the change. This is a big time saver!\nConclusion Once finished I just followed the official guide to publish the theme.\nI have tested this theme focused on my day-to-day workflow, with HTML, CSS, Javascript, Typescript and developing with frameworks such as Angular, Vue and React. Furthermore, I have tried with files you can find in demo folder (thanks to Wes Bos and Sarah Drasner).\nIf you find something amiss, you have any suggestion or improvement, please feel free to open and issue. I\u0026rsquo;m sure there are things I missed.\nI am not a designer, so any help or feedback would be really appreciated.\n Oceanic Wind at Marketplace Github repository Default dark colors on VSCode  ","summary":"I have created a VSCode dark theme called Oceanic Wind, but, why did I do that?"},{"url":"/en/blog/setting-up-standardjs/","title":"Setting up StandardJS","content":"In this post, we will cover the setup of StandardJS in VSCode to fix all the errors when saving a file automatically.\nWhat is StandardJS? Initially, you could think that StandardJS is the standard used for Javascript code, and, that is its main goal: provide a style guide, linter and, formatter for Javascript. Really, it\u0026rsquo;s not, we know about the different opinions about all concerning to Javascript ecosystem. The idea behind StandardJS is good, you install it, and you don\u0026rsquo;t worry about defining rules anymore. I had heard about it, but I had never given it a try (personally, I am used to Prettier as formatter). Here are some of the advantages:\n Avoid setting up rules for style decisions. Code auto formatting running standard --fix. Error and incorrect style detection in code.  StandardJS uses a fixed set of rules defined with ESLint.\nSetting up StandardJS The first is step is installing the package. You can do it globally or locally in a project. I always try using the last one in order to have under control all the dependencies.\nnpm install standard --save-dev You can fix at any moment all the problems founds automatically (some errors can\u0026rsquo;t be auto-fixed, you must fix it on your own) with:\nstandard --fix You can create a npm script to run the command, but in my opinion integrating into the editor is much better.\nAutoformat in VSCode I have used StandardJS for the first time in a job mate project, and at the beginning it was driving me crazy. I had Prettier as default formatter and when I was saving a file I had different kind of formats because Prettier was violating StandardJS rules.\nIs asked my teammate how did he format the code when saving a file, and he answered me that he didn\u0026rsquo;t do it. Simply when he saw an error in a file he clicked the bubble and selected Fix all. I hate this kind of repetitive tasks, so I investigated the solution in VSCode which I proceed to describe in the next lines.\nFirst, we have to install StandardJS extension for VSCode. As StandardJs is using ESLint under the hood, we will also install ESLint extension.\nIf you use Prettier as default formatter for Javascript as I do, you should disable it on the workspace of your project. At workspace level we will use the following setting which appears in the extension documentation. This way we are enabling auto-fix, but it\u0026rsquo;s necessary adding the highlighted lines to make work everything properly.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  { \u0026#34;standard.enable\u0026#34;: true, \u0026#34;standard.run\u0026#34;: \u0026#34;onSave\u0026#34;, \u0026#34;standard.autoFixOnSave\u0026#34;: true, \u0026#34;standard.validate\u0026#34;: [ \u0026#34;javascript\u0026#34;, \u0026#34;javascriptreact\u0026#34;, \u0026#34;typescript\u0026#34;, \u0026#34;typescriptreact\u0026#34; ], \u0026#34;javascript.validate.enable\u0026#34;: false, \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.fixAll.eslint\u0026#34;: true },  \u0026#34;[javascript]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: null } }   Let\u0026rsquo;s check that everything is working as expected. We just have to open a Javascript file and save it. File must be auto-formatted and all the error should disappear.\nAs conclusion, I prefer Prettier for formatting because I can use the same tool as well for HTML and CSS. I can define and apply rules directly with ESLint, but StandardJS is a superb tool that can avoid long discussions about opinionated things.\n","summary":"In this post, we will cover the setup of StandardJS in VSCode to fix all the errors when saving a file automatically."},{"url":"/en/blog/vue-3-with-typescript-eslint-and-prettier/","title":"Vue 3 with Typescript, ESLint and Prettier","content":"At the beginning of this year I started learning Vue 3, I had worked with version 2 before and the new version allows us to still use the same syntax, besides we can use the new Composition API, which is more powerful and customizable when creating reusable elements. In this post I will show how to create a new project with Vue 3 + Typescript and setting up ESLint and Prettier for working properly together in Visual Studio Code.\nVue CLI The easiest and fastest way for creating a new project is using Vue CLI. It will allow us to set up the project using different predefined workflows. First of all we will install Vue CLI:\nyarn global add @vue/cli # OR npm install -g @vue/cli Once installed we can create a new project:\nvue create hello-world We will select the last option from the list:\n Vue CLI v4.5.13 ? Please pick a preset: (Use arrow keys) Default ([Vue 2] babel, eslint) Default (Vue 3) ([Vue 3] babel, eslint)  Manually select features  And we can customize our project with the options present in the list. I chose the next ones, I didn\u0026rsquo;t select testing in order to focus on the topic:\n Vue CLI v4.5.13 ? Please pick a preset: Manually select features ? Check the features needed for your project: (*) Choose Vue version (*) Babel (*) TypeScript ( ) Progressive Web App (PWA) Support (*) Router ( ) Vuex ( ) CSS Pre-processors (*) Linter / Formatter ( ) Unit Testing ( ) E2E Testing  At the next step we will have to select more things, we choose version 3 and ESLint + Prettier at the end.\n Vue CLI v4.5.13 ? Please pick a preset: Manually select features ? Check the features needed for your project: Choose Vue version, Babel, TS, Router, Linter ? Choose a version of Vue.js that you want to start the project with 3.x ? Use class-style component syntax? No ? Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? Yes ? Use history mode for router? (Requires proper server setup for index fallback in production) Yes ? Pick a linter / formatter config: ESLint with error prevention only ESLint + Airbnb config ESLint + Standard config  ESLint + Prettier TSLint (deprecated)  After selection Vue CLI will start installing the dependencies. Once finished we can run npm run serve so that our new application will launch in development mode.\nESLint + Prettier The Vue team has done a great job in order to avoid us headaches setting up ESLint and Prettier. If we open .eslintrc.js file we will see these plugins installed:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  module.exports = { root: true, env: { node: true, }, extends: [ \u0026#34;plugin:vue/vue3-essential\u0026#34;, \u0026#34;eslint:recommended\u0026#34;, \u0026#34;@vue/typescript/recommended\u0026#34;, \u0026#34;@vue/prettier\u0026#34;, \u0026#34;@vue/prettier/@typescript-eslint\u0026#34;, ],  parserOptions: { ecmaVersion: 2020, }, rules: { \u0026#34;no-console\u0026#34;: process.env.NODE_ENV === \u0026#34;production\u0026#34; ? \u0026#34;warn\u0026#34; : \u0026#34;off\u0026#34;, \u0026#34;no-debugger\u0026#34;: process.env.NODE_ENV === \u0026#34;production\u0026#34; ? \u0026#34;warn\u0026#34; : \u0026#34;off\u0026#34;, \u0026#34;arrow-parens\u0026#34;: \u0026#34;off\u0026#34;, \u0026#34;eol-last\u0026#34;: \u0026#34;error\u0026#34;,  }, overrides: [ { files: [ \u0026#34;**/__tests__/*.{j,t}s?(x)\u0026#34;, \u0026#34;**/tests/unit/**/*.spec.{j,t}s?(x)\u0026#34;, ], env: { jest: true, }, }, ], };   This way Prettier won\u0026rsquo;t conflict with ESLint rules. At lines 19-20 there are custom rules added by me, we can add what we want in order to customize it.\nVSCode Last but not least, we will configure VSCode in order to have everything working properly. The most important thing is having installed the Vetur extension, which gives us a great development experience with Vue in VSCode. It will give us auto formatting code in Single File Components (files with .vue extension).\nOnce installed, we will go to Vetur settings and in Format -\u0026gt; Default Formatter section we will select the formatters for HTML, CSS, JS, Sass, Typescript\u0026hellip; It is very important to select prettier-eslint for JS, I have the default option in the rest including Typescript, with just Prettier instead of prettier-tslint which is deprecated.\nIn VSCode settings we must add Vetur as default formatter for Vue:\n\u0026#34;[vue]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;octref.vetur\u0026#34; } This way VSCode delegates in Vetur, and Vetur will format each different language that finds inside .vue files with a proper formatter. In my experience, there is only one thing wrong with auto format in .vue files, inserting the final new line at the end of the file. If you use this rule (which is the default), the only way I could find is delegating this task in VSCode with this setting:\n\u0026#34;files.insertFinalNewline\u0026#34;: false Sometimes using the last version of Vetur can be problematic, recently in a project Vetur started formatting HTML in a different way. After struggling for some hours I realized Vetur had been updated and after downgrading Vetur version everything started working as expected. I reported the bug and took the opportunity to comment on the problem with the final new line. Maybe I made a mistake, but I couldn\u0026rsquo;t find the problem after several hours.\nAfter completing all the steps we are now ready to begin new projects with Vue 3 + Typescript + ESLint + Prettier in VSCode.\n","summary":"At the beginning of this year I started learning Vue 3, I had worked with version 2 before and the new version allows us to still use the same syntax, besides we can use the new Composition API, which is more powerful and customizable when creating reusable elements."},{"url":"/en/blog/responsive-images-in-hugo/","title":"Responsive images in Hugo","content":"In this post I will share a very useful shortcode that will allow us processing images automatically with Hugo. First of all, we must be sure that our content is structured in Hugo´s page bundles. When I created my blog, I migrated from wordpress and all articles were named like this:\n responsive-images-hugo - responsive-images-hugo.md using-tailwindcss-with-angular - using-tailwindcss-with-angular.md  And all the images were placed inside /static folder. That structure will not be recognized by Hugo as page bundles so I had to reorganize every post. A very basic summary for page bundles:\n _index.md files are considered index of a section and list.html template will be used. index.md (or index.en.md, index.es.md) files are considered index of a page/post and single.html template will be used.  Now the structure for each post is:\n responsive-images-hugo - index.md - index.en.md img - img1.jpg - ...  The next step is creating a file for the shortcode, I created in layouts/shortcodes/img.html with this code: {{/* Get file that matches the filename as specified as src=\u0026#34;\u0026#34; in shortcode */}} {{$src:=.Page.Resources.GetMatch(printf\u0026#34;*%s*\u0026#34;(.Get\u0026#34;src\u0026#34;))}} {{/* Set image sizes, these are hardcoded for now, x dictates that images are resized to this width */}} {{$tinyw:=default\u0026#34;500x\u0026#34;}} {{$smallw:=default\u0026#34;800x\u0026#34;}} {{$mediumw:=default\u0026#34;1200x\u0026#34;}} {{$largew:=default\u0026#34;1500x\u0026#34;}} {{/* Initialize variables */}} {{$tiny:=\u0026#34;\u0026#34;}} {{$small:=\u0026#34;\u0026#34;}} {{$medium:=\u0026#34;\u0026#34;}} {{$large:=\u0026#34;\u0026#34;}} {{/* Resize the src image to the given sizes if necessary */}} {{ifge$src.Width\u0026#34;500\u0026#34;}} {{$tiny=$src.Resize$tinyw}} {{end}} {{ifge$src.Width\u0026#34;800\u0026#34;}} {{$small=$src.Resize$smallw}} {{end}} {{ifge$src.Width\u0026#34;1200\u0026#34;}} {{$medium=$src.Resize$mediumw}} {{end}} {{ifge$src.Width\u0026#34;1500\u0026#34;}} {{$large:=$src.Resize$largew}} {{end}} \u0026lt;img class=\u0026#39;mb-6 {{with.Get\u0026#34;class\u0026#34;}}{{.}}{{end}}\u0026#39; srcset=\u0026#39; {{with$src.RelPermalink}}{{.}}{{$src.Width}}w{{end}}{{ifge$src.Width\u0026#34;500\u0026#34;}}{{with$tiny.RelPermalink}},{{.}}500w{{end}}{{end}}{{ifge$src.Width\u0026#34;800\u0026#34;}}{{with$small.RelPermalink}}, {{.}}800w{{end}}{{end}}{{ifge$src.Width\u0026#34;1200\u0026#34;}}{{with$medium.RelPermalink}}, {{.}}1200w{{end}}{{end}}{{ifge$src.Width\u0026#34;1500\u0026#34;}}{{with$large.RelPermalink}}, {{.}}1500w {{end}}{{end}}\u0026#39; src=\u0026#34;{{$src.RelPermalink}}\u0026#34; width=\u0026#34;{{$src.Width}}\u0026#34; height=\u0026#34;{{$src.Height}}\u0026#34; {{with.Get\u0026#34;alt\u0026#34;}}alt=\u0026#39;{{.}}\u0026#39;{{end}}\u0026gt;\nThis way we will be able to use in markdown files the shortcode: {{\u0026lt;imgsrc=\u0026#34;img/img1.jpg\u0026#34;alt=\u0026#34;Description for image\u0026#34;\u0026gt;}}\nAnd that´s all, you use the image as if you were in html and the shortcode and Hugo will generate images smaller when necessary. This solution comes from Laura Kalbag, I just modified a little bit her code. I take this opportunity to recomendate her book Accessibility For Everyone.\n","summary":"In this post I will share a very useful shortcode that will allow us processing images automatically with Hugo."},{"url":"/en/blog/search-in-hugo-with-lunr/","title":"Search in Hugo with Lunr","content":"¿What is the best way to make a search engine in Hugo? My first attempt was looking for information in the official documentation, I found some guides and links which helped me, but none of them suited my needs. So I will detail in this guide the solution that I have developed.\nEvery guide suggest these 2 possibilities:\n  Algolia: It´s a service that provides a set of tools that simplify the process of making and integrating a full search experience into our sites and applications. It has an automated crawler to extract content from web sites. It´s a third party service which allows the integration on a static site easily, we just have to use the provided API in front. Algolia is used in a lot of different sites but I decided I didn´t want to use a third party service.\n  Lunr: Lunr.js is a small, full-text search library for use in the browser. It indexes JSON documents and provides a simple search interface for retrieving documents that best match text queries. It allows fuzzy search that is the technique of finding strings that match a pattern approximately (rather than exactly). This is the approach used in this blog.\n  Defining the output of our content in JSON format Having Lunr as Javascript library for fuzzy search we just need the other part in order to complete our search engine: a JSON file with posts content from the blog. We can define this behaviour in 2 differents ways:\n In Hugo global config file, config.toml in my case. All the content in Hugo will be available in HTML and RSS format by default if no config is provided. In this site, all the blog articles are under what is called in Hugo as section, in content/blog path. We can set global JSON output for every section on this way:  [outputs] section = [\u0026#34;JSON\u0026#34;, \u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] This configuration will output a JSON file for each section. For example, if we have another section (courses) in addition to blog, each one will have its index.json file with the content of the section. This is very powerful and we will be able to make independent searches for each section. But, How can I tell to Hugo the content and format for that JSON file? We have to create a list.json template file like we have list.html for HTML files.\nIf we want each section file different, inside layouts folder and following with this site as example, in a folder called blog we must create a list.json file and inside courses folder we will create another list.json different. However if the format for each section is going to be the same, we can create list.json file inside _default folder and it will be used for every section (unless the section has a list.json file that would replace the global in _default folder).\nLet´s see list.json content finally. It just generates an array of posts using Hugo syntax.\n[ {{range$index,$value:=where.Site.Pages\u0026#34;Type\u0026#34;\u0026#34;post\u0026#34;}} {{if$index}}, {{end}} { \u0026#34;url\u0026#34;: \u0026#34;{{.RelPermalink}}\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;{{.Title}}\u0026#34;, \u0026#34;content\u0026#34;: {{.Content|plainify|jsonify}}, \u0026#34;summary\u0026#34;: \u0026#34;{{.Summary}}\u0026#34; } {{end}} ] Of course the content is completely customizable, and so the name for each field. In my case I have a reduced number of posts, so by the moment I put all the content in content field, but in the future because of better performarnce I will try to reduce the JSON file size leaving just title and summary for the search.\nEnabling for each section the output format from the front matter. Following with my site as example, I have _index.md and _index.en.md (English version) files in content/blog folder. We can enable JSON format on this way:  --- title: Personal blog subtitle: Posts written on a variety of topics related to the world of technology and programming. outputs: - html - rss - json --- The template list.json part is exactly the same than at point 1. You can read more about custom output formats in Hugo documentation.\nImplementing search engine using lunr with Javascript Let´s see the code that will allow us to search in the JSON file generated. In my case, I have created a search.html file in layouts/page. Let´s check step by step the content. First of all we need and input text for the search term, followed by a section element where search results will be showed.\n\u0026lt;label for=\u0026#34;search-input\u0026#34;\u0026gt;Término de búsqueda\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;search-input\u0026#34; name=\u0026#34;search\u0026#34; placeholder=\u0026#34;{{i18n\u0026#34;search_loading\u0026#34;}}...\u0026#34;\u0026gt; \u0026lt;section id=\u0026#34;search-results\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; Javascript code is also inside the html file so that we can create dinamyc vars in Javascript with Hugo, for example for getting translation of strings and getting relative path to index.json for each language.\nNext step is importing Lunr, in my case in static/js/ folder:\n{{$lunr:=\u0026#34;js/lunr.min.js\u0026#34;|absURL}} \u0026lt;script src=\u0026#34;{{$lunr}}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; It would be possible importing Lunr via CDN:\n\u0026lt;script src=\u0026#34;https://unpkg.com/lunr/lunr.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Below is shown the Javascript code that on pageload makes a petition to load index.json file and creates indexed document that will be used to return search results. Searchs will be launched when user is typing in the input field.\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; (function () { let idx; let documents = []; const URL_LIST_POSTS = \u0026#39;{{\u0026#34;blog/index.json\u0026#34;|relLangURL}}\u0026#39;; const searchInput = document.getElementById(\u0026#34;search-input\u0026#34;); const searchResults = document.getElementById(\u0026#34;search-results\u0026#34;); // Request and index documents  fetch(URL_LIST_POSTS, { method: \u0026#34;get\u0026#34;, }) .then((res) =\u0026gt; res.json()) .then((res) =\u0026gt; { // Create index document with lunr  idx = lunr(function () { this.ref(\u0026#34;url\u0026#34;); this.field(\u0026#34;title\u0026#34;); this.field(\u0026#34;content\u0026#34;); this.field(\u0026#34;summary\u0026#34;); res.forEach(function (doc) { this.add(doc); documents[doc.url] = { title: doc.title, content: doc.content, summary: doc.summary, }; }, this); }); // Once data is loaded we can register handler  registerSearchHandler(); }) .catch((err) =\u0026gt; { console.log({ err }); const errorMsg = \u0026#39;{{i18n\u0026#34;search_error\u0026#34;}}\u0026#39;; searchResults.innerHTML = ` \u0026lt;div class=\u0026#34;bg-red-100 border-l-4 border-red-500 text-red-700 p-4\u0026#34; role=\u0026#34;alert\u0026#34;\u0026gt; \u0026lt;p\u0026gt;${errorMsg}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;`; }); ///////////////////////////////////////////////////////////  function renderSearchResults(results) { const noResults = \u0026#39;{{i18n\u0026#34;search_noCoincidence\u0026#34;}}\u0026#39;; // If results are empty  if (results.length === 0) { searchResults.innerHTML = ` \u0026lt;div class=\u0026#34;bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4\u0026#34; role=\u0026#34;alert\u0026#34;\u0026gt; \u0026lt;p\u0026gt;${noResults}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; return; } // Show max 10 results  if (results.length \u0026gt; 9) { results = results.slice(0, 10); } // Reset search results  searchResults.innerHTML = \u0026#34;\u0026#34;; // Append results  results.forEach((result) =\u0026gt; { // Create result item  let article = document.createElement(\u0026#34;article\u0026#34;); article.classList.add(\u0026#34;mb-8\u0026#34;); article.innerHTML = ` \u0026lt;a href=\u0026#34;${result.ref}\u0026#34; class=\u0026#34;block group\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;article-title group-hover:text-green-500 pb-1\u0026#34;\u0026gt;${documents[result.ref].title}\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;text-gray-700 dark:text-gray-300\u0026#34;\u0026gt;\u0026lt;p\u0026gt;${documents[result.ref].summary}\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/a\u0026gt;`; searchResults.appendChild(article); }); } function registerSearchHandler() { // Register on input event  searchInput.oninput = function (event) { if (searchInput.value === \u0026#34;\u0026#34;) { searchResults.innerHTML = \u0026#34;\u0026#34;; return; } // Get input value  const query = event.target.value; // Run fuzzy search  const results = idx.query(function(q) { q.term(lunr.tokenizer(query.trim()), { usePipeline: true, boost: 100 }); q.term(lunr.tokenizer(query.trim()) + \u0026#39;*\u0026#39;, { usePipeline: false, boost: 10 }); q.term(lunr.tokenizer(query.trim()), { usePipeline: false, editDistance: 1 }); }); // Render results  renderSearchResults(results); }; searchInput.placeholder = \u0026#39;{{i18n\u0026#34;search_inputPlaceholder\u0026#34;}}\u0026#39;; } })(); \u0026lt;/script\u0026gt; And that´s all. To develop this solution I have followed the guides of Joseph Earl and Matt Walters. I have adapted and updated Javascript code and corrected the method for searching with Lunr, beacuse it didn´t work properly in all cases. This is the most important part, I found the solution in an issue in Lunr github:\n// Run fuzzy search const results = idx.query(function(q) { q.term(lunr.tokenizer(query.trim()), { usePipeline: true, boost: 100 }); q.term(lunr.tokenizer(query.trim()) + \u0026#39;*\u0026#39;, { usePipeline: false, boost: 10 }); q.term(lunr.tokenizer(query.trim()), { usePipeline: false, editDistance: 1 }); }); You can take a look to search.html file with the complete code in github and adapt it to your needs.\n","summary":"¿What is the best way to make a search engine in Hugo?"},{"url":"/en/blog/using-tailwindcss-with-angular/","title":"Using TailwindCSS with Angular","content":"In this article we are going to explain how to set up an Angular application with Angular CLI in order to integrate TailwindCSS. With this approach the CSS written in our components will be very little because most of the time we will be using Tailwind classes.\nAngular CLI Angular CLI is the recommended command line interface for generating Angular applications. It uses webpack under the hood, but we can´t access directly to webpack settings so if we want to customize any behaviour we can use a package called @angular-builders/custom-webpack. This package will allow us extend webpack config.\nSetting up TailwindCSS TailwindCSS works regardless of CSS preprocessor we use in our application (if we use one). To make the development experience as productive as possible, we will run PurgeCSS just when building for production. Let´s see step by step guide for adding Tailwind:\nFirst of all we will install dependencies:\nnpm install tailwindcss --save npm install --save-dev @angular-builders/custom-webpack @fullhuman/postcss-purgecss Generate an empty Tailwind config file:\nnpx tailwind init Create a new file, and give it the extension depending on the preprocessor you are using. In my case scss, so the file will be src/tailwind.scss where we will insert Tailwind directives. We can also add custom styles using Tailwind directives in this file.\n@tailwind base; @tailwind components; /* Custom CSS */ a.tag { @apply bg-gray-200 rounded-full px-3 py-1 font-semibold text-gray-700; } a.tag:hover { @apply underline; } /* Custom CSS end */ @tailwind utilities; Next step is creating extra-webpack.config.js file on folder root with this content:\nconst purgecss = require(\u0026#39;@fullhuman/postcss-purgecss\u0026#39;)({ // Specify the paths to all of the template files in your project  content: [\u0026#39;./src/**/*.html\u0026#39;, \u0026#39;./src/**/*.component.ts\u0026#39;], // Include any special characters you\u0026#39;re using in this regular expression  defaultExtractor: content =\u0026gt; content.match(/[\\w-/:]+(?\u0026lt;!:)/g) || [] }); module.exports = (config, options) =\u0026gt; { console.log(`Using \u0026#39;${config.mode}\u0026#39; mode`); config.module.rules.push({ test: /tailwind\\.scss$/, use: [ { loader: \u0026#39;postcss-loader\u0026#39;, options: { plugins: [ require(\u0026#39;tailwindcss\u0026#39;)(\u0026#39;./tailwind.config.js\u0026#39;), require(\u0026#39;autoprefixer\u0026#39;), ...(config.mode === \u0026#39;production\u0026#39; ? [purgecss] : []) ] } } ] }); return config; }; angular.json Now we need to edit angular.json config file so that we can customize ng serve and ng build commands. We must search projects.architect.build.builder key and replace @angular-devkit/build-angular:browser with @angular-builders/custom-webpack:browser. It´s neccessary add a new object customWebpackConfig at architect.build.options with key path and extra-webpack.config.js as its value.\nWe must do same changes in projects.architect.serve.builder replacing @angular-devkit/build-angular:dev-server with @angular-builders/custom-webpack:dev-server. It´s neccessary again adding a new object customWebpackConfig at architect.serve.options with key path and extra-webpack.config.js as its value.\nFinally we will add our src/tailwind.scss stylesheet to the array in architect.build.options.styles. Let´s see all the changes together:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  \u0026#34;architect\u0026#34;: { \u0026#34;build\u0026#34;: { \u0026#34;builder\u0026#34;: \u0026#34;@angular-builders/custom-webpack:browser\u0026#34;,  \u0026#34;options\u0026#34;: { \u0026#34;customWebpackConfig\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;extra-webpack.config.js\u0026#34; },  // ...  \u0026#34;styles\u0026#34;: [ \u0026#34;src/tailwind.scss\u0026#34;,  \u0026#34;src/styles.css\u0026#34; ], // ...  } }, \u0026#34;serve\u0026#34;: { \u0026#34;builder\u0026#34;: \u0026#34;@angular-builders/custom-webpack:dev-server\u0026#34;,  \u0026#34;options\u0026#34;: { \u0026#34;customWebpackConfig\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;extra-webpack.config.js\u0026#34; },  // ...  } } }   Once these changes are applied we can init server in development mode with ng serve as usual. All the Tailwind classes will be available. When compiling for production with ng build --prod we can check in dist folder that styles files is generated with only classes that are used in our application.\nchunk {4} styles.847663bf210845648553.css (styles) 5.51 kB [initial] [rendered] PurgeCSS with Tailwind From Tailwind 1.4.0 PurgeCSS is integrated into Tailwind config file. This way we can remove @fullhuman/postcss-purgecss dependency in our project and leave extra-webpack.config.js with this content:\nmodule.exports = (config, options) =\u0026gt; { console.log(`Using \u0026#39;${config.mode}\u0026#39; mode`); config.module.rules.push({ test: /tailwind\\.scss$/, use: [ { loader: \u0026#39;postcss-loader\u0026#39;, options: { plugins: [ require(\u0026#39;tailwindcss\u0026#39;)(\u0026#39;./tailwind.config.js\u0026#39;) ] } } ] }); return config; }; We just move routes to tailwind.config.js file:\nmodule.exports = { purge: [\u0026#39;./src/**/*.html\u0026#39;, \u0026#39;./src/**/*.component.ts\u0026#39;], theme: { extend: {}, }, variants: {}, plugins: [], }; We must compile with NODE_ENV variable set to production so that Tailwind automatically purges unused styles. To achieve this with a multiplatform solution I like using cross-env package. We just install it:\nnpm install cross-env --save-dev After the installation we can create a script in package.json to launch the build:\n1 2 3 4 5 6 7 8 9 10 11 12 13  { // ...  \u0026#34;scripts\u0026#34;: { \u0026#34;ng\u0026#34;: \u0026#34;ng\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;ng serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;ng build\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;ng test\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;ng lint\u0026#34;, \u0026#34;e2e\u0026#34;: \u0026#34;ng e2e\u0026#34;, \u0026#34;build:prod\u0026#34;: \u0026#34;cross-env NODE_ENV=production ng build --prod\u0026#34;  }, // ... }   Now we run the script and check that everything is working as expected:\nnpm run build:prod chunk {4} styles.847663bf210845648553.css (styles) 5.51 kB [initial] [rendered] With these simple steps you are ready to go with Tailwind in your Angular projects.\n","summary":"In this article we are going to explain how to set up an Angular application with Angular CLI in order to integrate TailwindCSS."},{"url":"/en/blog/using-tailwind-css-with-hugo/","title":"Using Tailwind CSS with Hugo","content":"In this article we are going to see how can we build our Hugo site with TailwindCSS. Hugo is very flexible and allows us setting up our site easily as we want. In this web, I have a baseof.html file as template for the site. Inside this file I have a partial (an include in Hugo) file, head.html.\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;es\u0026#34;\u0026gt; \u0026lt;head\u0026gt; {{partial\u0026#34;head.html\u0026#34;.}} \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; We import styles.css file from css folder and call absURL Hugo function, so it will return us the absolute path file.\n\u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1, shrink-to-fit=no\u0026#34;\u0026gt; {{$css:=\u0026#34;css/styles.css\u0026#34;|absURL}} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{$css}}\u0026#34;\u0026gt; Static files in Hugo are saved by default in static folder so that is the first step, having styles.css in /static/css/. As this file is going to be generated, what I have done has been to create a folder called static-src where to have sources of my static files that I will subsequently process.\nBefore continuing, we will install the dependencies that we will need with npm.\nnpm install tailwindcss --save npm install postcss postcss-cli @fullhuman/postcss-purgecss autoprefixer watch cross-env cssnano --save-dev Let´s see what are these dependencies:\n tailwindcss: CSS framework. postcss postcss-cli: Tailwind uses PostCSS to get compiled and also we will add some plugins to CSS process. @fullhuman/postcss-purgecss: Tailwind generates thousands of utility classes, most of which we probably don´t use. We will use this plugin for removing CSS that we are not actually using in our project. autoprefixer: Optional, prefix for our stylesheets. watch: Node package which allows us running tasks when any file is modified. It includes a cli that we will use on npm script. cross-env: Package that allow us setting and using environment variables across platforms. NODE_ENV in our case. cssnano: CSS minifier.  With all these dependencies we are ready to generate a CSS file with just the utility classes used and not the whole framework. Let´s generate an empty Tailwind config file so that we can customize default settings in the framework. We simply run:\nnpx tailwind init A tailwind.config.js file will be generated:\nmodule.exports = { theme: { extend: {} }, variants: {}, plugins: [] } Finally we can create our /static-src/styles.css file invoking Tailwind directives. Besides, we can add custom styles we want, using Tailwind or not.\n@tailwind base; @tailwind components; /* Custom CSS */ a.tag { @apply bg-gray-200 rounded-full px-3 py-1 font-semibold text-gray-700; } a.tag:hover { @apply underline; } /* Custom CSS end */ @tailwind utilities; Tailwind is compiled using PostCSS, so adding new plugins is very easy. We are going to add autoprefixer in order to auto generate prefixes for CSS properties that need them. Besides when compiling for production, we will use purgecss and cssnano for reducing the file size for our stylesheet. Let´s see PostCSS config file (postcss.config.js in the root folder):\nconst purgecss = require(\u0026#39;@fullhuman/postcss-purgecss\u0026#39;)({ content: [\u0026#39;../../content/**/*.md\u0026#39;, \u0026#39;./layouts/**/*.html\u0026#39;], defaultExtractor: content =\u0026gt; content.match(/[A-Za-z0-9-_:/]+/g) || [] }); module.exports = { plugins: [ require(\u0026#39;tailwindcss\u0026#39;), require(\u0026#39;autoprefixer\u0026#39;), ...(process.env.NODE_ENV === \u0026#39;production\u0026#39; ? [purgecss, require(\u0026#39;cssnano\u0026#39;)] : []) ] }; When using purgecss, we will search for files with .md extension inside content folder and .html in layouts. If you are working with javascript files or any other paths where you add CSS classes, you will have to adjust the array of paths to suit your needs. In this snippet of code we are considering that we are working with a theme inside /themes/themename/ folder. If we are working directly in layouts folder (as I do in this blog), we should adjust the paths:\nconst purgecss = require(\u0026#39;@fullhuman/postcss-purgecss\u0026#39;)({ content: [\u0026#39;./content/**/*.md\u0026#39;, \u0026#39;./layouts/**/*.html\u0026#39;, \u0026#39;./static/**/*.js\u0026#39;], defaultExtractor: content =\u0026gt; content.match(/[A-Za-z0-9-_:/]+/g) || [] }); With all this we can generate our npm scripts in package.json file:\n{ \u0026#34;name\u0026#34;: \u0026#34;hugo-tailwindcss\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;css:watch\u0026#34;: \u0026#34;node_modules/.bin/watch \\\u0026#34;npm run css:build:dev\\\u0026#34; ./static-src/css\u0026#34;, \u0026#34;css:build:dev\u0026#34;: \u0026#34;cross-env NODE_ENV=development npm run css:build\u0026#34;, \u0026#34;css:build:prod\u0026#34;: \u0026#34;cross-env NODE_ENV=production npm run css:build\u0026#34;, \u0026#34;css:build\u0026#34;: \u0026#34;node_modules/.bin/postcss static-src/css/styles.css -o static/css/styles.css\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;tailwindcss\u0026#34;: \u0026#34;^1.1.4\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@fullhuman/postcss-purgecss\u0026#34;: \u0026#34;^2.0.5\u0026#34;, \u0026#34;autoprefixer\u0026#34;: \u0026#34;^9.7.4\u0026#34;, \u0026#34;cross-env\u0026#34;: \u0026#34;^6.0.3\u0026#34;, \u0026#34;cssnano\u0026#34;: \u0026#34;^4.1.10\u0026#34;, \u0026#34;postcss\u0026#34;: \u0026#34;^7.0.26\u0026#34;, \u0026#34;postcss-cli\u0026#34;: \u0026#34;^7.1.0\u0026#34;, \u0026#34;watch\u0026#34;: \u0026#34;^1.0.2\u0026#34; } } There are 3 tasks:\n css:build:dev: Compile CSS in development mode, for greater agility we will have all Tailwind utilities by default without need to minimize and purge classes. css:build:prod: Compile, purge and minify CSS file in order to get optimized stylesheet for production. css:watch: Watch ./static-src/css folder. If it detects any change, it compiles CSS file again. It avoids tediously launching manually css:build:dev task on each change we do in our CSS.  With these tasks we can finally generate our stylesheet. I have created a Github repository with a theme which incorporates these scripts as a starting point to create your own theme for Hugo. You can try it out with some example content that I have created in other repository.\nNOTE: It is possible to integrate the whole process thanks to Hugo pipe postCSS. You need to install globally postcss-cli in addition to any other plugins you use. I personally prefer not having global packages installed and being able to customize the process, but it´s an option that Hugo gives us.\n","summary":"In this article we are going to see how can we build our Hugo site with TailwindCSS."},{"url":"/en/blog/new-website-with-hugo/","title":"New website with Hugo","content":"I have a new web with a single purpose: create articles with content about things I am learning. I have migrated the old posts from my Wordpress blog. I always wanted to create a design for my blog from scratch and finally I did it!\nIn the next articles I am going to show some things I have learnt creating this website. First of all I had to choose which tool to use for managing my personal website. I always thought in creating my own Wordpress theme but nowadays there a lot of alternatives and I decided finally using a Static Site Generator.\nSearching on the Internet I found an open-source static site generator written in Go: Hugo. I started testing Hugo, I felt very comfortable and I decided Hugo was the tool I needed.\nIn order to work with hugo, first thing I did was installing it on my PC and following this great guide for creating a blog with Hugo from scratch. Hugo is very flexible and allows us to do everything we can imagine, using themes and shortcodes for syntax highlighting, embed content from popular services such as Youtube, Twitter, Instagram\u0026hellip;\nWorking with a static site allows me using Github pages as hosting. When I want to deploy a new version I just need to copy public folder into the repository, commit, push and the website is deployed automatically.\nFinally, I had the decision of how I was going to organize the web layout. I could have developed everything on my own with CSS or SASS, but I have been hearing about Tailwind CSS, a CSS framework that implements \u0026ldquo;utility first\u0026rdquo; concept. After having worked with Bootstrap, I didn´t want to start learning another framework but I decided to give it a shot. First day I thought that HTML was very dirty with so many classes, but after a couple of days I decided it was very useful and now I love it.\nTailwind is not a framework like Boostrap, you don´t have components with a given markup. Tailwind provides low-level utility classes that let you build completely custom designs without ever leaving your HTML. You can focus on creating, you don´t have to invert time in naming classes and you don´t repeat every time the same CSS properties that make CSS files size growing without control.\nTailwind provides you with a set of possibilities to choose from, different text sizes, color palette, shadow, scale for margins and paddings\u0026hellip; And it is completely customizable, Tailwind is built with PostCSS and you can overwrite or extend everything you want. Tailwind gives you a base on which can create your design system for a fully customized website. Try it.\nIn my next articles I will show how I have configured Hugo, things I have learnt in which I spent a lot of time to get resolved.\n","summary":"I have a new web with a single purpose: create articles with content about things I am learning."}]