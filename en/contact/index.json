[{"url":"/en/blog/setting-up-standardjs/","title":"Setting up StandardJS","content":"In this post, we will cover the setup of StandardJS in VSCode to fix all the errors when saving a file automatically.\nWhat is StandardJS? Initially, you could think that StandardJS is the standard used for Javascript code, and, that is its main goal: provide a style guide, linter and, formatter for Javascript. Really, it\u0026rsquo;s not, we know about the different opinions about all concerning to Javascript ecosystem. The idea behind StandardJS is good, you install it, and you don\u0026rsquo;t worry about defining rules anymore. I had heard about it, but I had never given it a try (personally, I am used to Prettier as formatter). Here are some of the advantages:\n Avoid setting up rules for style decisions. Code auto formatting running standard --fix. Error and incorrect style detection in code.  StandardJS uses a fixed set of rules defined with ESLint.\nSetting up StandardJS The first is step is installing the package. You can do it globally or locally in a project. I always try using the last one in order to have under control all the dependencies.\nnpm install standard --save-dev You can fix at any moment all the problems founds automatically (some errors can\u0026rsquo;t be auto-fixed, you must fix it on your own) with:\nstandard --fix You can create a npm script to run the command, but in my opinion integrating into the editor is much better.\nAutoformat in VSCode I have used StandardJS for the first time in a job mate project, and at the beginning it was driving me crazy. I had Prettier as default formatter and when I was saving a file I had different kind of formats because Prettier was violating StandardJS rules.\nIs asked my teammate how did he format the code when saving a file, and he answered me that he didn\u0026rsquo;t do it. Simply when he saw an error in a file he clicked the bubble and selected Fix all. I hate this kind of repetitive tasks, so I investigated the solution in VSCode which I proceed to describe in the next lines.\nFirst, we have to install StandardJS extension for VSCode. As StandardJs is using ESLint under the hood, we will also install ESLint extension.\nIf you use Prettier as default formatter for Javascript as I do, you should disable it on the workspace of your project. At workspace level we will use the following setting which appears in the extension documentation. This way we are enabling auto-fix, but it\u0026rsquo;s necessary adding the highlighted lines to make work everything properly.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  { \u0026#34;standard.enable\u0026#34;: true, \u0026#34;standard.run\u0026#34;: \u0026#34;onSave\u0026#34;, \u0026#34;standard.autoFixOnSave\u0026#34;: true, \u0026#34;standard.validate\u0026#34;: [ \u0026#34;javascript\u0026#34;, \u0026#34;javascriptreact\u0026#34;, \u0026#34;typescript\u0026#34;, \u0026#34;typescriptreact\u0026#34; ], \u0026#34;javascript.validate.enable\u0026#34;: false, \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.fixAll.eslint\u0026#34;: true },  \u0026#34;[javascript]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: null } }   Let\u0026rsquo;s check that everything is working as expected. We just have to open a Javascript file and save it. File must be auto-formatted and all the error should disappear.\nAs conclusion, I prefer Prettier for formatting because I can use the same tool as well for HTML and CSS. I can define and apply rules directly with ESLint, but StandardJS is a superb tool that can avoid long discussions about opinionated things.\n","summary":"In this post, we will cover the setup of StandardJS in VSCode to fix all the errors when saving a file automatically."},{"url":"/en/blog/vue-3-with-typescript-eslint-and-prettier/","title":"Vue 3 with Typescript, ESLint and Prettier","content":"At the beginning of this year I started learning Vue 3, I had worked with version 2 before and the new version allows us to still use the same syntax, besides we can use the new Composition API, which is more powerful and customizable when creating reusable elements. In this post I will show how to create a new project with Vue 3 + Typescript and setting up ESLint and Prettier for working properly together in Visual Studio Code.\nVue CLI The easiest and fastest way for creating a new project is using Vue CLI. It will allow us to set up the project using different predefined workflows. First of all we will install Vue CLI:\nyarn global add @vue/cli # OR npm install -g @vue/cli Once installed we can create a new project:\nvue create hello-world We will select the last option from the list:\n\rVue CLI v4.5.13\r? Please pick a preset: (Use arrow keys)\rDefault ([Vue 2] babel, eslint)\rDefault (Vue 3) ([Vue 3] babel, eslint)\r Manually select features\r\rAnd we can customize our project with the options present in the list. I chose the next ones, I didn\u0026rsquo;t select testing in order to focus on the topic:\n\rVue CLI v4.5.13\r? Please pick a preset: Manually select features\r? Check the features needed for your project: (*) Choose Vue version\r(*) Babel\r(*) TypeScript\r( ) Progressive Web App (PWA) Support (*) Router\r( ) Vuex\r( ) CSS Pre-processors\r(*) Linter / Formatter\r( ) Unit Testing\r( ) E2E Testing\r\rAt the next step we will have to select more things, we choose version 3 and ESLint + Prettier at the end.\n\rVue CLI v4.5.13\r? Please pick a preset: Manually select features\r? Check the features needed for your project: Choose Vue version, Babel, TS, Router, Linter\r? Choose a version of Vue.js that you want to start the project with 3.x\r? Use class-style component syntax? No\r? Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? Yes\r? Use history mode for router? (Requires proper server setup for index fallback in production) Yes\r? Pick a linter / formatter config: ESLint with error prevention only ESLint + Airbnb config\rESLint + Standard config\r ESLint + Prettier\rTSLint (deprecated)\r\rAfter selection Vue CLI will start installing the dependencies. Once finished we can run npm run serve so that our new application will launch in development mode.\nESLint + Prettier The Vue team has done a great job in order to avoid us headaches setting up ESLint and Prettier. If we open .eslintrc.js file we will see these plugins installed:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  module.exports = { root: true, env: { node: true, }, extends: [ \u0026#34;plugin:vue/vue3-essential\u0026#34;, \u0026#34;eslint:recommended\u0026#34;, \u0026#34;@vue/typescript/recommended\u0026#34;, \u0026#34;@vue/prettier\u0026#34;, \u0026#34;@vue/prettier/@typescript-eslint\u0026#34;, ],  parserOptions: { ecmaVersion: 2020, }, rules: { \u0026#34;no-console\u0026#34;: process.env.NODE_ENV === \u0026#34;production\u0026#34; ? \u0026#34;warn\u0026#34; : \u0026#34;off\u0026#34;, \u0026#34;no-debugger\u0026#34;: process.env.NODE_ENV === \u0026#34;production\u0026#34; ? \u0026#34;warn\u0026#34; : \u0026#34;off\u0026#34;, \u0026#34;arrow-parens\u0026#34;: \u0026#34;off\u0026#34;, \u0026#34;eol-last\u0026#34;: \u0026#34;error\u0026#34;,  }, overrides: [ { files: [ \u0026#34;**/__tests__/*.{j,t}s?(x)\u0026#34;, \u0026#34;**/tests/unit/**/*.spec.{j,t}s?(x)\u0026#34;, ], env: { jest: true, }, }, ], };   This way Prettier won\u0026rsquo;t conflict with ESLint rules. At lines 19-20 there are custom rules added by me, we can add what we want in order to customize it.\nVSCode Last but not least, we will configure VSCode in order to have everything working properly. The most important thing is having installed the Vetur extension, which gives us a great development experience with Vue in VSCode. It will give us auto formatting code in Single File Components (files with .vue extension).\nOnce installed, we will go to Vetur settings and in Format -\u0026gt; Default Formatter section we will select the formatters for HTML, CSS, JS, Sass, Typescript\u0026hellip; It is very important to select prettier-eslint for JS, I have the default option in the rest including Typescript, with just Prettier instead of prettier-tslint which is deprecated.\nIn VSCode settings we must add Vetur as default formatter for Vue:\n\u0026#34;[vue]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;octref.vetur\u0026#34; } This way VSCode delegates in Vetur, and Vetur will format each different language that finds inside .vue files with a proper formatter. In my experience, there is only one thing wrong with auto format in .vue files, inserting the final new line at the end of the file. If you use this rule (which is the default), the only way I could find is delegating this task in VSCode with this setting:\n\u0026#34;files.insertFinalNewline\u0026#34;: false Sometimes using the last version of Vetur can be problematic, recently in a project Vetur started formatting HTML in a different way. After struggling for some hours I realized Vetur had been updated and after downgrading Vetur version everything started working as expected. I reported the bug and took the opportunity to comment on the problem with the final new line. Maybe I made a mistake, but I couldn\u0026rsquo;t find the problem after several hours.\nAfter completing all the steps we are now ready to begin new projects with Vue 3 + Typescript + ESLint + Prettier in VSCode.\n","summary":"At the beginning of this year I started learning Vue 3, I had worked with version 2 before and the new version allows us to still use the same syntax, besides we can use the new Composition API, which is more powerful and customizable when creating reusable elements."},{"url":"/en/blog/responsive-images-in-hugo/","title":"Responsive images in Hugo","content":"In this post I will share a very useful shortcode that will allow us processing images automatically with Hugo. First of all, we must be sure that our content is structured in Hugo´s page bundles. When I created my blog, I migrated from wordpress and all articles were named like this:\n\rresponsive-images-hugo\r- responsive-images-hugo.md\rusing-tailwindcss-with-angular\r- using-tailwindcss-with-angular.md\r\rAnd all the images were placed inside /static folder. That structure will not be recognized by Hugo as page bundles so I had to reorganize every post. A very basic summary for page bundles:\n _index.md files are considered index of a section and list.html template will be used. index.md (or index.en.md, index.es.md) files are considered index of a page/post and single.html template will be used.  Now the structure for each post is:\n\rresponsive-images-hugo\r- index.md\r- index.en.md\rimg\r- img1.jpg\r- ...\r\rThe next step is creating a file for the shortcode, I created in layouts/shortcodes/img.html with this code: {{/* Get file that matches the filename as specified as src=\u0026#34;\u0026#34; in shortcode */}} {{$src:=.Page.Resources.GetMatch(printf\u0026#34;*%s*\u0026#34;(.Get\u0026#34;src\u0026#34;))}} {{/* Set image sizes, these are hardcoded for now, x dictates that images are resized to this width */}} {{$tinyw:=default\u0026#34;500x\u0026#34;}} {{$smallw:=default\u0026#34;800x\u0026#34;}} {{$mediumw:=default\u0026#34;1200x\u0026#34;}} {{$largew:=default\u0026#34;1500x\u0026#34;}} {{/* Initialize variables */}} {{$tiny:=\u0026#34;\u0026#34;}} {{$small:=\u0026#34;\u0026#34;}} {{$medium:=\u0026#34;\u0026#34;}} {{$large:=\u0026#34;\u0026#34;}} {{/* Resize the src image to the given sizes if necessary */}} {{ifge$src.Width\u0026#34;500\u0026#34;}} {{$tiny=$src.Resize$tinyw}} {{end}} {{ifge$src.Width\u0026#34;800\u0026#34;}} {{$small=$src.Resize$smallw}} {{end}} {{ifge$src.Width\u0026#34;1200\u0026#34;}} {{$medium=$src.Resize$mediumw}} {{end}} {{ifge$src.Width\u0026#34;1500\u0026#34;}} {{$large:=$src.Resize$largew}} {{end}} \u0026lt;img class=\u0026#39;mb-6 {{with.Get\u0026#34;class\u0026#34;}}{{.}}{{end}}\u0026#39; srcset=\u0026#39; {{with$src.RelPermalink}}{{.}}{{$src.Width}}w{{end}}{{ifge$src.Width\u0026#34;500\u0026#34;}}{{with$tiny.RelPermalink}},{{.}}500w{{end}}{{end}}{{ifge$src.Width\u0026#34;800\u0026#34;}}{{with$small.RelPermalink}}, {{.}}800w{{end}}{{end}}{{ifge$src.Width\u0026#34;1200\u0026#34;}}{{with$medium.RelPermalink}}, {{.}}1200w{{end}}{{end}}{{ifge$src.Width\u0026#34;1500\u0026#34;}}{{with$large.RelPermalink}}, {{.}}1500w {{end}}{{end}}\u0026#39; src=\u0026#34;{{$src.RelPermalink}}\u0026#34; width=\u0026#34;{{$src.Width}}\u0026#34; height=\u0026#34;{{$src.Height}}\u0026#34; {{with.Get\u0026#34;alt\u0026#34;}}alt=\u0026#39;{{.}}\u0026#39;{{end}}\u0026gt;\nThis way we will be able to use in markdown files the shortcode: {{\u0026lt;imgsrc=\u0026#34;img/img1.jpg\u0026#34;alt=\u0026#34;Description for image\u0026#34;\u0026gt;}}\nAnd that´s all, you use the image as if you were in html and the shortcode and Hugo will generate images smaller when necessary. This solution comes from Laura Kalbag, I just modified a little bit her code. I take this opportunity to recomendate her book Accessibility For Everyone.\n","summary":"In this post I will share a very useful shortcode that will allow us processing images automatically with Hugo."},{"url":"/en/blog/search-in-hugo-with-lunr/","title":"Search in Hugo with Lunr","content":"¿What is the best way to make a search engine in Hugo? My first attempt was looking for information in the official documentation, I found some guides and links which helped me, but none of them suited my needs. So I will detail in this guide the solution that I have developed.\nEvery guide suggest these 2 possibilities:\n  Algolia: It´s a service that provides a set of tools that simplify the process of making and integrating a full search experience into our sites and applications. It has an automated crawler to extract content from web sites. It´s a third party service which allows the integration on a static site easily, we just have to use the provided API in front. Algolia is used in a lot of different sites but I decided I didn´t want to use a third party service.\n  Lunr: Lunr.js is a small, full-text search library for use in the browser. It indexes JSON documents and provides a simple search interface for retrieving documents that best match text queries. It allows fuzzy search that is the technique of finding strings that match a pattern approximately (rather than exactly). This is the approach used in this blog.\n  Defining the output of our content in JSON format Having Lunr as Javascript library for fuzzy search we just need the other part in order to complete our search engine: a JSON file with posts content from the blog. We can define this behaviour in 2 differents ways:\n In Hugo global config file, config.toml in my case. All the content in Hugo will be available in HTML and RSS format by default if no config is provided. In this site, all the blog articles are under what is called in Hugo as section, in content/blog path. We can set global JSON output for every section on this way:  [outputs] section = [\u0026#34;JSON\u0026#34;, \u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] This configuration will output a JSON file for each section. For example, if we have another section (courses) in addition to blog, each one will have its index.json file with the content of the section. This is very powerful and we will be able to make independent searches for each section. But, How can I tell to Hugo the content and format for that JSON file? We have to create a list.json template file like we have list.html for HTML files.\nIf we want each section file different, inside layouts folder and following with this site as example, in a folder called blog we must create a list.json file and inside courses folder we will create another list.json different. However if the format for each section is going to be the same, we can create list.json file inside _default folder and it will be used for every section (unless the section has a list.json file that would replace the global in _default folder).\nLet´s see list.json content finally. It just generates an array of posts using Hugo syntax.\n[ {{range$index,$value:=where.Site.Pages\u0026#34;Type\u0026#34;\u0026#34;post\u0026#34;}} {{if$index}}, {{end}} { \u0026#34;url\u0026#34;: \u0026#34;{{.RelPermalink}}\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;{{.Title}}\u0026#34;, \u0026#34;content\u0026#34;: {{.Content|plainify|jsonify}}, \u0026#34;summary\u0026#34;: \u0026#34;{{.Summary}}\u0026#34; } {{end}} ] Of course the content is completely customizable, and so the name for each field. In my case I have a reduced number of posts, so by the moment I put all the content in content field, but in the future because of better performarnce I will try to reduce the JSON file size leaving just title and summary for the search.\nEnabling for each section the output format from the front matter. Following with my site as example, I have _index.md and _index.en.md (English version) files in content/blog folder. We can enable JSON format on this way:  --- title: Personal blog subtitle: Posts written on a variety of topics related to the world of technology and programming. outputs: - html - rss - json --- The template list.json part is exactly the same than at point 1. You can read more about custom output formats in Hugo documentation.\nImplementing search engine using lunr with Javascript Let´s see the code that will allow us to search in the JSON file generated. In my case, I have created a search.html file in layouts/page. Let´s check step by step the content. First of all we need and input text for the search term, followed by a section element where search results will be showed.\n\u0026lt;label for=\u0026#34;search-input\u0026#34;\u0026gt;Término de búsqueda\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;search-input\u0026#34; name=\u0026#34;search\u0026#34; placeholder=\u0026#34;{{i18n\u0026#34;search_loading\u0026#34;}}...\u0026#34;\u0026gt; \u0026lt;section id=\u0026#34;search-results\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; Javascript code is also inside the html file so that we can create dinamyc vars in Javascript with Hugo, for example for getting translation of strings and getting relative path to index.json for each language.\nNext step is importing Lunr, in my case in static/js/ folder:\n{{$lunr:=\u0026#34;js/lunr.min.js\u0026#34;|absURL}} \u0026lt;script src=\u0026#34;{{$lunr}}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; It would be possible importing Lunr via CDN:\n\u0026lt;script src=\u0026#34;https://unpkg.com/lunr/lunr.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Below is shown the Javascript code that on pageload makes a petition to load index.json file and creates indexed document that will be used to return search results. Searchs will be launched when user is typing in the input field.\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; (function () { let idx; let documents = []; const URL_LIST_POSTS = \u0026#39;{{\u0026#34;blog/index.json\u0026#34;|relLangURL}}\u0026#39;; const searchInput = document.getElementById(\u0026#34;search-input\u0026#34;); const searchResults = document.getElementById(\u0026#34;search-results\u0026#34;); // Request and index documents  fetch(URL_LIST_POSTS, { method: \u0026#34;get\u0026#34;, }) .then((res) =\u0026gt; res.json()) .then((res) =\u0026gt; { // Create index document with lunr  idx = lunr(function () { this.ref(\u0026#34;url\u0026#34;); this.field(\u0026#34;title\u0026#34;); this.field(\u0026#34;content\u0026#34;); this.field(\u0026#34;summary\u0026#34;); res.forEach(function (doc) { this.add(doc); documents[doc.url] = { title: doc.title, content: doc.content, summary: doc.summary, }; }, this); }); // Once data is loaded we can register handler  registerSearchHandler(); }) .catch((err) =\u0026gt; { console.log({ err }); const errorMsg = \u0026#39;{{i18n\u0026#34;search_error\u0026#34;}}\u0026#39;; searchResults.innerHTML = ` \u0026lt;div class=\u0026#34;bg-red-100 border-l-4 border-red-500 text-red-700 p-4\u0026#34; role=\u0026#34;alert\u0026#34;\u0026gt; \u0026lt;p\u0026gt;${errorMsg}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;`; }); ///////////////////////////////////////////////////////////  function renderSearchResults(results) { const noResults = \u0026#39;{{i18n\u0026#34;search_noCoincidence\u0026#34;}}\u0026#39;; // If results are empty  if (results.length === 0) { searchResults.innerHTML = ` \u0026lt;div class=\u0026#34;bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4\u0026#34; role=\u0026#34;alert\u0026#34;\u0026gt; \u0026lt;p\u0026gt;${noResults}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; return; } // Show max 10 results  if (results.length \u0026gt; 9) { results = results.slice(0, 10); } // Reset search results  searchResults.innerHTML = \u0026#34;\u0026#34;; // Append results  results.forEach((result) =\u0026gt; { // Create result item  let article = document.createElement(\u0026#34;article\u0026#34;); article.classList.add(\u0026#34;mb-8\u0026#34;); article.innerHTML = ` \u0026lt;a href=\u0026#34;${result.ref}\u0026#34; class=\u0026#34;block group\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;article-title group-hover:text-green-500 pb-1\u0026#34;\u0026gt;${documents[result.ref].title}\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;text-gray-700 dark:text-gray-300\u0026#34;\u0026gt;\u0026lt;p\u0026gt;${documents[result.ref].summary}\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/a\u0026gt;`; searchResults.appendChild(article); }); } function registerSearchHandler() { // Register on input event  searchInput.oninput = function (event) { if (searchInput.value === \u0026#34;\u0026#34;) { searchResults.innerHTML = \u0026#34;\u0026#34;; return; } // Get input value  const query = event.target.value; // Run fuzzy search  const results = idx.query(function(q) { q.term(lunr.tokenizer(query.trim()), { usePipeline: true, boost: 100 }); q.term(lunr.tokenizer(query.trim()) + \u0026#39;*\u0026#39;, { usePipeline: false, boost: 10 }); q.term(lunr.tokenizer(query.trim()), { usePipeline: false, editDistance: 1 }); }); // Render results  renderSearchResults(results); }; searchInput.placeholder = \u0026#39;{{i18n\u0026#34;search_inputPlaceholder\u0026#34;}}\u0026#39;; } })(); \u0026lt;/script\u0026gt; And that´s all. To develop this solution I have followed the guides of Joseph Earl and Matt Walters. I have adapted and updated Javascript code and corrected the method for searching with Lunr, beacuse it didn´t work properly in all cases. This is the most important part, I found the solution in an issue in Lunr github:\n// Run fuzzy search const results = idx.query(function(q) { q.term(lunr.tokenizer(query.trim()), { usePipeline: true, boost: 100 }); q.term(lunr.tokenizer(query.trim()) + \u0026#39;*\u0026#39;, { usePipeline: false, boost: 10 }); q.term(lunr.tokenizer(query.trim()), { usePipeline: false, editDistance: 1 }); }); You can take a look to search.html file with the complete code in github and adapt it to your needs.\n","summary":"¿What is the best way to make a search engine in Hugo?"},{"url":"/en/blog/using-tailwindcss-with-angular/","title":"Using TailwindCSS with Angular","content":"In this article we are going to explain how to set up an Angular application with Angular CLI in order to integrate TailwindCSS. With this approach the CSS written in our components will be very little because most of the time we will be using Tailwind classes.\nAngular CLI Angular CLI is the recommended command line interface for generating Angular applications. It uses webpack under the hood, but we can´t access directly to webpack settings so if we want to customize any behaviour we can use a package called @angular-builders/custom-webpack. This package will allow us extend webpack config.\nSetting up TailwindCSS TailwindCSS works regardless of CSS preprocessor we use in our application (if we use one). To make the development experience as productive as possible, we will run PurgeCSS just when building for production. Let´s see step by step guide for adding Tailwind:\nFirst of all we will install dependencies:\nnpm install tailwindcss --save npm install --save-dev @angular-builders/custom-webpack @fullhuman/postcss-purgecss Generate an empty Tailwind config file:\nnpx tailwind init Create a new file, and give it the extension depending on the preprocessor you are using. In my case scss, so the file will be src/tailwind.scss where we will insert Tailwind directives. We can also add custom styles using Tailwind directives in this file.\n@tailwind base; @tailwind components; /* Custom CSS */ a.tag { @apply bg-gray-200 rounded-full px-3 py-1 font-semibold text-gray-700; } a.tag:hover { @apply underline; } /* Custom CSS end */ @tailwind utilities; Next step is creating extra-webpack.config.js file on folder root with this content:\nconst purgecss = require(\u0026#39;@fullhuman/postcss-purgecss\u0026#39;)({ // Specify the paths to all of the template files in your project  content: [\u0026#39;./src/**/*.html\u0026#39;, \u0026#39;./src/**/*.component.ts\u0026#39;], // Include any special characters you\u0026#39;re using in this regular expression  defaultExtractor: content =\u0026gt; content.match(/[\\w-/:]+(?\u0026lt;!:)/g) || [] }); module.exports = (config, options) =\u0026gt; { console.log(`Using \u0026#39;${config.mode}\u0026#39; mode`); config.module.rules.push({ test: /tailwind\\.scss$/, use: [ { loader: \u0026#39;postcss-loader\u0026#39;, options: { plugins: [ require(\u0026#39;tailwindcss\u0026#39;)(\u0026#39;./tailwind.config.js\u0026#39;), require(\u0026#39;autoprefixer\u0026#39;), ...(config.mode === \u0026#39;production\u0026#39; ? [purgecss] : []) ] } } ] }); return config; }; angular.json Now we need to edit angular.json config file so that we can customize ng serve and ng build commands. We must search projects.architect.build.builder key and replace @angular-devkit/build-angular:browser with @angular-builders/custom-webpack:browser. It´s neccessary add a new object customWebpackConfig at architect.build.options with key path and extra-webpack.config.js as its value.\nWe must do same changes in projects.architect.serve.builder replacing @angular-devkit/build-angular:dev-server with @angular-builders/custom-webpack:dev-server. It´s neccessary again adding a new object customWebpackConfig at architect.serve.options with key path and extra-webpack.config.js as its value.\nFinally we will add our src/tailwind.scss stylesheet to the array in architect.build.options.styles. Let´s see all the changes together:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  \u0026#34;architect\u0026#34;: { \u0026#34;build\u0026#34;: { \u0026#34;builder\u0026#34;: \u0026#34;@angular-builders/custom-webpack:browser\u0026#34;,  \u0026#34;options\u0026#34;: { \u0026#34;customWebpackConfig\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;extra-webpack.config.js\u0026#34; },  // ... \u0026#34;styles\u0026#34;: [ \u0026#34;src/tailwind.scss\u0026#34;,  \u0026#34;src/styles.css\u0026#34; ], // ... } }, \u0026#34;serve\u0026#34;: { \u0026#34;builder\u0026#34;: \u0026#34;@angular-builders/custom-webpack:dev-server\u0026#34;,  \u0026#34;options\u0026#34;: { \u0026#34;customWebpackConfig\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;extra-webpack.config.js\u0026#34; },  // ... } } }   Once these changes are applied we can init server in development mode with ng serve as usual. All the Tailwind classes will be available. When compiling for production with ng build --prod we can check in dist folder that styles files is generated with only classes that are used in our application.\nchunk {4} styles.847663bf210845648553.css (styles) 5.51 kB [initial] [rendered] PurgeCSS with Tailwind From Tailwind 1.4.0 PurgeCSS is integrated into Tailwind config file. This way we can remove @fullhuman/postcss-purgecss dependency in our project and leave extra-webpack.config.js with this content:\nmodule.exports = (config, options) =\u0026gt; { console.log(`Using \u0026#39;${config.mode}\u0026#39; mode`); config.module.rules.push({ test: /tailwind\\.scss$/, use: [ { loader: \u0026#39;postcss-loader\u0026#39;, options: { plugins: [ require(\u0026#39;tailwindcss\u0026#39;)(\u0026#39;./tailwind.config.js\u0026#39;) ] } } ] }); return config; }; We just move routes to tailwind.config.js file:\nmodule.exports = { purge: [\u0026#39;./src/**/*.html\u0026#39;, \u0026#39;./src/**/*.component.ts\u0026#39;], theme: { extend: {}, }, variants: {}, plugins: [], }; We must compile with NODE_ENV variable set to production so that Tailwind automatically purges unused styles. To achieve this with a multiplatform solution I like using cross-env package. We just install it:\nnpm install cross-env --save-dev After the installation we can create a script in package.json to launch the build:\n1 2 3 4 5 6 7 8 9 10 11 12 13  { // ... \u0026#34;scripts\u0026#34;: { \u0026#34;ng\u0026#34;: \u0026#34;ng\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;ng serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;ng build\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;ng test\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;ng lint\u0026#34;, \u0026#34;e2e\u0026#34;: \u0026#34;ng e2e\u0026#34;, \u0026#34;build:prod\u0026#34;: \u0026#34;cross-env NODE_ENV=production ng build --prod\u0026#34;  }, // ... }   Now we run the script and check that everything is working as expected:\nnpm run build:prod chunk {4} styles.847663bf210845648553.css (styles) 5.51 kB [initial] [rendered] With these simple steps you are ready to go with Tailwind in your Angular projects.\n","summary":"In this article we are going to explain how to set up an Angular application with Angular CLI in order to integrate TailwindCSS."},{"url":"/en/blog/using-tailwind-css-with-hugo/","title":"Using Tailwind CSS with Hugo","content":"In this article we are going to see how can we build our Hugo site with TailwindCSS. Hugo is very flexible and allows us setting up our site easily as we want. In this web, I have a baseof.html file as template for the site. Inside this file I have a partial (an include in Hugo) file, head.html.\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;es\u0026#34;\u0026gt; \u0026lt;head\u0026gt; {{partial\u0026#34;head.html\u0026#34;.}} \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; We import styles.css file from css folder and call absURL Hugo function, so it will return us the absolute path file.\n\u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1, shrink-to-fit=no\u0026#34;\u0026gt; {{$css:=\u0026#34;css/styles.css\u0026#34;|absURL}} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{$css}}\u0026#34;\u0026gt; Static files in Hugo are saved by default in static folder so that is the first step, having styles.css in /static/css/. As this file is going to be generated, what I have done has been to create a folder called static-src where to have sources of my static files that I will subsequently process.\nBefore continuing, we will install the dependencies that we will need with npm.\nnpm install tailwindcss --save npm install postcss postcss-cli @fullhuman/postcss-purgecss autoprefixer watch cross-env cssnano --save-dev Let´s see what are these dependencies:\n tailwindcss: CSS framework. postcss postcss-cli: Tailwind uses PostCSS to get compiled and also we will add some plugins to CSS process. @fullhuman/postcss-purgecss: Tailwind generates thousands of utility classes, most of which we probably don´t use. We will use this plugin for removing CSS that we are not actually using in our project. autoprefixer: Optional, prefix for our stylesheets. watch: Node package which allows us running tasks when any file is modified. It includes a cli that we will use on npm script. cross-env: Package that allow us setting and using environment variables across platforms. NODE_ENV in our case. cssnano: CSS minifier.  With all these dependencies we are ready to generate a CSS file with just the utility classes used and not the whole framework. Let´s generate an empty Tailwind config file so that we can customize default settings in the framework. We simply run:\nnpx tailwind init A tailwind.config.js file will be generated:\nmodule.exports = { theme: { extend: {} }, variants: {}, plugins: [] } Finally we can create our /static-src/styles.css file invoking Tailwind directives. Besides, we can add custom styles we want, using Tailwind or not.\n@tailwind base; @tailwind components; /* Custom CSS */ a.tag { @apply bg-gray-200 rounded-full px-3 py-1 font-semibold text-gray-700; } a.tag:hover { @apply underline; } /* Custom CSS end */ @tailwind utilities; Tailwind is compiled using PostCSS, so adding new plugins is very easy. We are going to add autoprefixer in order to auto generate prefixes for CSS properties that need them. Besides when compiling for production, we will use purgecss and cssnano for reducing the file size for our stylesheet. Let´s see PostCSS config file (postcss.config.js in the root folder):\nconst purgecss = require(\u0026#39;@fullhuman/postcss-purgecss\u0026#39;)({ content: [\u0026#39;../../content/**/*.md\u0026#39;, \u0026#39;./layouts/**/*.html\u0026#39;], defaultExtractor: content =\u0026gt; content.match(/[A-Za-z0-9-_:/]+/g) || [] }); module.exports = { plugins: [ require(\u0026#39;tailwindcss\u0026#39;), require(\u0026#39;autoprefixer\u0026#39;), ...(process.env.NODE_ENV === \u0026#39;production\u0026#39; ? [purgecss, require(\u0026#39;cssnano\u0026#39;)] : []) ] }; When using purgecss, we will search for files with .md extension inside content folder and .html in layouts. If you are working with javascript files or any other paths where you add CSS classes, you will have to adjust the array of paths to suit your needs. In this snippet of code we are considering that we are working with a theme inside /themes/themename/ folder. If we are working directly in layouts folder (as I do in this blog), we should adjust the paths:\nconst purgecss = require(\u0026#39;@fullhuman/postcss-purgecss\u0026#39;)({ content: [\u0026#39;./content/**/*.md\u0026#39;, \u0026#39;./layouts/**/*.html\u0026#39;, \u0026#39;./static/**/*.js\u0026#39;], defaultExtractor: content =\u0026gt; content.match(/[A-Za-z0-9-_:/]+/g) || [] }); With all this we can generate our npm scripts in package.json file:\n{ \u0026#34;name\u0026#34;: \u0026#34;hugo-tailwindcss\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;css:watch\u0026#34;: \u0026#34;node_modules/.bin/watch \\\u0026#34;npm run css:build:dev\\\u0026#34; ./static-src/css\u0026#34;, \u0026#34;css:build:dev\u0026#34;: \u0026#34;cross-env NODE_ENV=development npm run css:build\u0026#34;, \u0026#34;css:build:prod\u0026#34;: \u0026#34;cross-env NODE_ENV=production npm run css:build\u0026#34;, \u0026#34;css:build\u0026#34;: \u0026#34;node_modules/.bin/postcss static-src/css/styles.css -o static/css/styles.css\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;tailwindcss\u0026#34;: \u0026#34;^1.1.4\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@fullhuman/postcss-purgecss\u0026#34;: \u0026#34;^2.0.5\u0026#34;, \u0026#34;autoprefixer\u0026#34;: \u0026#34;^9.7.4\u0026#34;, \u0026#34;cross-env\u0026#34;: \u0026#34;^6.0.3\u0026#34;, \u0026#34;cssnano\u0026#34;: \u0026#34;^4.1.10\u0026#34;, \u0026#34;postcss\u0026#34;: \u0026#34;^7.0.26\u0026#34;, \u0026#34;postcss-cli\u0026#34;: \u0026#34;^7.1.0\u0026#34;, \u0026#34;watch\u0026#34;: \u0026#34;^1.0.2\u0026#34; } } There are 3 tasks:\n css:build:dev: Compile CSS in development mode, for greater agility we will have all Tailwind utilities by default without need to minimize and purge classes. css:build:prod: Compile, purge and minify CSS file in order to get optimized stylesheet for production. css:watch: Watch ./static-src/css folder. If it detects any change, it compiles CSS file again. It avoids tediously launching manually css:build:dev task on each change we do in our CSS.  With these tasks we can finally generate our stylesheet. I have created a Github repository with a theme which incorporates these scripts as a starting point to create your own theme for Hugo. You can try it out with some example content that I have created in other repository.\nNOTE: It is possible to integrate the whole process thanks to Hugo pipe postCSS. You need to install globally postcss-cli in addition to any other plugins you use. I personally prefer not having global packages installed and being able to customize the process, but it´s an option that Hugo gives us.\n","summary":"In this article we are going to see how can we build our Hugo site with TailwindCSS."},{"url":"/en/blog/new-website-with-hugo/","title":"New website with Hugo","content":"I have a new web with a single purpose: create articles with content about things I am learning. I have migrated the old posts from my Wordpress blog. I always wanted to create a design for my blog from scratch and finally I did it!\nIn the next articles I am going to show some things I have learnt creating this website. First of all I had to choose which tool to use for managing my personal website. I always thought in creating my own Wordpress theme but nowadays there a lot of alternatives and I decided finally using a Static Site Generator.\nSearching on the Internet I found an open-source static site generator written in Go: Hugo. I started testing Hugo, I felt very comfortable and I decided Hugo was the tool I needed.\nIn order to work with hugo, first thing I did was installing it on my PC and following this great guide for creating a blog with Hugo from scratch. Hugo is very flexible and allows us to do everything we can imagine, using themes and shortcodes for syntax highlighting, embed content from popular services such as Youtube, Twitter, Instagram\u0026hellip;\nWorking with a static site allows me using Github pages as hosting. When I want to deploy a new version I just need to copy public folder into the repository, commit, push and the website is deployed automatically.\nFinally, I had the decision of how I was going to organize the web layout. I could have developed everything on my own with CSS or SASS, but I have been hearing about Tailwind CSS, a CSS framework that implements \u0026ldquo;utility first\u0026rdquo; concept. After having worked with Bootstrap, I didn´t want to start learning another framework but I decided to give it a shot. First day I thought that HTML was very dirty with so many classes, but after a couple of days I decided it was very useful and now I love it.\nTailwind is not a framework like Boostrap, you don´t have components with a given markup. Tailwind provides low-level utility classes that let you build completely custom designs without ever leaving your HTML. You can focus on creating, you don´t have to invert time in naming classes and you don´t repeat every time the same CSS properties that make CSS files size growing without control.\nTailwind provides you with a set of possibilities to choose from, different text sizes, color palette, shadow, scale for margins and paddings\u0026hellip; And it is completely customizable, Tailwind is built with PostCSS and you can overwrite or extend everything you want. Tailwind gives you a base on which can create your design system for a fully customized website. Try it.\nIn my next articles I will show how I have configured Hugo, things I have learnt in which I spent a lot of time to get resolved.\n","summary":"I have a new web with a single purpose: create articles with content about things I am learning."}]