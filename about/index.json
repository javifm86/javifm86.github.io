[{"url":"/blog/setup-inicial-para-mac/","title":"Setup inicial para mac","content":"Setup inicial para mac Finalmente he decidido comprarme Mac, concretamente el Mac Mini M2 Pro. Además, en el trabajo voy a cambiar a un MacBook Pro. Por tanto es hora de adecuar el sistema operativo a mi gusto.\nConfiguración del sistema Mouse \u0026gt; Natural scrolling deshabilitado. Keyboard repetición de tecla a lo más rápido posible y retardo hasta repetir a corto. Keyboard \u0026gt; Keyboard shortcuts \u0026gt; Input sources deshabilito ambos shortcuts, no los necesito y uno de ellos coincide con uno de VSCode. Keyboard \u0026gt; Keyboard shortcuts \u0026gt; Services \u0026gt; Text deshabilitar Convert text to Simplified chinese and traditional, quiero estas combinaciones para algo más útil. Deshabilitar ApplePressAndHoldEnabled, una configuración que impide que al mantener una tecla pulsada se repita ese carácter multiples veces. Para ello ejecutar en la terminal: defaults write -g ApplePressAndHoldEnabled -bool false. Mismo comando con true para revertir el cambio. Finder Finder es el explorador de archivos para Mac. Cambio estas configuraciones:\nCambiar la vista por la de listas y añadir la columna de fecha de modificación. En View activo Show path bar y Show status bar. Arrastro a la izquierda mis carpetas más utilizadas en el día a día, como por ejemplo Github. En View, ir a Customize toolbar y eliminar cosas que no utilizo como tags, groups, etc. Finder \u0026gt; Settings \u0026gt; Advanced y seleccionar Current folder para el campo When performing a search. Configuración del Dock Botón derecho en una parte vacía del dock y seleccionar Dock settings:\nActivar minimizar aplicación en su icono. Deshabilitar Show suggested and recent apps in dock. Aplicaciones a instalar Normalmente instalo estas aplicaciones:\nShottr: Aplicación gratuita para tomar pantallazos y hacer rápidas anotaciones. Warp: Terminal mejorada, con AI incluida. Oh My Zsh: Framework para personalizar la terminal zsh. Macpass: Cliente para KeePass en mac, gestor de contraseñas. Colorslurp: Color picker. Me encanta que al pulsar Ctrl + click mientras te mueves se activa el modo alta precisión. VSCode: Mi editor de texto favorito para desarrollo. Firefox, Chrome, Responsively: Navegadores. Logi Options+: Software para mi ratón y teclado. ChatGPT: La herramienta de AI más famosa. HyperKey: Convierte la tecla Bloq. Mayús o otra tecla no usada en la hyper tecla, una combinación de pulsar estas 4 teclas: ⌃⌥⌘⇧. Más información más abajo. Raycast: Spotlight con extensiones y más opciones. Amplío información más adelante. DevToys: Navaja de herramientas para desarrolladores para macOS. GIMP: Edición de imágenes open source. Rectangle PRO: Manejo de ventanas avanzado para mac con mi funcionalidad favorita, App layouts. Hyperkey HyperKey es una aplicación muy sencilla que puede implicar todo un cambio a la hora de manejar los atajos de teclado. Te permite mapear la poco usada tecla Bloq. Mayús (u otra a tu elección) para ejecutar la combinación ⌃⌥⌘⇧. Esta combinación es muy raramente usada en atajos de teclado, por lo que es ideal para crear tus propios atajos de teclado evitando colisión con los de otras aplicaciones.\nAdemás, la tecla Bloq. Mayús continuará funcionando como siempre si la pulsas rápidamente. Esta es la configuración que uso para Hyperkey:\nSi quieres conseguir la misma personalización o ir más allá, puedes utilizar Karabiner. Karabiner es una aplicación muy poderosa que te permite personalizar tu teclado en macOS. Hay un motón de locas combinaciones y cosas que puedes lograr, yo por simplicidad de momento estoy utilizando Hyperkey.\nRaycast Raycast es una aplicación que es una versión mejorada de la nativa Spotlight. En mi opinión Raycast implementa algunas de las funcionalidades que más se echan de menos en Mac de manera nativa, gestión de clipboard, manejo de ventanas y un montón de cosas que puedes añadir en forma de plugins.\nLo primero que hago es mapear Raycast al atajo por defecto de Spotlight, Command + Space. Para conseguir esto hay que ir a Preferences \u0026gt; Keyboard \u0026gt; Shortcuts \u0026gt; Spotlight y deshabilitar el atajo de teclado. Luego en la configuración de Raycast grabas el atajo de teclado utilizando Command + Space y ya estaría listo.\nAlgunas extensiones que utilizo:\nColorslurp. Google translate. Ruler. GIF Search. Lorem Ipsum. Change case. ray.so brew Shortcuts Atajos de teclado predefinidos y otros creados por mí mismo para mejorar mi productividad.\nManejo de aplicaciones ⌘ + M: Minimizar ⌃ + ⌘ + F: Activar/desactivar el modo pantalla completa ⌘ + W: Cerrar ventana de la aplicación ⌘ + Q: Matar aplicación ⌘ + H: Esconder aplicación ⌥ + ⌘ + H: Esconder todas las aplicaciones excepto la actual ⌥ + ⌘ + W: Cierra todas las ventanas para una aplicación ⌥ + ⌘ + ESC: Ventana que permite forzar el cierre de aplicaciones F11: Mostrar escritorio Screenshots ⌘ + ⌃ + 1: Capturar pantalla (Shottr) ⌘ + ⌃ + 2: Capturar área (Shottr) ⌘ + ⌃ + 3: Capturar pantalla (Nativo) ⌘ + ⌃ + 4: Capturar área (Nativo) ⌘ + ⌃ + 5: Capturar vídeo (Nativo) Manejo de ventanas Atajos de teclado custom definidos en Raycast o Rectangle:\n⌘ + ⌥ + Left: Mover a la izquierda (rota entre 1/3, 2/3\u0026hellip;) ⌘ + ⌥ + Right: Mover a la derecha (rota entre 1/3, 2/3\u0026hellip;) ⌘ + ⌥ + Up: Mover arriba (rota entre 1/3, 2/3\u0026hellip;) Nota: Conflicto con atajo de teclado en VSCode ⌘ + ⌥ + Down: Mover abajo (rota entre 1/3, 2/3\u0026hellip;) Nota: Conflicto con atajo de teclado en VSCode ⌘ + ⌥ + C: Centrar (rota entre 1/3, 2/3\u0026hellip;) ⌃ + ⌘ + ⌥ + C: Centrar ventana ⌘ + ⌥ + F: Maximizar ⌘ + ⌥ + Del: Restaurar ⌘ + ⌥ + +: Agrandar ⌘ + ⌥ + -: Empequeñecer Historial del Clipboard ⌃ + ⌥ + V: Historial del portapapeles Raycast Atajos de teclado con Hyper key ⌃ + ⌥ + ⌘ + ⇧ + F: Firefox ⌃ + ⌥ + ⌘ + ⇧ + C: Chrome ⌃ + ⌥ + ⌘ + ⇧ + V: VSCode ⌃ + ⌥ + ⌘ + ⇧ + W: Warp ⌃ + ⌥ + ⌘ + ⇧ + S: Slack ⌃ + ⌥ + ⌘ + ⇧ + Enter: Confetti (extensión de Raycast) ","summary":"Setup inicial para mac Finalmente he decidido comprarme Mac, concretamente el Mac Mini M2 Pro."},{"url":"/blog/plantuml-para-generar-diagramas/","title":"PlantUML para generar diagramas","content":"PlantUML PlantUML es una aplicación que permite escribir rápidamente diferentes tipos de diagramas (UML y no UML).\nEn base a unas instrucciones, puedes crear y exportar diagramas a diferentes formatos (png, SVG, etc). Echa un vistazo a la guía online para descubrir diferentes opciones para crear diagramas.\nMe encanta la extensión de PlantUML para VSCode, puesto que me permite generar diagramas sin salir del editor.\nEs posible instalar la extensión y utilizar el servicio online para crear diagramas, pero por motivos de privacidad, recomendaría instalar el servidor local.\nEjecutar servidor local para PlantUML Para poder ejecutar el servidor es necesario seguir los siguientes pasos:\nDescargar e instalar Java.\nInstalar Graphviz, necesario para diagramas complejos.\nbrew install graphviz Descarga el fichero plantuml.jar desde la página oficial de Plantum o desde github releases.\nCon eso estaría todo. Simplemente ejecuta el siguiente comando en tu consola para tener listo el servidor local:\njava -jar plantuml.jar -picoweb:8000 Ejecutar PlantUML con imagen Docker Otra alternativa es obtener una imagen de Docker en lugar de instalar localmente.\nEjecuta Docker y descarga la imagen de PlantUML. Puedes hacer pull ejecutando:\ndocker pull plantuml/plantuml-server Ejecuta la imagen, por defecto el contenedor ejecuta el servidor en el puerto 8080. Podrías cambiar al 8000 por ejemplo con el siguiente comando:\ndocker run -d -p 8000:8080 plantuml/plantuml-server PlantUML VSCode settings Éstas son las settings relativas a la extensión PlantUML:\n{ \u0026#34;plantuml.server\u0026#34;: \u0026#34;http://localhost:8000\u0026#34;, \u0026#34;plantuml.render\u0026#34;: \u0026#34;PlantUMLServer\u0026#34;, \u0026#34;plantuml.diagramsRoot\u0026#34;: \u0026#34;docs/diagrams/src\u0026#34;, \u0026#34;plantuml.exportOutDir\u0026#34;: \u0026#34;docs/diagrams/out\u0026#34;, \u0026#34;plantuml.exportSubFolder\u0026#34;: false } Creando diagramas desde VSCode Ejecuta el servidor de PlantUML y crea un fichero en docs/diagrams/src, hello.puml por ejemplo, con este contenido:\n@startuml hello Alice -\u0026gt; Bob: test @enduml Escribe PlantUml en la paleta de comandos de VSCode y selecciona PlantUML: Preview Current Diagram (o usa el shortcut Option + D).\nSi todo está funcionando correctamente, deberías de ser capaz de visualizar la vista previa para el diagrama.\nAhora, escribe y selecciona en la paleta de comandos PlantUML: Export Current File Diagrams y exporta el diagrama a png, SVG o txt.\n","summary":"PlantUML PlantUML es una aplicación que permite escribir rápidamente diferentes tipos de diagramas (UML y no UML)."},{"url":"/blog/compartiendo-dtos-entre-nestjs-y-react/","title":"Compartiendo DTOs entre NestJS y React","content":"Durante los 2 últimos años, he estado trabajando en proyectos que utilizan estructura de monorepo, con NestJS para el backend y React para el frontend. Fruto de esta experiencia, he diseñado un approach para compartir eficientemente DTOs entre las 2 capas. Si buscas información acerca de este tema, no encontrarás una rápida respuesta asi que ¡allá vamos!.\nDTO (Data Transfer Object) Antes de nada, ¿Qué es un DTO (Data Transfer Object)? Extraído de la documentación oficial de NestJS:\nUn DTO es un objeto que define cómo se enviarán los datos a través de la red. Podríamos determinar el esquema del DTO utilizando interfaces de TypeScript o clases simples. Curiosamente, recomendamos utilizar clases. ¿Por qué? Las clases son parte del estándar ES6 de JavaScript y, por lo tanto, se preservan como entidades reales en el JavaScript compilado. Por otro lado, dado que las interfaces de TypeScript se eliminan durante la transpilación, Nest no puede referirse a ellas en tiempo de ejecución. Esto es importante porque características como Pipes permiten posibilidades adicionales cuando tienen acceso al metatipo de la variable en tiempo de ejecución.\nMe encanta lo sencillo que es validar parámetros con DTOs en NestJS, puedes usar decoradores class-validator para validar parámetros de entrada sin la necesidad de escribir ni una línea de código.\nPuedes documentar y generar el swagger para tus endpoints simplemente usando decoradores.\nEjemplo de un DTO:\nexport class ExampleRequestDto { @ApiProperty({ description: \u0026#39;Person ID\u0026#39;, example: \u0026#39;a94dd9b3-c0ae-43e2-b13e-31fce2e60203\u0026#39; }) @IsNotEmpty() personId: string; @ApiProperty({ description: \u0026#39;Address ID\u0026#39;, example: \u0026#39;a94dd9b3-c0ae-43e2-b13e-31fce2e60203\u0026#39; }) @IsNotEmpty() addressId: string; @ApiProperty({ description: \u0026#39;Telephone number ID\u0026#39;, example: \u0026#39;3e26f0e9-22e4-46eb-a14e-ad37fbdf2144\u0026#39; }) @IsNotEmpty() @IsOptional() phoneNumberId?: string; } Con este DTO podemos validar los parámetros de entrada para un endpoint, tenemos tipado, y podemos crear un maravilloso swagger con información para los desarrolladores que quieran utilizar esta API. Está muy chulo, ¿cierto?\n¿No sería genial si pudiéramos utilizar el mismo DTO, como fuente de verdad para tipado de parámetros de entrada en los servicios front? De esta manera eliminaríamos la necesidad de duplicar ambas definiciones. Inicialmente, tenía que generar version separadas del DTO utilizando Typescript plano con interfaces, ya que los decoradores no eran posibles en este caso. Era una tarea tediosa, pero utilizar un DTO compartido hace el proceso de desarrollo más productivo y eficiente.\nUsando DTOs para tipado en el frontend ¿Cómo podríamos utilizar el mismo DTO con decoradores en el frontend sin añadir cosas innecesarias a nuestro bundle? De primeras, pudiera parecer que instalar dependencias como @nestjs/swagger y class-validator e importándolas añadiríamos multitud de código a nuestro bundle.\nSin embargo, por lo que he podido probar, si solo utilizamos el DTO como un tipo, el resultado final del bundle no se verá afectado ya que los tipos son eliminados durante el proceso de compilado. Por tanto, incluso si utilizas una clase para definir el DTO, las referencias no será incluidas en el bundle final siempre y cuando se utilice como tipado. Veamos un ejemplo de configuración para un monorepo.\nPreparando el monorepo Crearemos en un directorio raíz 3 directorios: backend, frontend y common (aquí dejaremos los DTOs compartidos).\nBackend con NestJS Iniciaremos un proyecto con el CLI de NestJS:\nnest new backend cd backend npm i Frontend con React Como CRA está oficialmente deprecado, usaremos Vite, que es más rápido y una de las opciones más fáciles para inicializar un proyecto React sin utilizar ningún framework.\nnpm create vite@latest frontend -- --template react-ts cd frontend npm install Directorio common Crearemos un directorio común donde estarán los DTOs reutilizados para frontend y backend, e instalaremos las dependencias.\nmkdir common cd common npm i @nestjs/swagger class-validator npm i -D typescript Tenemos que definir un tsconfig.json:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;declaration\u0026#34;: true, \u0026#34;removeComments\u0026#34;: true, \u0026#34;emitDecoratorMetadata\u0026#34;: true, \u0026#34;experimentalDecorators\u0026#34;: true, \u0026#34;allowSyntheticDefaultImports\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;es2017\u0026#34;, \u0026#34;sourceMap\u0026#34;: true, \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34;, \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;, \u0026#34;incremental\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true, \u0026#34;strictNullChecks\u0026#34;: true, \u0026#34;noImplicitAny\u0026#34;: true, \u0026#34;strictBindCallApply\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true, \u0026#34;noFallthroughCasesInSwitch\u0026#34;: true } } Ahora crearemos un directorio api que contendrá los ficheros fuente para los DTOs. Destacar que no vamos a hacer build de este directorio común, copiaremos los ficheros utilizando este directorio como fuente de verdad. Por ejemplo, example.dto.ts:\nimport { ApiProperty } from \u0026#39;@nestjs/swagger\u0026#39;; import { IsNotEmpty, IsString } from \u0026#39;class-validator\u0026#39;; export class ExampleDto { @ApiProperty({ description: \u0026#39;Property description\u0026#39; }) @IsString() @IsNotEmpty() test: string; other: number; } Script para distribuir los DTOs para backend y frontend Instalaremos estas dependencias en el directorio raíz.\nnpm i -D cpx rimraf npm-run-all Definimos los siguientes scripts para distribuir los DTOs.\n// ---- scripts section from package.json \u0026#34;scripts\u0026#34;: { \u0026#34;predistribute:api:frontend\u0026#34;: \u0026#34;rimraf frontend/src/api\u0026#34;, \u0026#34;distribute:api:frontend\u0026#34;: \u0026#34;cpx ./common/api/**/* ./frontend/src/api\u0026#34;, \u0026#34;predistribute:api:backend\u0026#34;: \u0026#34;rimraf backend/src/api\u0026#34;, \u0026#34;distribute:api:backend\u0026#34;: \u0026#34;cpx ./common/api/**/* ./backend/src/api\u0026#34;, \u0026#34;distribute:api\u0026#34;: \u0026#34;npm-run-all distribute:api:frontend distribute:api:backend\u0026#34; } // ---- Finalmente, ejecutaremos el script para distribuir el directorio api:\nnpm run distribute:api Ya estamos listos para configurar frontend y backend con sus dependencias y configuración.\nConfigurando el frontend Tenemos que instalar las dependencias de NestJS, pero no te preocupes, no serán incluidas en el bundle final.\nnpm i @nestjs/swagger class-validator Y estas dependencias de desarrollo:\nnpm i -D @babel/plugin-proposal-class-properties @babel/plugin-proposal-decorators @types/node Actualizaremos el tsconfig.json, añadiendo las líneas destacadas:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;experimentalDecorators\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;ESNext\u0026#34;, \u0026#34;useDefineForClassFields\u0026#34;: true, \u0026#34;lib\u0026#34;: [\u0026#34;DOM\u0026#34;, \u0026#34;DOM.Iterable\u0026#34;, \u0026#34;ESNext\u0026#34;], \u0026#34;allowJs\u0026#34;: false, \u0026#34;skipLibCheck\u0026#34;: true, \u0026#34;esModuleInterop\u0026#34;: false, \u0026#34;allowSyntheticDefaultImports\u0026#34;: true, \u0026#34;strict\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true, \u0026#34;module\u0026#34;: \u0026#34;ESNext\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;Node\u0026#34;, \u0026#34;resolveJsonModule\u0026#34;: true, \u0026#34;isolatedModules\u0026#34;: true, \u0026#34;noEmit\u0026#34;: true, \u0026#34;jsx\u0026#34;: \u0026#34;react-jsx\u0026#34;, \u0026#34;strictPropertyInitialization\u0026#34;: false }, \u0026#34;include\u0026#34;: [\u0026#34;src\u0026#34;], \u0026#34;references\u0026#34;: [{ \u0026#34;path\u0026#34;: \u0026#34;./tsconfig.node.json\u0026#34; }] } Actualizaremos el tsconfig.node.json también:\n1 2 3 4 5 6 7 8 9 10 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;composite\u0026#34;: true, \u0026#34;module\u0026#34;: \u0026#34;ESNext\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;Node\u0026#34;, \u0026#34;allowSyntheticDefaultImports\u0026#34;: true, \u0026#34;experimentalDecorators\u0026#34;: true }, \u0026#34;include\u0026#34;: [\u0026#34;vite.config.ts\u0026#34;] } Finalmente tenemos que actualizar vite.config.ts. Añadiremos los plugins de Babel necesarios para procesas decoradores, y crearemos un alias para el archivo shim utilizado por @nestjs/swagger. Aunque no tenemos planeado instanciar ninguna clase de los DTOs, es siempre una buena idea disponer de una opción de fallback para algún caso de uso imprevisto o error. Este alias previene cargar codigo y polyfills innecesarios que serían requeridos en tales casos.\nimport { defineConfig } from \u0026#39;vite\u0026#39;; import react from \u0026#39;@vitejs/plugin-react\u0026#39;; import * as path from \u0026#39;path\u0026#39;; const swaggerShimFile = \u0026#39;node_modules/@nestjs/swagger/dist/extra/swagger-shim.js\u0026#39;; // https://vitejs.dev/config/ export default defineConfig({ plugins: [ react({ babel: { plugins: [ [\u0026#39;@babel/plugin-proposal-decorators\u0026#39;, { legacy: true }], [\u0026#39;@babel/plugin-proposal-class-properties\u0026#39;, { loose: true }] ] } }) ], resolve: { alias: { \u0026#39;@nestjs/swagger\u0026#39;: path.resolve(__dirname, swaggerShimFile) } } }); Ahora podemos ir al fichero App.tsx, y poner un ejemplo muy básico. Importaremos nuestro example.dto y lo usaremos como tipo.\nimport \u0026#39;./App.css\u0026#39;; import { ExampleDto } from \u0026#39;./api/example.dto\u0026#39;; const example: ExampleDto = { test: \u0026#39;testValue\u0026#39;, other: 2 }; function App() { return \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt;Hello world\u0026lt;/div\u0026gt;; } export default App; ¡Genial! Tendremos errores en typescript si no estamos definiendo correctamente el objeto, y una maravillosa experiencia de desarrollo gracias al autocompletado. Puedes comprobar que el proyecto se inicia sin errores ejecutando npm run dev y ejecutando el build con npm run build.\n\u0026gt; frontend@0.0.0 build \u0026gt; tsc \u0026amp;\u0026amp; vite build vite v4.2.2 building for production... ✓ 33 modules transformed. dist/index.html 0.46 kB dist/assets/index-d526a0c5.css 1.42 kB │ gzip: 0.74 kB dist/assets/index-d40907b6.js 142.90 kB │ gzip: 45.87 kB Para asegurarnos que el fichero shim está funcionando correctamente, editamos el fichero App.tsx e instanciamos un objeto ExampleDto.\nimport \u0026#39;./App.css\u0026#39;; import { ExampleDto } from \u0026#39;./api/example.dto\u0026#39;; const example = new ExampleDto(); function App() { return \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt;Hello world\u0026lt;/div\u0026gt;; } export default App; Resultado con la configuración de Vite con el archivo shim (el fichero JS crece un poco):\n\u0026gt; frontend@0.0.0 build \u0026gt; tsc \u0026amp;\u0026amp; vite build vite v4.2.2 building for production... ✓ 586 modules transformed. dist/index.html 0.46 kB dist/assets/index-d526a0c5.css 1.42 kB │ gzip: 0.74 kB dist/assets/index-e4051b0b.js 154.29 kB │ gzip: 49.15 kB Y el resultado sin archivo shim:\n\u0026gt; frontend@0.0.0 build \u0026gt; tsc \u0026amp;\u0026amp; vite build vite v4.2.2 building for production... transforming (1213) node_modules/rxjs/dist/cjs/internal/util/Immediate.js\u0026#34;@nestjs/websockets/socket-module\u0026#34; is imported by \u0026#34;@nestjs/websockets/socket-module?commonjs-external\u0026#34;, but could not be resolved – treating it as an external dependency. \u0026#34;@nestjs/microservices/microservices-module\u0026#34; is imported by \u0026#34;@nestjs/microservices/microservices-module?commonjs-external\u0026#34;, but could not be resolved – treating it as an external dependency. \u0026#34;class-transformer/storage\u0026#34; is imported by \u0026#34;class-transformer/storage?commonjs-external\u0026#34;, but could not be resolved – treating it as an external dependency. ✓ 2053 modules transformed. dist/index.html 0.46 kB dist/assets/index-d526a0c5.css 1.42 kB │ gzip: 0.74 kB dist/assets/index-f46b4c53.js 1,053.06 kB │ gzip: 296.88 kB (!) Some chunks are larger than 500 kBs after minification. Consider: - Using dynamic import() to code-split the application - Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/configuration-options/#output-manualchunks - Adjust chunk size limit for this warning via build.chunkSizeWarningLimit. ✓ built in 6.90s Como mencioné anteriormente, si utilizamos DTOs como tipos, esto no ocurrirá, pero es mejor tener configurado el archivo shim por precaución.\nConfigurando el backend Este paso es más sencillo porque NestJS ya está preparado para trabajar con decorators y DTOs, asi que simplemente instalamos las dependencias:\nnpm i @nestjs/swagger class-validator class-transformer Destacar que class-transformer es requerido junto con class-validator. Actualizamos el fichero main.ts con estos cambios:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { NestFactory } from \u0026#39;@nestjs/core\u0026#39;; import { ValidationPipe } from \u0026#39;@nestjs/common\u0026#39;; import { AppModule } from \u0026#39;./app.module\u0026#39;; async function bootstrap() { const app = await NestFactory.create(AppModule); app.useGlobalPipes( new ValidationPipe({ transform: true, whitelist: false, forbidNonWhitelisted: false }) ); await app.listen(3050); } bootstrap(); Este proceso está comentado en la documentación oficial de NestJS. Ahora probemos con un ejemplo muy sencillo. Reemplazamos el contenido de app.controller.ts con el siguiente código:\nimport { Body, Controller, Get, Post } from \u0026#39;@nestjs/common\u0026#39;; import { AppService } from \u0026#39;./app.service\u0026#39;; import { ExampleDto } from \u0026#39;./api/example.dto\u0026#39;; @Controller() export class AppController { constructor(private readonly appService: AppService) {} @Get() getHello(): string { return this.appService.getHello(); } @Post(\u0026#39;test\u0026#39;) postHello(@Body() exampleDto: ExampleDto) { return this.appService.postHello(exampleDto); } } Y app.service.ts con:\nimport { Injectable } from \u0026#39;@nestjs/common\u0026#39;; import { ExampleDto } from \u0026#39;./api/example.dto\u0026#39;; @Injectable() export class AppService { getHello(): string { return \u0026#39;Hello World!\u0026#39;; } postHello(exampleDto: ExampleDto) { return { success: true }; } } Nuestro endpoint está tipado correctamente, podemos beneficiarnos de las validaciones con decoradores y tendremos nuestra API documentada con su swagger (esta parte ha sido omitida en esta guía). Podemos comprobar que los decoradores están funcionando ejecutando npm run start:dev, y haciendo una petitición post con parámetros a http://localhost:3050/test.\nSi la propiedad test no es un string, obtendremos un error.\nBody para la request:\n{ \u0026#34;test\u0026#34;: 2, \u0026#34;other\u0026#34;: 2 } Respuesta:\n{ \u0026#34;statusCode\u0026#34;: 400, \u0026#34;message\u0026#34;: [\u0026#34;test must be a string\u0026#34;], \u0026#34;error\u0026#34;: \u0026#34;Bad Request\u0026#34; } Si utilizamos string, la petición termina correctamente.\nBody para la request:\n{ \u0026#34;test\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;other\u0026#34;: 2 } Respuesta:\n{ \u0026#34;success\u0026#34;: true } Resumen y conclusión Hemos experimentado cómo compartir DTOs entre un backend NestJS y un frontend React. Aunque puede que haya métodos alternativos, no hay mucha información disponible acerca de este tema. Por tanto, en esta guía tenemos una solución que funciona.\nHay espacio para mejorar el enfoque, como ignorar el directorio API en el backend y frontend, que tiene el mismo contenido que el directorio common.\nPara evitar errores en el futuro, asegurate de instalar la misma versión de @nestjs/swagger y class-validator en los 3 proyectos.\nEspera que esta guía haya sido de utilidad. Puedes encontrar el ejemplo en este repositorio.\n","summary":"Durante los 2 últimos años, he estado trabajando en proyectos que utilizan estructura de monorepo, con NestJS para el backend y React para el frontend."},{"url":"/blog/gesti%C3%B3n-de-literales-en-react-con-react-intl/","title":"Gestión de literales en react con react-intl","content":"En esta publicación, vamos a adentrarnos en un enfoque para la gestión de literales de un proyecto de React utilizando react-intl.\nConfigurando un nuevo proyecto con create-react-app Iniciamos un nuevo proyecto de React con CRA, una de las formas más fáciles de hacerlo sin tener que lidiar con la configuración de webpack.\nnpx create-react-app react-intl-example --template typescript cd react-intl-example npm start Instalando react-intl El siguiente paso es instalar react-intl como una dependencia:\nnpm i react-intl También necesitaremos una dependencia de desarrollo para extraer y compilar los literales:\nnpm i -D @formatjs/cli Usando react-intl en una aplicación de React Comencemos a usar react-intl en nuestra aplicación de React de prueba.\nCrea una carpeta lang en src con un archivo JSON vacío llamado en.json. Este archivo contendrá más tarde el resultado de la compilación para cada literal en la aplicación. Explicaremos más adelante en detalle cómo lograr esto.\n{} Editamos index.tsx en la carpeta src. Tenemos que importar IntlProvider de react-intl y envolver nuestra aplicación con él. Estamos creando algunos componentes para rich elements que por defecto se usarán globalmente en los literales de la aplicación.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom/client\u0026#34;; import \u0026#34;./index.css\u0026#34;; import App from \u0026#34;./App\u0026#34;; import reportWebVitals from \u0026#34;./reportWebVitals\u0026#34;; import { IntlProvider } from \u0026#34;react-intl\u0026#34;; import literals from \u0026#34;./lang/en.json\u0026#34;; interface Props { children?: React.ReactNode; } const Bold = (props: Props) =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;strong\u0026gt;{props.children}\u0026lt;/strong\u0026gt; \u0026lt;/div\u0026gt; ); }; const root = ReactDOM.createRoot( document.getElementById(\u0026#34;root\u0026#34;) as HTMLElement ); root.render( \u0026lt;IntlProvider locale=\u0026#34;en\u0026#34; defaultLocale=\u0026#34;en\u0026#34; messages={literals} defaultRichTextElements={{ bold: (chunks) =\u0026gt; \u0026lt;Bold\u0026gt;{chunks}\u0026lt;/Bold\u0026gt;, }} \u0026gt; \u0026lt;React.StrictMode\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/React.StrictMode\u0026gt; \u0026lt;/IntlProvider\u0026gt; ); // If you want to start measuring performance in your app, pass a function // to log results (for example: reportWebVitals(console.log)) // or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals reportWebVitals(); El siguiente paso es crear una nueva carpeta con un archivo example.ts donde definiremos algunos literales. Por ejemplo, uno usando un rich element global definido anteriormente (usado como una etiqueta HTML, \u0026lt;bold\u0026gt;\u0026lt;/bold\u0026gt; en este ejemplo), y otro literal regular simple. Lo haremos utilizando la función defineMessages de react-intl.\nimport { defineMessages } from \u0026#34;react-intl\u0026#34;; export default defineMessages({ hello: { id: \u0026#34;a.hello\u0026#34;, defaultMessage: \u0026#34;\u0026lt;bold\u0026gt;hello\u0026lt;/bold\u0026gt;\u0026#34;, }, world: { id: \u0026#34;a.world\u0026#34;, defaultMessage: \u0026#34;world\u0026#34;, }, }); Podemos crear otro archivo de literales llamado other.ts dentro de la carpeta messages. Esto es solo un ejemplo, puedes crear tantos archivos de literales como desees y colocarlos donde quieras, esa decisión está en tus manos y es subjetiva.\nimport { defineMessages } from \u0026#34;react-intl\u0026#34;; export default defineMessages({ other: { id: \u0026#34;a.richtext\u0026#34;, defaultMessage: \u0026#34;I have \u0026lt;test\u0026gt;{num}\u0026lt;/test\u0026gt;\u0026#34;, }, }); Ahora podemos comenzar a importar nuestros literales en la aplicación. Para simplificar, mostraré cómo hacerlo editando directamente el archivo App.tsx de la siguiente manera:\nimport React from \u0026#34;react\u0026#34;; import { FormattedMessage } from \u0026#34;react-intl\u0026#34;; import exampleMessages from \u0026#34;./messages/example\u0026#34;; import otherMessages from \u0026#34;./messages/other\u0026#34;; function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;FormattedMessage {...exampleMessages.hello} /\u0026gt;{\u0026#34; \u0026#34;} \u0026lt;FormattedMessage {...exampleMessages.world} /\u0026gt; \u0026lt;FormattedMessage id={otherMessages.other.id} defaultMessage={otherMessages.other.defaultMessage} values={{ num: 99, test: (chunks: any) =\u0026gt; \u0026lt;strong\u0026gt;{chunks}!!\u0026lt;/strong\u0026gt; }} /\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; En este ejemplo, estamos cargando nuestros literales desde dos archivos diferentes y utilizando el componente FormattedMessage de la biblioteca react-intl. Puedes consultar en la documentación oficial diferentes formas de declarar mensajes.\nPor lo tanto, cada vez que deseemos usar un literal en la aplicación, podemos definirlo en un archivo separado e importarlo para usarlo. Si no se encuentra un literal en el archivo compilado lang/en.json, se utilizará el valor proporcionado en defaultMessage. Esto es muy útil porque no es necesario compilar los literales cada vez que necesitemos un nuevo literal mientras desarrollamos.\nExtrayendo y compilando literales con formatJS Crearemos algunos scripts en el archivo package.json para automatizar el proceso de extracción y compilación de literales. Podemos consultar la documentación oficial para obtener más detalles. Utilizaremos un comando muy largo de la documentación y lo dividiremos en algunos scripts para una mejor legibilidad. Veamos los scripts y luego la explicación de los comandos ejecutados:\n// ---- scripts section from package.json \u0026#34;scripts\u0026#34;: { \u0026#34;literals:extract\u0026#34;: \u0026#34;formatjs extract \u0026#39;src/**/*.ts*\u0026#39; --ignore=\u0026#39;**/*.d.ts\u0026#39; --out-file temp.json --flatten --id-interpolation-pattern \u0026#39;[sha512:contenthash:base64:6]\u0026#39;\u0026#34;, \u0026#34;literals:compile\u0026#34;: \u0026#34;formatjs compile \u0026#39;temp.json\u0026#39;\u0026#34;, \u0026#34;postliterals:compile\u0026#34;: \u0026#34;rm temp.json\u0026#34;, } // ---- El primer comando extraerá cada una de los literales definidos en la aplicación bajo la carpeta src a un archivo temporal llamado temp.json.\nformatjs extract \u0026#39;src/**/*.ts*\u0026#39; --ignore=\u0026#39;**/*.d.ts\u0026#39; --out-file temp.json --flatten --id-interpolation-pattern \u0026#39;[sha512:contenthash:base64:6]\u0026#39; Advertencias: El comando incluye una opción para generar ids, pero con la configuración de create-react-app, esta característica no funcionará porque es necesario editar la configuración de webpack y babel.\nUna vez extraídos los literales a un archivo, los compilaremos especificando el archivo de destino (destacar los parámetros adicionales utilizados en el comando, no están presentes en el script anterior, agregaremos más scripts al final):\nformatjs compile \u0026#39;temp.json\u0026#39; --out-file src/lang/en.json Con este comando, el archivo generado (src/lang/en.json) será el siguiente:\n{ \u0026#34;a.hello\u0026#34;: \u0026#34;\u0026lt;bold\u0026gt;hello\u0026lt;/bold\u0026gt;\u0026#34;, \u0026#34;a.richtext\u0026#34;: \u0026#34;I have \u0026lt;test\u0026gt;{num}\u0026lt;/test\u0026gt;\u0026#34;, \u0026#34;a.world\u0026#34;: \u0026#34;world\u0026#34; } Si deseamos traducir nuestros literales a otro idioma, este archivo debe ser utilizado como punto de partida, y se deben traducir cada uno de los literales. Luego, debemos crear un nuevo archivo, por ejemplo es.json, y agregar lógica en index.tsx para cargar el archivo en.json o es.json dependiendo del idioma seleccionado en la aplicación.\nSi iniciamos nuestra aplicación con este archivo, todo funcionará según lo esperado, pero en las DevTools se puede leer esta advertencia:\n[@formatjs/intl] \u0026quot;defaultRichTextElements\u0026quot; was specified but \u0026quot;message\u0026quot; was not pre-compiled. Please consider using \u0026quot;@formatjs/cli\u0026quot; to pre-compile your messages for performance. For more details see https://formatjs.io/docs/getting-started/message-distribution.\nEsto se debe a que estamos usando la opción defaultRichTextElements globalmente para los literales, y cada vez que se carga un literal, la biblioteca no sabe si el literal está utilizando defaultRichTextElements o no. Por esta razón, debemos compilar utilizando el flag ast:\nformatjs compile \u0026#39;temp.json\u0026#39; --ast --out-file src/lang/en.json Después de esto, el resultado será diferente:\n{ \u0026#34;a.hello\u0026#34;: [ { \u0026#34;children\u0026#34;: [ { \u0026#34;type\u0026#34;: 0, \u0026#34;value\u0026#34;: \u0026#34;hello\u0026#34; } ], \u0026#34;type\u0026#34;: 8, \u0026#34;value\u0026#34;: \u0026#34;bold\u0026#34; } ], \u0026#34;a.richtext\u0026#34;: [ { \u0026#34;type\u0026#34;: 0, \u0026#34;value\u0026#34;: \u0026#34;I have \u0026#34; }, { \u0026#34;children\u0026#34;: [ { \u0026#34;type\u0026#34;: 1, \u0026#34;value\u0026#34;: \u0026#34;num\u0026#34; } ], \u0026#34;type\u0026#34;: 8, \u0026#34;value\u0026#34;: \u0026#34;test\u0026#34; } ], \u0026#34;a.world\u0026#34;: [ { \u0026#34;type\u0026#34;: 0, \u0026#34;value\u0026#34;: \u0026#34;world\u0026#34; } ] } Y si iniciamos la aplicación con este archivo, la advertencia desaparecerá. Finalmente, podemos agregar más scripts con los flags necesarios para cada caso. Extracto final de los scripts:\n// ---- scripts section from package.json \u0026#34;scripts\u0026#34;: { \u0026#34;literals:extract\u0026#34;: \u0026#34;formatjs extract \u0026#39;src/**/*.ts*\u0026#39; --ignore=\u0026#39;**/*.d.ts\u0026#39; --out-file temp.json --flatten --id-interpolation-pattern \u0026#39;[sha512:contenthash:base64:6]\u0026#39;\u0026#34;, \u0026#34;literals:compile\u0026#34;: \u0026#34;formatjs compile \u0026#39;temp.json\u0026#39;\u0026#34;, \u0026#34;postliterals:compile\u0026#34;: \u0026#34;rm temp.json\u0026#34;, \u0026#34;literals:en\u0026#34;: \u0026#34;npm run literals:compile -- --out-file src/lang/en.json\u0026#34;, \u0026#34;literals:en:ast\u0026#34;: \u0026#34;npm run literals:compile -- --ast --out-file src/lang/en.json\u0026#34;, \u0026#34;literals:extract:compile\u0026#34;: \u0026#34;npm-run-all literals:extract literals:en\u0026#34;, \u0026#34;literals:extract:compile:ast\u0026#34;: \u0026#34;npm-run-all literals:extract literals:en:ast\u0026#34; } // ---- Los últimos 2 scripts están utilizando npm-run-all como una dependencia de desarrollo, puedes instalarla usando: npm i -D npm-run-all.\nPara generar los literales en la aplicación, podemos ejecutar literals:extract:compile para generar un archivo listo para ser traducido, o literals:extract:compile:ast para un archivo listo para producción.\nSe puede revisar un repositorio con este ejemplo de aplicación en mi cuenta de Github.\nNota: No he probado BalbelEdit pero parece que puede ser muy útil a la hora de traducir una aplicación, soporta React.\n","summary":"En esta publicación, vamos a adentrarnos en un enfoque para la gestión de literales de un proyecto de React utilizando react-intl."},{"url":"/blog/flujo-de-trabajo-sencillo-para-un-monorepo/","title":"Flujo de trabajo sencillo para un monorepo","content":"En mi trabajo actual, me ha tocado configurar un monorepo con hooks de git, ESLint, Prettier y algunas acciones propias. Quiero dejar constancia del proceso de cara a poder volver a consultar en el futuro. Este es el caso de uso:\nDirectorio backend, con proyecto de NestJS. NestJS es un framework para backend en Node, utiliza Typescript. Directorio frontend, con un proyecto React + Typescript. Configuración global de Prettier, compartida entre ambos proyectos. ESLint para linting, cada proyecto tendrá su propia configuración. Además de ESLint, tsc para las comprobaciones de tipo. Hook pre-commit para git: ejecutará eslint --fix y prettier --write en los archivos que se incluyan en los commit. Si ESLint o tsc detectan algún error, el commit será abortado. Git pre-push hook: ejecutará los tests unitarios, si los ficheros cambiados corresponden al proyecto de backend, ejecutará solo los tests de backend. Hará lo mismo para frontend y, en caso de haber cambios en ambos directorios ejecutará ambos. Git push será abortado si se encuentra algún error. Empecemos explicando paso a paso.\nInicialización del backend con NestJS Como he mencionado al comienzo, utilizaremos NestJS para el backend. El primer paso será instalar el CLI de Nest para iniciar el proyecto. Por tanto, crearemos un nuevo proyecto:\nnpm i -g @nestjs/cli nest new backend Ya que esta será parte backend del monorepo, eliminaremos la carpeta .git creada dentro del directorio backend.\nInicialización del frontend Una vez creado el backend, procederemos a crear el frontend con React + Typescript utilizando create-react-app:\nnpx create-react-app frontend --template typescript Instalar prettier Ambos proyectos utilizarán Prettier. Lo instalaremos tanto en el directorio de frontend como en el de backend.\ncd backend npm install --save-dev --save-exact prettier cd ../frontend npm install --save-dev --save-exact prettier Ahora podemos crear el fichero de configuración .prettierrc en el directorio raíz (será compartido por ambos proyectos). Podemos añadir nuestras reglas preferidas, un ejemplo:\n{ \u0026#34;printWidth\u0026#34;: 80, \u0026#34;tabWidth\u0026#34;: 2, \u0026#34;trailingComma\u0026#34;: \u0026#34;all\u0026#34;, \u0026#34;singleQuote\u0026#34;: true, \u0026#34;semi\u0026#34;: true } A continuación crearemos scripts npm para ejecutar prettier. En frontend/package.json:\n\u0026#34;scripts\u0026#34;: { // ... \u0026#34;format\u0026#34;: \u0026#34;prettier --write \u0026#39;src/**/*.{js,jsx,ts,tsx,json,css,scss,md}\u0026#39;\u0026#34; }, En backend/package.json:\n\u0026#34;scripts\u0026#34;: { // ... \u0026#34;format\u0026#34;: \u0026#34;prettier --write \u0026#39;src/**/*.ts\\\u0026#39; \u0026#39;test/**/*.ts\u0026#39;\u0026#34;, }, Configurando ESLint En este momento configuraremos ESLint para el linting. Como estamos usando Prettier, instalaremos un paquete que desactivará reglas que son innecesarias o pudieran entrar en conflicto con ESLint. Después de eso, instalaremos un plugin para auto ordenar los imports, pero veamos la configuración básica primero.\nVamos con frontend primero:\ncd frontend npm i -D eslint eslint-config-prettier @typescript-eslint/parser Además, crearemos un fichero .eslintrc.js en el directorio frontend:\nmodule.exports = { extends: [ \u0026#39;react-app\u0026#39;, \u0026#39;react-app/jest\u0026#39;, \u0026#39;prettier\u0026#39;, ], parser: \u0026#39;@typescript-eslint/parser\u0026#39;, ignorePatterns: [\u0026#39;.eslintrc.js\u0026#39;], rules: { \u0026#39;no-console\u0026#39;: \u0026#39;warn\u0026#39;, \u0026#39;no-debugger\u0026#39;: \u0026#39;warn\u0026#39;, \u0026#39;no-alert\u0026#39;: \u0026#39;warn\u0026#39;, }, }; Ésta es la configuración más básica para React con Typescript. Se evitan los conflictos con Prettier y es un estupendo punto de inicio para personalizar o extender con otro tipo de configuraciones.\nComo bonus, en nuestro proyecto añadimos el plugin eslint-plugin-import para ordenar los imports siguiendo siempre el mismo criterio. Si no te interesa puedes saltarte esta parte. Debemos instalar los siguientes paquetes:\nnpm i -D eslint-import-resolver-typescript eslint-plugin-import Y finalmente la configuración (hay multitud de reglas que pueden ser personalizadas):\nmodule.exports = { extends: [ \u0026#39;react-app\u0026#39;, \u0026#39;react-app/jest\u0026#39;, \u0026#39;plugin:import/recommended\u0026#39;, \u0026#39;plugin:import/typescript\u0026#39;, \u0026#39;prettier\u0026#39;, ], plugins: [\u0026#39;import\u0026#39;], parser: \u0026#39;@typescript-eslint/parser\u0026#39;, ignorePatterns: [\u0026#39;.eslintrc.js\u0026#39;], rules: { \u0026#39;no-console\u0026#39;: \u0026#39;warn\u0026#39;, \u0026#39;no-debugger\u0026#39;: \u0026#39;warn\u0026#39;, \u0026#39;no-alert\u0026#39;: \u0026#39;warn\u0026#39;, \u0026#39;import/order\u0026#39;: [ \u0026#39;error\u0026#39;, { groups: [\u0026#39;builtin\u0026#39;, \u0026#39;external\u0026#39;, \u0026#39;parent\u0026#39;, \u0026#39;sibling\u0026#39;, \u0026#39;index\u0026#39;], pathGroups: [ { pattern: \u0026#39;react**\u0026#39;, group: \u0026#39;builtin\u0026#39;, position: \u0026#39;after\u0026#39;, }, { pattern: \u0026#39;*.scss\u0026#39;, patternOptions: { matchBase: true }, group: \u0026#39;index\u0026#39;, position: \u0026#39;after\u0026#39;, }, ], pathGroupsExcludedImportTypes: [\u0026#39;react\u0026#39;], \u0026#39;newlines-between\u0026#39;: \u0026#39;always\u0026#39;, alphabetize: { order: \u0026#39;asc\u0026#39;, caseInsensitive: true, }, warnOnUnassignedImports: true, }, ], }, settings: { \u0026#39;import/parsers\u0026#39;: { \u0026#39;@typescript-eslint/parser\u0026#39;: [\u0026#39;.ts\u0026#39;, \u0026#39;.tsx\u0026#39;], }, }, }; Ahora, cuando ejecutemos eslint --fix, todos los imports deberían formatearse automáticamente.\nNOTA: Los imports que no son nombrados no pueden ser ordenados automáticamente porque, en este tipo de imports, el orden importa. Este tipo de imports serán marcados como error, pero deben ser ordenados manualmente.\nEjemplo: import \u0026lsquo;./App.scss\u0026rsquo;;\nFinalmente, podemos eliminar del package.json la configuración de ESLint que fue creada por create-react-app:\n\u0026#34;eslintConfig\u0026#34;: { \u0026#34;extends\u0026#34;: [ \u0026#34;react-app\u0026#34;, \u0026#34;react-app/jest\u0026#34; ] }, Una vez tenemos ESLint funcionando en el frontend, vayamos a por el backend. NestJS viene con una configuración por defecto que es un buen punto de partida. Vamos a modificarla e instalar eslint-plugin-import.\ncd backend npm i -D eslint-import-resolver-typescript eslint-plugin-import El fichero .eslintrc.js final, con el plugin de Prettier y la configuración para los imports:\nmodule.exports = { parser: \u0026#39;@typescript-eslint/parser\u0026#39;, plugins: [\u0026#39;@typescript-eslint/eslint-plugin\u0026#39;, \u0026#39;import\u0026#39;], extends: [ \u0026#39;plugin:@typescript-eslint/recommended\u0026#39;, \u0026#39;plugin:import/recommended\u0026#39;, \u0026#39;plugin:import/typescript\u0026#39;, \u0026#39;prettier\u0026#39;, ], root: true, env: { node: true, jest: true, }, ignorePatterns: [\u0026#39;.eslintrc.js\u0026#39;], rules: { \u0026#39;no-console\u0026#39;: \u0026#39;warn\u0026#39;, \u0026#39;no-debugger\u0026#39;: \u0026#39;warn\u0026#39;, \u0026#39;@typescript-eslint/interface-name-prefix\u0026#39;: \u0026#39;off\u0026#39;, \u0026#39;@typescript-eslint/explicit-function-return-type\u0026#39;: \u0026#39;off\u0026#39;, \u0026#39;@typescript-eslint/explicit-module-boundary-types\u0026#39;: \u0026#39;off\u0026#39;, \u0026#39;@typescript-eslint/no-explicit-any\u0026#39;: \u0026#39;off\u0026#39;, \u0026#39;@typescript-eslint/ban-ts-comment\u0026#39;: \u0026#39;off\u0026#39;, \u0026#39;import/order\u0026#39;: [ \u0026#39;error\u0026#39;, { groups: [\u0026#39;builtin\u0026#39;, \u0026#39;external\u0026#39;, \u0026#39;parent\u0026#39;, \u0026#39;sibling\u0026#39;, \u0026#39;index\u0026#39;], pathGroups: [ { pattern: \u0026#39;@nestjs**\u0026#39;, group: \u0026#39;builtin\u0026#39;, position: \u0026#39;after\u0026#39;, }, ], pathGroupsExcludedImportTypes: [\u0026#39;@nestjs\u0026#39;], \u0026#39;newlines-between\u0026#39;: \u0026#39;always\u0026#39;, alphabetize: { order: \u0026#39;asc\u0026#39;, caseInsensitive: true, }, warnOnUnassignedImports: true, }, ], }, settings: { \u0026#39;import/parsers\u0026#39;: { \u0026#39;@typescript-eslint/parser\u0026#39;: [\u0026#39;.ts\u0026#39;, \u0026#39;.tsx\u0026#39;], }, }, }; Git pre-commit hook Queremos ejecutar ciertas operaciones en los ficheros que hacemos commit, tales como formatear con prettier y lanzar el lint con eslint --fix. Para conseguir esto, utilizaremos Husky que se encargará de ejecutar estas acciones como hooks de git.\nInstalando husky Debemos crear un fichero package.json en el raíz de nuestro proyecto para poder instalar Husky como dependencia. Ejecutaremos:\nnpm init -y Acto seguido, rellenamos los campos con la información que queramos, y procederemos a instalar Husky y crear y ejecutar el script prepare:\nnpm i -D husky npm set-script prepare \u0026#34;husky install\u0026#34; npm run prepare prepare es un script que forma parte del ciclo de vida, y será ejecutado justo después de hacer npm install en un repositorio. Si estás utilizando Yarn, quizás husky no se instala automáticamente después del install. En ese caso, debemos ejecutarlo manualmente:\nnpm run prepare Finalmente podemos añadir el hook pre-commit. Ejecutaremos npm run lint en el pre-commit (en breve definiremos este script).\nnpx husky add .husky/pre-commit \u0026#34;npm run lint\u0026#34; Un fichero llamado pre-commit aparecerá bajo el directorio .husky, con el siguiente contenido:\n#!/bin/sh . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; npm run lint NOTA: Si utilizas un cliente para Git como Sourcetree, y obtienes el error command not found, es necesario crear un fichero ~/.huskyrc para cargar lo necesario antes de ejecutar el hook (descrito aquí). Por ejemplo, para nvm:\n# ~/.huskyrc # This loads nvm.sh and sets the correct PATH before running hook export NVM_DIR=\u0026#34;$HOME/.nvm\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; Añadiendo scripts npm en el package.json raíz Una vez definidos el hook, debemos crear el script lint en el package.json. Este script ejecutará a su vez 2 scripts, uno para el lint en el backend, y otro para el frontend. Añadimos estas líneas:\n\u0026#34;scripts\u0026#34;: { // ... \u0026#34;lint\u0026#34;: \u0026#34;npm-run-all lint:backend lint:frontend\u0026#34;, \u0026#34;lint:backend\u0026#34;: \u0026#34;cd backend \u0026amp;\u0026amp; npm run lint:staged\u0026#34;, \u0026#34;lint:frontend\u0026#34;: \u0026#34;cd frontend \u0026amp;\u0026amp; npm run lint:staged\u0026#34;, }, Estamos utilizando npm-run-all en el script lint para ejecutar los otros 2 scripts, por tanto debemos instalar esta dependencia en el package.json del raíz:\nnpm i -D npm-run-all El siguiente paso es definir el script lint:staged en backend/package.json y en frontend/package.json, pero antes, instalaremos otra dependencia para el linting.\nInstalando tsc-files tsc-files es una pequeña herramienta para ejecutar tsc en determinados ficheros sin ignorar el tsconfig.json. Este paquete fue creado porque pasar ficheros específicos de esta manera tsc --noEmit file1.ts file2.ts propicia que Typescript simplemente ignora el tsconfig.json.\nInstalamos tsc-files, que se necesitará en pasos posteriores:\ncd backend npm i -D tsc-files cd ../frontend npm i -D tsc-files lint-staged para backend y frontend lint-staged es un paquete que nos permite ejecutar linters en los ficheros staged en git. De esta manera, no permitiremos que entren bus en nuestro código, y aprovecharemos la oportunidad para formatear los ficheros.\nInstalaremos esta dependencia de desarrollo tanto en backend como en frontend:\ncd backend npm i -D lint-staged cd ../frontend npm i -D lint-staged Ahora definiremos la configuración para lint-staged que se aplicará al ejecutar nuestras tareas. Podemos definir esta configuración en el fichero package.json o en un archivo separado. Para ambos proyectos, ejecutaremos eslint --fix, tsc para comprobaciones de tipo y prettier para formateo.\nAdicionalmente, tenemos que añadir un script lint:staged, que será invocado desde el package.json raíz.\nVayamos por el primero:\nbackend/package.json\n\u0026#34;scripts\u0026#34;: { // ... \u0026#34;lint:staged\u0026#34;: \u0026#34;lint-staged\u0026#34;, // ... } // ... \u0026#34;lint-staged\u0026#34;: { \u0026#34;src/**/*.+(ts)\u0026#34;: [ \u0026#34;eslint --fix\u0026#34;, \u0026#34;tsc-files --noEmit\u0026#34; ], \u0026#34;src/**/*.{ts,json,md}\u0026#34;: [ \u0026#34;prettier --write\u0026#34; ] } frontend/package.json\n\u0026#34;scripts\u0026#34;: { // ... \u0026#34;lint:staged\u0026#34;: \u0026#34;lint-staged\u0026#34;, // ... } // ... \u0026#34;lint-staged\u0026#34;: { \u0026#34;src/**/*.+(ts|tsx)\u0026#34;: [ \u0026#34;eslint --fix\u0026#34;, \u0026#34;tsc-files --noEmit\u0026#34; ], \u0026#34;src/**/*.{js,jsx,ts,tsx,json,css,scss,md}\u0026#34;: [ \u0026#34;prettier --write\u0026#34; ], \u0026#34;*.js\u0026#34;: \u0026#34;eslint --cache --fix\u0026#34; } Resumen pre-commit Con todos estos pasos completados, hemos terminado la configuración del hook pre-commit. Este será el flujo ejecutado cuando hagamos commit:\nEl script pre-commit de husky ejecutará npm run lint que se encuentra definido en el package.json raíz. El script lint acudirá tanto a los directorios de backend como de frontend y ejecutará npm run lint:staged. lint-staged será invocada y recibirá la lista de archivos involucrados en el commit. Si no encuentra ningún fichero definido en la configuración no hará nada. En caso de encontrar un error el commit es abortado hasta que se resuelva el problema. Git pre-push hook Con este hook, queremos asegurarnos de que no hacemos push de código que pueda romper nuestros tests unitarios. Nuevamente utilizaremos husky, utilizando la misma estrategia seguida en el hook pre-commit using the same strategy as pre-commit hook. Vayamos directamente al lío. En el directorio raíz del proyecto:\nnpx husky add .husky/pre-push \u0026#34;npm run pre-push\u0026#34; Un fichero pre-push dentro del directorio .husky aparecerá con este contenido:\n#!/bin/sh . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; npm run pre-push Añadiendo scripts npm en el package.json raíz Con el hook ya definido, debemos crear un script pre-push en el package.json raíz. Este script invocará a otros 2 scripts, uno para backend y otro para frontend. Añadimos estas líneas:\n\u0026#34;scripts\u0026#34;: { // ... \u0026#34;pre-push\u0026#34;: \u0026#34;npm-run-all pre-push:backend pre-push:frontend\u0026#34;, \u0026#34;pre-push:frontend\u0026#34;: \u0026#34;cd frontend \u0026amp;\u0026amp; npm run pre-push\u0026#34;, \u0026#34;pre-push:backend\u0026#34;: \u0026#34;cd backend \u0026amp;\u0026amp; npm run pre-push\u0026#34;, }, El siguiente objetivo es definir el script pre-push en backend/package.json y en frontend/package.json.\nprepush-if-changed para backend y frontend prepush-if-changed es un paquete similar a lint-staged pero para git push. No es tan popular como lint-staged, pero lo he probado yo mismo y funciona correctamente. Queremos lanzar los test unitarios y el linting, pero solo si algún fichero de backend o frontend está involucrado en los ficheros que vamos a hacer push.\nPor ejemplo, si estamos haciendo push de cambios en frontend, solo queremos ejecutar los test de la parte de front y su lint. Lo mismo aplica para backend, y en caso de tener cambios de ambos proyectos, se comprobarán ambos.\nInstalaremos esta dependencia de desarrollo tanto en backend como en frontend:\ncd backend npm i -D prepush-if-changed cd ../frontend npm i -D prepush-if-changed Definiremos la configuración utilizad para prepush-if-changed. Podemos definirla en el package.json o en un fichero aparte.\nAdemás, tenemos que añadir un script llamado pre-push (y sus tareas dependientes), que será ejecutado desde el package.json raíz. Si algún test o el proceso de lint fallan, el git push será abortado.\nVamos con el primero:\nbackend/package.json\n\u0026#34;scripts\u0026#34;: { // ... \u0026#34;pre-push\u0026#34;: \u0026#34;npm-run-all pre-push:test lint\u0026#34;, \u0026#34;pre-push:test\u0026#34;: \u0026#34;prepush-if-changed\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;npm-run-all lint:eslint lint:tsc\u0026#34;, \u0026#34;lint:eslint\u0026#34;: \u0026#34;eslint \u0026#39;src/**/*.ts\u0026#39;\u0026#34;, \u0026#34;lint:tsc\u0026#34;: \u0026#34;tsc -p tsconfig.json\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;npm run test:unit \u0026amp;\u0026amp; npm run test:e2e\u0026#34;, \u0026#34;test:unit\u0026#34;: \u0026#34;jest --runInBand\u0026#34;, \u0026#34;test:e2e\u0026#34;: \u0026#34;jest --config ./test/jest-e2e.json\u0026#34;, // ... } // ... \u0026#34;prepush-if-changed\u0026#34;: { \u0026#34;src/**/*.+(ts)\u0026#34;: \u0026#34;echo \u0026#39;Files changed on backend. Launching tests.\u0026#39; \u0026amp;\u0026amp; npm run test\u0026#34; }, Breve explicación del proceso:\nEl script pre-push lanzará pre-push:test que a su vez ejecuta prepush-if-changed con la configuración mostrada, y después de eso, lint. Si la configuración de prepush-if-changed encuentra algún resultado, ejecutará el script test. El script test ejecutará test:unit y test:e2e. Por último, el script lint ejecuta lint:eslint y lint:tsc. frontend/package.json\n\u0026#34;scripts\u0026#34;: { // ... \u0026#34;pre-push\u0026#34;: \u0026#34;npm-run-all pre-push:test lint\u0026#34;, \u0026#34;pre-push:test\u0026#34;: \u0026#34;prepush-if-changed\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;npm-run-all lint:eslint lint:tsc\u0026#34;, \u0026#34;lint:eslint\u0026#34;: \u0026#34;eslint \u0026#39;src/**/*.{ts,tsx}\u0026#39;\u0026#34;, \u0026#34;lint:tsc\u0026#34;: \u0026#34;tsc -p tsconfig.json\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;react-scripts test\u0026#34;, // ... } // ... \u0026#34;prepush-if-changed\u0026#34;: { \u0026#34;src/**/*.+(ts|tsx)\u0026#34;: \u0026#34;echo \u0026#39;Files changed on frontend. Launching tests.\u0026#39; \u0026amp;\u0026amp; npm run test -- --watchAll=false\u0026#34; }, Nota para frontend:\nEl script pre-push ejecuta pre-push:test que a su vez lanza prepush-if-changed con la configuración mostrada, y después de eso, lint. Si la configuración de prepush-if-changed encuentra algún resultado, procederá a lanzar npm run test -- --watchAll=false. Finalmente, el script lint ejecuta lint:eslint y lint:tsc. Vaya este post ha sido largo, muy interesante como futura referencia. Toca un montón de temas, he publicado el resultado final en Github. En mi equipo hemos estado utilizando esta configuración los últimos 3 meses sin problemas, estamos contentos con los resultados. Gracias por leerme.\n","summary":"En mi trabajo actual, me ha tocado configurar un monorepo con hooks de git, ESLint, Prettier y algunas acciones propias."},{"url":"/blog/resumen-de-2021/","title":"Resumen de 2021","content":"Nunca he hecho esto antes, pero pienso que tener mi propio blog es una buena oportunidad para empezar a revisar el año, tanto a modo personal como profesional.\nHitos personales Retomando el ejercicio Después de más de 1 año sin practicar ejercicio, volví a la piscina. Una vez mi familia se vacunó, empecé a ir de nuevo a la piscina a nadar. Tenía distintos tipos de dolores en mi cuerpo, 2020 fué un año duro que me provocó mucho estrés debido al trabajo y algunas situaciones personales.\nComencé yendo una o 2 veces por semana, y he terminado el año con 3 sesiones semanales. ¡Estoy muy contento de haberlo retomado.!\nPerfeccionando mi inglés Este es un objetivo pendiente desde hace algunos años, siempre he podido escribir y leer inglés sin grandes problemas, pero escuchar y especialmente hablar han sido mis asignaturas pendientes. Pienso que es algo que se puede practicar así que decidí comenzar con clases de conversación una vez a la semana,\nAdemás, comencé a ver series en versión original con subtítulos. Me he visto las 10 temporadas de Friends, y he comenzado con Downtown Abbey. No sé si algún día seré capaz de ver series sin echar una ojeada a los subtítulos, pero se intentará.\nHe usado una herramienta muy buena para comprobar mis artículos, emails, etc: LanguageTool, pagué suscripción premium por 1 año y estoy encantado. También dispone de versión gratuita.\nCambio en mi carrera profesional Después de casi 4 años trabajando en Renta 4 banco, comencé a buscar una nueva oportunidad laboral. Antes de llegar a Renta 4 siempre había trabajado en consultoría, y esta era mi primera oportunidad de trabajar en un cliente final. No suelo lamentar mis decisiones, y con la información que disponía parecía una buena oportunidad.\nAl cabo de 2 años me dí cuenta de que estaba atrapado en un sitio con tecnología antigua y sin ninguna perspectiva de evolución. Estuve apunto de cambiar de trabajo en Marzo de 2019, tuve una oportunidad muy apetecible, pero justo entonces comenzó la pandemia y todo se pospuso. Unos meses después me contactaron, pero por aquel entonces prefería no moverme durante un tiempo.\nPensaba que trabajar en un cliente final era el paso adecuado, una posición estable con un salario en constante evolución. La realidad es que me dí cuenta de que pasamos mucho tiempo de nuestra vida trabajando, así que es crucial estar feliz con lo que tienes que hacer en el día a día.\nEn estos momentos para mí tener la posibilidad de teletrabajar, organizarme mi propio horario y ser capaz de pasar todo el tiempo posible con mi hijo es la prioridad.\nFinalmente comencé en Cognizant como Frontend Developer, creo que es una gran oportunidad de aprender, trabajar en equipo en proyectos internacionales y mejorar mi inglés. En estos momentos trabajo 100% en remoto y en el futuro iré un par de mañanas a la oficina.\nVacuna Covid-19 Me vacuné con Pfizer 💉💉. Todos estamos hartos de esta pandemia, hay un montón de información y en ocasiones dudamos de si esto acabará algún día. En estos momentos estoy a la espera de mi tercera dosis, está siendo difícil escapar de la variante Omicron.\nResumen de las skill profesionales Comencé 2021 con el objetivo de aprender Vue 3. Creé un proyecto personal inventado, financial-bank. No lo terminé pero aprendí un montón de cosas, jugué con Tailwind, Vue y Typescript. Está aún en la rama develop, si en el futuro tengo ocasión, hay algunas cosas en mi cabeza que me gustaría aplicar.\nEn los últimos 3 meses he estado aprendiendo React. React es uno de los más populares frameworks, mucha gente lo usa y hay muchísimas librerías y artículos sobre ello. Pronto pasará a ser la librería más popular cuando jQuery abandone el primer puesto.\nNo conocía prácticamente nada de React, intento no volverme loco aprendiendo constantemente nuevos frameworks y librerías. Sabiendo Angular y Vue no tenía necesidad de aprender React, pero me asignaron a un proyecto con React y aquí estoy, con experiencia en los 3 grandes frameworks.\nCreé algunos repositorios en Github (216 contribuciones el año pasado), escribí 6 artículos en este blog. Además, creé mi propio theme para VSCode llamado Oceanic Wind, me encanta deberías probarlo.\nObjetivos para 2022 Estos son mis objetivos para 2022:\nHacer más ejercicio y tratar de ganar un poco de músculo (espero que me ayudé con algunos dolores crónicos que tengo). Estoy cambiando mi dieta con 8fit y ejercitándome algunas veces en casa.\nMejorar mi técnica en natación con diferentes entrenamientos. Me compré un Garmin Swim 2 para monitorizar mis sesiones. Continuar nadando 3 veces a la semana es mi objetivo.\nLeer más, tanto en inglés como en castellano. Ojalá pueda leer un par de horas a la semana.\nObtener el certificado C1 en inglés.\nConvertirme en fullstack developer de Javascript.\nPublicar más artículos en el blog.\n💪🏻💪🏻\n","summary":"Nunca he hecho esto antes, pero pienso que tener mi propio blog es una buena oportunidad para empezar a revisar el año, tanto a modo personal como profesional."},{"url":"/blog/restaurar-grub-despu%C3%A9s-de-instalar-windows/","title":"Restaurar grub después de instalar Windows","content":"En este artículo, vamos a ver como podemos restaurar grub después de instalar Windows. Tenía Windows 7 aún en mi portátil junto con Ubuntu, asi que después de mucho tiempo posponiéndolo, finalmente me he decidido a actualizar a Windows 10. Lo más recomendable al instalar un ordenador, es instalar Windows y después Linux. De esta manera, Linux se preocupará de dejar grub listo para posibilitar el arranque dual.\nSi por cualquier motivo tienes que instalar Windows después de Linux, Windows eliminará grub, pondrá por defecto que cargue Windows y será necesario restaurar grub. A continuación la opción más sencilla para recuperar grub.\nBoot repair al rescate Boot repair disk es una herramienta de rescate que permite de una manera muy sencilla restaurar grub. Tan sólo hay que descargar la iso y crear un USB con ella, por ejemplo con Rufus. Reinicia el sistema y asegurate de que la opción USB está al principio de la lista de dispositivos de arranque en la BIOS.\nUna vez Boot repair se haya cargado, puedes conectarte a internet para descargar la última versión, hacer click en la opción \u0026ldquo;Recommended repair\u0026rdquo; y reiniciar.\n¡Y eso es todo! Al reiniciar, deberías ver la pantalla para seleccionar el sistema operativo que quieras cargar.\n","summary":"En este artículo, vamos a ver como podemos restaurar grub después de instalar Windows."},{"url":"/blog/integrar-stylelint-en-un-proyecto-con-vue/","title":"Integrar stylelint en un proyecto con Vue","content":"Stylelint es a CSS el equivalente a ESLint para Javascript. Hasta hoy, estaba utilizando las validaciones que provee VSCode por defecto en CSS, pero si queremos ir un paso más allá a la hora de prevenir errores y tener una mejor consistencia en el estilo, un linter para CSS es la mejor opción.\nDependencias Veamos como podemos configurar Stylelint para tener validaciones y desactivar las advertencias por defecto del validador de VSCode.\nEl primer paso será añadir algunas dependencias a nuestro proyecto:\nstylelint: El linter. stylelint-config-standard: Configuración base. También podemos proporcionar nuestra configuración desde cero o elegir otra opción de base como stylelint-config-recommended. stylelint-config-recommended-vue: Configuración base para Vue, añade soporte para algunos selectores CSS de Vue como por ejemplo ::v-slotted. Además añade automáticamente un override para archivos .vue utilizando postcss-html como sintáxis personalizada. postcss-html: Dependencia necesaria para validar CSS en ficheros .vue. Por lo tanto, las instalamos:\nnpm install stylelint stylelint-config-standard stylelint-config-recommended-vue postcss-html --save-dev Stylelint en VSCode El siguiente paso es instalar la extensión oficial de Stylelint para VSCode.\nAñadiremos algunas entradas a las settings de nuestro workspace en VSCode (o globalmente) para poder deshabilitar el lint por defecto de VSCode. Si estamos utilizando Vetur, también necesitaremos deshabilitar las validaciones de estilo en la extensión.\nAdemás, desde la versión 14 de Stylelint, es necesario especificar los diferentes estilos de lenguaje que van a ser validados, en nuestro caso vue.\nAdicionalmente, tengo fixAll que se ejecuta automáticamente al guardar un archivo.\n{ \u0026#34;css.validate\u0026#34;: false, // Disable built-in lint \u0026#34;less.validate\u0026#34;: false, // Disable built-in lint \u0026#34;scss.validate\u0026#34;: false, // Disable built-in lint \u0026#34;stylelint.enable\u0026#34;: true, // Enable stylelint \u0026#34;stylelint.validate\u0026#34;: [\u0026#34;css\u0026#34;, \u0026#34;less\u0026#34;, \u0026#34;postcss\u0026#34;, \u0026#34;vue\u0026#34;], // Add vue files \u0026#34;vetur.validation.style\u0026#34;: false, // Disable vetur style validation \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.fixAll.stylelint\u0026#34;: true }, } Fichero de configuración Stylelint Por último pero no menos importante, debemos crear un fichero de configuración en la raíz de nuestro proyecto..stylelintrc:\n{ \u0026#34;extends\u0026#34;: [ \u0026#34;stylelint-config-standard\u0026#34;, \u0026#34;stylelint-config-recommended-vue\u0026#34; ], \u0026#34;rules\u0026#34;: { } } En caso de no extender stylelint-config-recommended-vue, tendremos que añadir manualmente el override para validar archivos vue:\n{ \u0026#34;extends\u0026#34;: [ \u0026#34;stylelint-config-standard\u0026#34;, \u0026#34;stylelint-config-recommended-vue\u0026#34; ], \u0026#34;overrides\u0026#34;: [ { \u0026#34;files\u0026#34;: [ \u0026#34;**/*.vue\u0026#34; ], \u0026#34;customSyntax\u0026#34;: \u0026#34;postcss-html\u0026#34; } ], \u0026#34;rules\u0026#34;: { } } Con todas estas configuraciones, nuestro proyecto está listo para comenzar a utilizar Stylelint para linting de CSS.\nAñadiendo nuestras propias reglas Podemos especificar reglas personalizadas. Por ejemplo, en un proyecto en el que estemos utilizando Tailwind CSS, podemos evitar el siguiente warning al utilizar @apply: Unknown at rule @applycss(unknownAtRules). Esto es clave si queremos trabajar con plugins de PostCSS y evitar mensajes de advertencia. Ejemplo para Tailwind CSS:\n{ \u0026#34;extends\u0026#34;: [ \u0026#34;stylelint-config-standard\u0026#34;, \u0026#34;stylelint-config-recommended-vue\u0026#34; ], \u0026#34;rules\u0026#34;: { \u0026#34;at-rule-no-unknown\u0026#34;: [ true, { \u0026#34;ignoreAtRules\u0026#34;: [ \u0026#34;tailwind\u0026#34;, \u0026#34;apply\u0026#34;, \u0026#34;variants\u0026#34;, \u0026#34;responsive\u0026#34;, \u0026#34;screen\u0026#34; ] } ], \u0026#34;block-no-empty\u0026#34;: null, \u0026#34;declaration-block-trailing-semicolon\u0026#34;: null, \u0026#34;no-descending-specificity\u0026#34;: null } } Enlaces de interés:\nStylelint stylelint-config-recommended-vue PostCSS HTML Syntax ","summary":"Stylelint es a CSS el equivalente a ESLint para Javascript. Hasta hoy, estaba utilizando las validaciones que provee VSCode por defecto en CSS, pero si queremos ir un paso más allá a la hora de prevenir errores y tener una mejor consistencia en el estilo, un linter para CSS es la mejor opción."},{"url":"/blog/oceanic-wind-para-vscode/","title":"Oceanic Wind para VSCode","content":" He creado un theme oscuro para VSCode llamado Oceanic Wind, pero, ¿por qué? Bueno, he estado usando el tema Oceanic Next durante años, la primera vez que lo utilicé fue con Sublime Text, y quería modificarlo.\nEstá basado en las combinaciones de color de Oceanic Next pero reemplazando y personalizando con la paleta de colores de Tailwind CSS.\nSoy una persona que necesita tiempo para adaptarse a los cambios, y, desde que cambié a VSCode no había demasiados temas basados en Oceanic Next (ahora parece que hay bastantes más). Sentía que el que estaba usando no me terminaba de convencer asi que pensé que crear un tema basado en esos colores pero con buen contraste podría ser divertido.\nCuando empecé a crear el tema no sabía que existían tantas posibilidades y colores para personalizar VSCode. Decidí que personalizaría cada color que pudiera encontrar, en la mayoría de los casos simplemente reemplazaba el color por defecto de VSCode por uno de la paleta de Tailwind.\nCreando tu propio theme Si quieres crear tu propio tema puedes seguir los pasos de la guía oficial de Visual Studio Code. Esto es lo que hice:\nPrimero, instalar la extensión para Yeoman para generar extensiones de VSCode, y ejecutarla:\nnpm install -g yo generator-code yo code Selecciona New color theme y No, start fresh. Rellena los campos que te pide como nombre e identificador, y selecciona un punto de partida para crear tu theme, en mi caso Dark theme. Ya puedes abrir el directorio con VSCode:\ncd your-theme code . Para probar el tema, simplemente pulsa F5 y se abrirá una nueva ventana en la que puedes ver el resultado.\nLa documentación oficial es la perfecta guía de referencia. Como podrás comprobar, hay montones de colores disponibles, en ocasiones encontrar el color al que se refieren puede ser difícil a pesar de la descripción. Hay unos cuantos que no pude encontrar.\nEncontrando colores Pulsa Ctrl + Shift + P y teclea Inspect Editor Tokens and Scopes. Ahora puedes pulsar en cualquier parte del código y aparecerá un pop-up donde aparece información útil como tipo de fuente y scope de la regla seleccionada. También puedes consultar el ratio de contraste del color, yo siempre intento obtener 4.5 como mínimo.\nVSCode dispone de developer tools que puedes utilizar para inspeccionar elementos. Pulsa Ctrl + Shift + P y teclea Toggle Developer Tools para abrirlas.\nMuy útil si quieres obtener rápidamente un color de algún tema que estás consultando para obtener inspiración. Al comenzar a crear el tema éste era el método que utilizaba para obtener el color por defecto de cualquier cosa en VSCode, pero hay algunos elementos que son difíciles de inspeccionar como el mini mapa.\nFinalmente, opté por buscar los colores por defecto en el repositorio de VSCode en Github. Simplemente busca el color que quieras en el buscador (sin poner el punto), por ejemplo activityBar inactiveForeground, e indaga entre los distintos resultados hasta obtener el color que usan.\nHe creado un gist con todos los colores oscuros por defecto en VSCode, algunos valores no son 100% exactos ya que en el código fuente se ve que usan las funciones darken o lighten, o también pueden aplicar transparencia a un color que ya tenía transparencia. Te ahorrará mucho tiempo, no encontré en un ningún sitio un listado con los colores por defecto utilizados.\nColor de acento Se pueden sobrescribir colores para un tema en las settings de VSCode. He creado differentes esquemas de colores para cambiar el color de acento en VSCode. Si alguien desea probar con otro color en lugar del azul por defecto, puede utilizar estas combinaciones:\nIndigo Green Rose Teal Fuchsia Amber Esmerald Sky He realizado pruebas de contraste de color para los distintos esquemas, no debería haber ningún gran problema de contraste. Tengo pendiente revisarlo porque no he comprobado con las versiones Warm y Cool del tema.\nCreando a partir de una paleta de colores definida Una vez terminé el tema, podía fácilmente generar numerosas variantes. Simplemente reemplazando el gris con los 5 distintos tipos de gris de Tailwind, podría generar 40 distintas variantes (8 colores de acento x 5 tipos de gris = 40). Esto es solo una posibilidad, decidí utilizar el gris neutro para la versión por defecto, el gris cálido para la versión cálida y el gris azul para la fría.\nHe querido evitar ensuciar el selector de themes de VSCode con más de 40 distintas versiones, había que elegir asi que finalmente dejé 3 versiones con el azul como color de acento, y si alguien desea personalizar más puede copiar y pegar la configuración de los distintos colores de acento. ¡Es tan fácil generar variantes cuando dispones de una paleta de colores!\nTesteando La forma por defecto de testear un theme puede resultar insuficiente en algunos casos. Para ello puedes utilizar un truco: Copia tu directorio con todos los archivos de la extensión en el directorio .vscode. Por ejemplo en Windows:\nC:\\Users\\your-user\\.vscode De esta forma puedes activar localmente tu tema y probarlo en el workspace que desees.\nPuedes hacer cambios directamente en el directorio del tema, pero necesitarás reiniciar la instancia de VSCode para poder ver los cambios (puedes pulsar Ctrl + Shift + P y escribir Reload window).\nAdemás puedes modificar las settings de usuario, y sobrescribir los colores de tu tema para poder ver en caliente los cambios realizados. ¡Esto ahorra mucho tiempo!\nConclusión Cuando termines puedes seguir la guía oficial para publicar tu theme.\nHe basado y probado este tema en mi workflow diario, con HTML, CSS, Javascript, Typescript y desarrollando con los principales frameworks, Angular, Vue y React. Adicionalmente he probado con los ficheros que se pueden encontrar en el directorio demo (gracias a Wes Bos y Sarah Drasner).\nSi encuentras algo raro, tienes una sugerencia o mejora, por favor siéntete libre de abrir una issue. Estoy seguro de que me he dejado alguna cosa.\nNo soy diseñador así que cualquier feedback recibido sería genial.\nOceanic Wind en Marketplace Repositorio Github Colores oscuros por defecto en VSCode ","summary":"He creado un theme oscuro para VSCode llamado Oceanic Wind, pero, ¿por qué?"},{"url":"/blog/configurando-standardjs/","title":"Configurando StandardJS","content":"En este post vamos a ver como configurar StandardJS en VSCode para poder corregir todos los errores al guardar un archivo automáticamente.\n¿Qué es StandardJS? A simple vista podría parecer que es el estándar a la hora de escribir código Javascript, y esa es la intención de StandardJS, proporcionar una guía de estilos, linter y formateador para código Javascript. En realidad no lo es, el ecosistema Javascript ya sabemos cómo es y para gustos los colores. La idea es buena, lo instalas y te despreocupas de definir reglas, siempre y cuando te guste lo que trae. Yo había oído hablar de él pero nunca lo había probado.\nPersonalmente soy un poco maniático con algunas cosas y estoy acostumbrado a utilizar Prettier como formateador, pero todo es acostumbrarse. Las ventajas son:\nEvitar configuración de estilo. Formateado automático del código con standard --fix. Identifica errores de estilo y programación en el código. StandardJS utiliza una configuración de reglas fijas definidas con ESLint.\nInstalar y configurar StandardJS El primer paso será como no, instalar el paquete. Lo puedes hacer de manera global o local para un proyecto, yo siempre que puedo elijo esta última opción, para poder tener las dependencias controladas y no depender de un paquete global.\nnpm install standard --save-dev En cualquier momento puedes solucionar automáticamente los problemas que encuentre (los que se puedan arreglar automáticamente) con:\nstandard --fix Puedes crearte un script npm para ejecutarlo automáticamente, pero la opción más cómoda es integrarlo en el editor.\nFormateo automático en VSCode He utilizado StandardJS por primera vez en un proyecto de un compañero, y de primeras me volví loco. Tengo configurado Prettier como formateador por defecto, y me encontraba constantemente distintos formatos al guardar, pues Prettier formateaba violando reglas de StandardJS.\nLe pregunte a mi compañero que como formateaba el código al guardar un fichero, y me dijo que no lo hacía, simplemente al detectar un error le da a la bombilla y seleccionaba Fix all. Este tipo de tareas manuales no van conmigo, asi que investigué como formatear cada vez que se guarda un archivo en VSCode y a continuación describo la solución.\nEn primer lugar, instalaremos la extensión de StandardJS para VSCode. Como StandardJS utiliza ESLint, instalaremos la extensión de ESLint también.\nEn mi caso, como suelo utilizar Prettier lo más recomendable es desactivar el formateador en lenguaje Javascript en el workspace del proyecto. También a nivel de workspace, utilizaremos la siguiente configuración, que aparece en la documentación de la extensión para formateo y resolución automática de problemas, pero a la que he tenido que añadir las líneas que aparecen remarcadas, porque sino no me funcionaba.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \u0026#34;standard.enable\u0026#34;: true, \u0026#34;standard.run\u0026#34;: \u0026#34;onSave\u0026#34;, \u0026#34;standard.autoFixOnSave\u0026#34;: true, \u0026#34;standard.validate\u0026#34;: [ \u0026#34;javascript\u0026#34;, \u0026#34;javascriptreact\u0026#34;, \u0026#34;typescript\u0026#34;, \u0026#34;typescriptreact\u0026#34; ], \u0026#34;javascript.validate.enable\u0026#34;: false, \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.fixAll.eslint\u0026#34;: true }, \u0026#34;[javascript]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: null } } Para probar que todo funciona, vamos a un fichero Javascript y comprobamos que al guardar desaparecen todos los errores que marcaba StandardJS. Eso es todo, por mi parte prefiero Prettier a la hora de formatear, ya que puedo usarlo también para HTML y CSS, y aplicar reglas directamente con ESLint.\n","summary":"En este post vamos a ver como configurar StandardJS en VSCode para poder corregir todos los errores al guardar un archivo automáticamente."},{"url":"/blog/vue-3-con-typescript-eslint-y-prettier/","title":"Vue 3 con Typescript, ESLint y Prettier","content":"A principios de este año comencé a aprender Vue 3, ya había trabajado con la versión 2 y la verdad es que esta nueva versión te permite seguir utilizando la misma sintaxis, además de incorporar la nueva Composition API, mucho más potente y personalizable a la hora de crear elementos reutilizables. En este artículo voy a escribir sobre cómo crear un nuevo proyecto con Vue 3 + Typescript, y configurar ESLint y Prettier para que funcionen correctamente en Visual Studio Code.\nVue CLI Para crear un nuevo proyecto la opción más rápida y sencilla es utilizar Vue CLI. Nos permitirá configurar nuestro proyecto con diferentes workflows predefinidos. El primer paso es instalar Vue CLI:\nyarn global add @vue/cli # OR npm install -g @vue/cli Y una vez instalado ya podemos crear un nuevo proyecto:\nvue create hello-world Nos saldrá un listado de opciones donde seleccionaremos la última opción:\nVue CLI v4.5.13 ? Please pick a preset: (Use arrow keys) Default ([Vue 2] babel, eslint) Default (Vue 3) ([Vue 3] babel, eslint) \u003e Manually select features Y podremos configurar nuestro proyecto con las opciones que aparecen. Yo elegí estas, no marco testing para no desviarme del tema:\nVue CLI v4.5.13 ? Please pick a preset: Manually select features ? Check the features needed for your project: (*) Choose Vue version (*) Babel (*) TypeScript ( ) Progressive Web App (PWA) Support \u003e(*) Router ( ) Vuex ( ) CSS Pre-processors (*) Linter / Formatter ( ) Unit Testing ( ) E2E Testing A continuación nos irá preguntando más cosas, elegimos versión 3 y al final ESLint + Prettier.\nVue CLI v4.5.13 ? Please pick a preset: Manually select features ? Check the features needed for your project: Choose Vue version, Babel, TS, Router, Linter ? Choose a version of Vue.js that you want to start the project with 3.x ? Use class-style component syntax? No ? Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? Yes ? Use history mode for router? (Requires proper server setup for index fallback in production) Yes ? Pick a linter / formatter config: ESLint with error prevention only ESLint + Airbnb config ESLint + Standard config \u003e ESLint + Prettier TSLint (deprecated) Después de responder a todo lo que nos pregunta comenzará a instalar las dependencias. Una vez finalizado, podremos ejecutar npm run serve para que se lance en modo desarrollo nuestra nueva aplicación.\nESLint + Prettier El equipo de Vue ha hecho un buen trabajo a la hora de evitarnos los quebraderos de cabeza de configurar ESLint y Prettier de manera que no haya conflicto entre ellos. Si abrimos el fichero .eslintrc.js vemos que tenemos instalados estos plugins:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 module.exports = { root: true, env: { node: true, }, extends: [ \u0026#34;plugin:vue/vue3-essential\u0026#34;, \u0026#34;eslint:recommended\u0026#34;, \u0026#34;@vue/typescript/recommended\u0026#34;, \u0026#34;@vue/prettier\u0026#34;, \u0026#34;@vue/prettier/@typescript-eslint\u0026#34;, ], parserOptions: { ecmaVersion: 2020, }, rules: { \u0026#34;no-console\u0026#34;: process.env.NODE_ENV === \u0026#34;production\u0026#34; ? \u0026#34;warn\u0026#34; : \u0026#34;off\u0026#34;, \u0026#34;no-debugger\u0026#34;: process.env.NODE_ENV === \u0026#34;production\u0026#34; ? \u0026#34;warn\u0026#34; : \u0026#34;off\u0026#34;, \u0026#34;arrow-parens\u0026#34;: \u0026#34;off\u0026#34;, \u0026#34;eol-last\u0026#34;: \u0026#34;error\u0026#34;, }, overrides: [ { files: [ \u0026#34;**/__tests__/*.{j,t}s?(x)\u0026#34;, \u0026#34;**/tests/unit/**/*.spec.{j,t}s?(x)\u0026#34;, ], env: { jest: true, }, }, ], }; De esta manera Prettier no entrará en conflicto con las reglas de ESLint. En las líneas 19-20 hay unas reglas que he añadido yo. Se puede añadir todo lo que deseemos para personalizarlo a nuestro gusto.\nVSCode Como último paso, vamos a ver lo que tenemos que configurar para que todo funcione correctamente en VSCode. Lo más importante es tener instalada la extensión Vetur, que mejora la experiencia a la hora de desarrollar con Vue en VSCode, y permite que podamos disfrutar de autoformateo de código en los Single File Components, es decir los ficheros con extensión .vue.\nUna vez instalado, iremos a la configuración de Vetur, y en la sección de Format -\u0026gt; Default Formatter podremos elegir con qué queremos que se formatee nuestro HTML, CSS, JS, Sass, Typescript, etc. Es muy importante que en JS tengamos marcado prettier-eslint, en el resto yo tengo la opción por defecto, incluso en Typescript tengo solo Prettier, ya que prettier-tslint es una opción que está en desuso.\nEn la configuración de VSCode tenemos que decir que los ficheros de tipo Vue utilicen como formateador por defecto Vetur:\n\u0026#34;[vue]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;octref.vetur\u0026#34; } De esta manera VSCode delega en Vetur, y es Vetur el que a cada parte que encuentre en los ficheros .vue aplicará el formateador adecuado. Tan solo hay una cosa que Vetur no hace correctamente en el autoformateo de los ficheros .vue, y es el insertar una línea en blanco al final del archivo. Si tienes esta opción, la única forma que he encontrado es delegar esa tarea en VSCode mediante esta configuración:\n\u0026#34;files.insertFinalNewline\u0026#34;: false En ocasiones tener la última versión de Vetur puede ser problemático, recientemente en un proyecto me he encontrado que Vetur comenzaba a formatear el HTML de manera distinta. Después de unas horas volviéndome loco, instalé una versión anterior de Vetur y todo volvió a funcionar correctamente. He reportado el bug y he aprovechado a comentar lo de la línea en blanco al final del archivo, aún estoy a la espera de la respuesta. Quizás sea un error mío, pero he pasado muchas horas dándole vueltas y de ser así no he sido capaz de encontrarlo.\nCon estos pasos ya estamos listos para comenzar nuestros proyectos con Vue 3 + Typescript + ESLint + Prettier en VSCode.\n","summary":"A principios de este año comencé a aprender Vue 3, ya había trabajado con la versión 2 y la verdad es que esta nueva versión te permite seguir utilizando la misma sintaxis, además de incorporar la nueva Composition API, mucho más potente y personalizable a la hora de crear elementos reutilizables."},{"url":"/blog/im%C3%A1genes-responsive-en-hugo/","title":"Imágenes responsive en Hugo","content":"En este post voy a compartir un shortcode muy útil que nos permitirá procesar automáticamente las imágenes con Hugo. Antes de nada debemos asegurarnos de que nuestro contenido se encuentra estructurado con Hugo´s page bundles. Al crear este blog, lo migré de un Wordpress y todos los artículos estaban estructurados de la siguiente manera:\nresponsive-images-hugo - responsive-images-hugo.md using-tailwindcss-with-angular - using-tailwindcss-with-angular.md Y todas las imágenes se encontraban en el directorio /static. Con esa estructura Hugo no reconocerá nuestro contenido como un bundle, así que tuve que reorganizar todos los posts. A continuación un resumen muy breve de los bundles en Hugo:\nLos archivos _index.md son considerados índices de una sección y se utilizará el template list.html para ellos. Los archivos index.md (o index.en.md, index.es.md) se consideran índices de una página/post y se utilizará el template single.html. Después de estos cambios la estructura queda así:\nresponsive-images-hugo - index.md - index.en.md img - img1.jpg - ... El siguiente paso es crear un archivo para el shortcode, yo lo creé en layouts/shortcodes/img.html con el siguiente código:\n{{/* Get file that matches the filename as specified as src=\u0026#34;\u0026#34; in shortcode */}} {{ $src := .Page.Resources.GetMatch (printf \u0026#34;*%s*\u0026#34; (.Get \u0026#34;src\u0026#34;)) }} {{/* Set image sizes, these are hardcoded for now, x dictates that images are resized to this width */}} {{ $tinyw := default \u0026#34;500x\u0026#34; }} {{ $smallw := default \u0026#34;800x\u0026#34; }} {{ $mediumw := default \u0026#34;1200x\u0026#34; }} {{ $largew := default \u0026#34;1500x\u0026#34; }} {{/* Initialize variables */}} {{ $tiny := \u0026#34;\u0026#34; }} {{ $small := \u0026#34;\u0026#34; }} {{ $medium := \u0026#34;\u0026#34; }} {{ $large := \u0026#34;\u0026#34; }} {{/* Resize the src image to the given sizes if necessary */}} {{ if ge $src.Width \u0026#34;500\u0026#34; }} {{ $tiny = $src.Resize $tinyw }} {{ end }} {{ if ge $src.Width \u0026#34;800\u0026#34; }} {{ $small = $src.Resize $smallw }} {{ end }} {{ if ge $src.Width \u0026#34;1200\u0026#34; }} {{ $medium = $src.Resize $mediumw }} {{ end }} {{ if ge $src.Width \u0026#34;1500\u0026#34; }} {{ $large := $src.Resize $largew }} {{ end }} \u0026lt;img class=\u0026#39;mb-6 {{ with .Get \u0026#34;class\u0026#34; }}{{.}}{{ end }}\u0026#39; srcset=\u0026#39; {{ with $src.RelPermalink }}{{.}} {{$src.Width}}w{{ end }} {{ if ge $src.Width \u0026#34;500\u0026#34; }} {{ with $tiny.RelPermalink }},{{.}} 500w{{ end }} {{ end }} {{ if ge $src.Width \u0026#34;800\u0026#34; }} {{ with $small.RelPermalink }}, {{.}} 800w{{ end }} {{ end }} {{ if ge $src.Width \u0026#34;1200\u0026#34; }} {{ with $medium.RelPermalink }}, {{.}} 1200w{{ end }} {{ end }} {{ if ge $src.Width \u0026#34;1500\u0026#34; }} {{ with $large.RelPermalink }}, {{.}} 1500w {{ end }} {{ end }}\u0026#39; src=\u0026#34;{{ $src.RelPermalink }}\u0026#34; width=\u0026#34;{{ $src.Width }}\u0026#34; height=\u0026#34;{{ $src.Height }}\u0026#34; {{ with .Get \u0026#34;alt\u0026#34; }}alt=\u0026#39;{{.}}\u0026#39;{{ end }}\u0026gt; De esta manera seremos capaces de usar en los archivos markdown para los artículos el shortcode:\n{{\u0026lt; img src=\u0026#34;img/img1.jpg\u0026#34; alt=\u0026#34;Description for image\u0026#34; \u0026gt;}} Y eso es todo, usas la imagen como si estuvieras en html y gracias al shortcode y Hugo se generarán imágenes más pequeñas cuando sea necesario. El crédito de esta solución es de Laura Kalbag, yo simplemente modifiqué un poco su código. Aprovecho para recomendar su libro Accessibility For Everyone, es una buena introducción para accesibilidad.\n","summary":"En este post voy a compartir un shortcode muy útil que nos permitirá procesar automáticamente las imágenes con Hugo."},{"url":"/blog/buscar-en-hugo-con-lunr/","title":"Buscar en Hugo con Lunr","content":"¿Cómo implementar un buscador con Hugo? Mi primer impulso fue buscar en la documentación oficial, donde encontré una serie de links y guías que me permitieron orientarme un poco, pero no terminaba de convencerme ninguna. Asi que en esta guía voy a detallar cual es la solución que he desarrollado.\nEn los distintos sitios que encontré guías básicamente las posibilidades eran 2:\nAlgolia: Es un servicio que se encarga de rastrear todas las páginas de un sitio web. De esa manera es capaz de proveer una API que podremos utilizar para realizar búsquedas en nuestra web. Tiene la ventaja de que al ser un servicio de un tercero, facilita la integración en sitios estáticos pues basta con llamar a la API desde el front. Es una opción muy válida y utilizada en multitud de sitios, pero en mi caso prefería decantarme por una opción sin depender de servicios de terceros. Lunr: Lunr es una librería Javascript que permite realizar búsquedas en ficheros con formato JSON. Ofrece una interfaz sencilla pero potente para hacer búsquedas en cliente. Permite realizar fuzzy search, que es un algoritmo que permite devolver los resultados más relevantes para una búsqueda a pesar de que el término introducido no coincida exactamente. Esta opción es la que he elegido e implementado en este blog. Definiendo la salida de nuestro contenido en formato JSON Con Lunr como librería Javascript para realizar fuzzy search tan solo nos falta la otra parte para completar nuestro buscador: un fichero JSON con el contenido de todos los posts del blog. Para ello podemos definirlo en 2 sitios distintos:\nEn el fichero de configuración global de Hugo, config.toml en mi caso. Si no definimos nada, por defecto todo el contenido estará disponible en formato HTML y RSS. En mi caso, tengo todos los artículos del blog en lo que se define en Hugo como una section, concretamente en la carpeta content/blog. Por tanto podría definir de manera global que todas las secciones del sitio también tuvieran como formato de salida JSON de la siguiente manera: [outputs] section = [\u0026#34;JSON\u0026#34;, \u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] De esta manera tendríamos un fichero JSON por cada section. Si además de blog como es en mi caso, tuviéramos otra sección (cursos), cada una dispondría de su propio fichero index.json con el contenido propio de cada sección, lo que nos permitiría poder realizar búsquedas independientes por cada sección. ¿Cómo indico el contenido y formato de ese fichero JSON? En este caso al igual que disponemos de un template HTML llamado list.html para mostrar el listado de contenidos de una sección, crearemos un fichero list.json para generar el JSON.\nSi queremos que sean distintos por cada sección, dentro de la carpeta layouts y siguiendo con el ejemplo de este sitio, en una carpeta blog crearíamos un fichero list.json y en la carpeta cursos crearíamos otro list.json con contenido distinto. Si el formato del fichero JSON va a ser el mismo para cada sección, podemos crear el fichero list.json dentro de la carpeta _default, y valdría para todas las secciones (siempre que la sección no contenga un fichero list.json, en cuyo caso prevalecería este último al de _default).\nVeamos el contenido del fichero list.json, que simplemente genera usando sintaxis de Hugo un array de posts.\n[ {{ range $index, $value := where .Site.Pages \u0026#34;Type\u0026#34; \u0026#34;post\u0026#34; }} {{ if $index }}, {{ end }} { \u0026#34;url\u0026#34;: \u0026#34;{{ .RelPermalink }}\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;{{ .Title }}\u0026#34;, \u0026#34;content\u0026#34;: {{ .Content | plainify | jsonify }}, \u0026#34;summary\u0026#34;: \u0026#34;{{.Summary}}\u0026#34; } {{ end }} ] El contenido es personalizable, y el nombre de cada campo también. Yo por el momento al tener un número reducido de artículos, tengo el contenido de cada uno en un campo content, pero a futuro con un número grande de artículos por temas de rendimiento sería conveniente reducir el tamaño del fichero JSON quizás dejando solo el título y el sumario.\nSe puede activar para cada section el formato de salida desde el front matter. En mi caso, en content/blog tengo un fichero _index.md e _index.en.md para el idioma inglés. Desde ahí puedo activar también el formato JSON de la siguiente manera: --- title: Blog personal subtitle: Artículos escritos sobre temática variada relacionada con el mundo de la tecnología y la programación. outputs: - html - rss - json --- La parte del template list.json es exactamente igual que en el punto anterior. Puedes leer en la documentación de Hugo acerca de la personalización de formato de salida del contenido.\nImplementando el buscador usando lunr con Javascript Una vez tenemos la fuente de datos contra la cual vamos a realizar las búsquedas, veamos el código que nos va a permitir terminar la implementación del buscador. Yo he decidido poner el buscador simplemente en una página, por lo que en layouts/page he creado un fichero search.html. Analicemos parte por parte y simplificando su contenido. Lo primero es el código html que consta de un input para recoger el término de búsqueda y un elemento section donde mostraremos los resultados de la búsqueda.\n\u0026lt;label for=\u0026#34;search-input\u0026#34;\u0026gt;Término de búsqueda\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;search-input\u0026#34; name=\u0026#34;search\u0026#34; placeholder=\u0026#34;{{i18n \u0026#34;search_loading\u0026#34;}}...\u0026#34;\u0026gt; \u0026lt;section id=\u0026#34;search-results\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; En el mismo fichero html se encuentra el código Javascript, ya que no es muy largo y podemos crear variables dinámicas en Javascript con Hugo para obtener los literales multi idioma y la ruta relativa al index.json para cada lenguaje.\nImportamos Lunr, yo lo tengo en la carpeta static/js/:\n{{ $lunr := \u0026#34;js/lunr.min.js\u0026#34; | absURL }} \u0026lt;script src=\u0026#34;{{ $lunr }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; También podría importarse desde CDN:\n\u0026lt;script src=\u0026#34;https://unpkg.com/lunr/lunr.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; A continuación, el código javascript que al cargar la página hace una petición para cargar el fichero index.json y crea el documento indexado que posteriormente se utilizará para devolver los resultados de la búsqueda. Las búsquedas se van lanzando según el usuario va escribiendo en el input.\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; (function () { let idx; let documents = []; const URL_LIST_POSTS = \u0026#39;{{ \u0026#34;blog/index.json\u0026#34; | relLangURL }}\u0026#39;; const searchInput = document.getElementById(\u0026#34;search-input\u0026#34;); const searchResults = document.getElementById(\u0026#34;search-results\u0026#34;); // Request and index documents fetch(URL_LIST_POSTS, { method: \u0026#34;get\u0026#34;, }) .then((res) =\u0026gt; res.json()) .then((res) =\u0026gt; { // Create index document with lunr idx = lunr(function () { this.ref(\u0026#34;url\u0026#34;); this.field(\u0026#34;title\u0026#34;); this.field(\u0026#34;content\u0026#34;); this.field(\u0026#34;summary\u0026#34;); res.forEach(function (doc) { this.add(doc); documents[doc.url] = { title: doc.title, content: doc.content, summary: doc.summary, }; }, this); }); // Once data is loaded we can register handler registerSearchHandler(); }) .catch((err) =\u0026gt; { console.log({ err }); const errorMsg = \u0026#39;{{ i18n \u0026#34;search_error\u0026#34; }}\u0026#39;; searchResults.innerHTML = ` \u0026lt;div class=\u0026#34;bg-red-100 border-l-4 border-red-500 text-red-700 p-4\u0026#34; role=\u0026#34;alert\u0026#34;\u0026gt; \u0026lt;p\u0026gt;${errorMsg}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;`; }); /////////////////////////////////////////////////////////// function renderSearchResults(results) { const noResults = \u0026#39;{{ i18n \u0026#34;search_noCoincidence\u0026#34; }}\u0026#39;; // If results are empty if (results.length === 0) { searchResults.innerHTML = ` \u0026lt;div class=\u0026#34;bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4\u0026#34; role=\u0026#34;alert\u0026#34;\u0026gt; \u0026lt;p\u0026gt;${noResults}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; return; } // Show max 10 results if (results.length \u0026gt; 9) { results = results.slice(0, 10); } // Reset search results searchResults.innerHTML = \u0026#34;\u0026#34;; // Append results results.forEach((result) =\u0026gt; { // Create result item let article = document.createElement(\u0026#34;article\u0026#34;); article.classList.add(\u0026#34;mb-8\u0026#34;); article.innerHTML = ` \u0026lt;a href=\u0026#34;${result.ref}\u0026#34; class=\u0026#34;block group\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;article-title group-hover:text-green-500 pb-1\u0026#34;\u0026gt;${documents[result.ref].title}\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;text-gray-700 dark:text-gray-300\u0026#34;\u0026gt;\u0026lt;p\u0026gt;${documents[result.ref].summary}\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/a\u0026gt;`; searchResults.appendChild(article); }); } function registerSearchHandler() { // Register on input event searchInput.oninput = function (event) { if (searchInput.value === \u0026#34;\u0026#34;) { searchResults.innerHTML = \u0026#34;\u0026#34;; return; } // Get input value const query = event.target.value; // Run fuzzy search const results = idx.query(function(q) { q.term(lunr.tokenizer(query.trim()), { usePipeline: true, boost: 100 }); q.term(lunr.tokenizer(query.trim()) + \u0026#39;*\u0026#39;, { usePipeline: false, boost: 10 }); q.term(lunr.tokenizer(query.trim()), { usePipeline: false, editDistance: 1 }); }); // Render results renderSearchResults(results); }; searchInput.placeholder = \u0026#39;{{ i18n \u0026#34;search_inputPlaceholder\u0026#34; }}\u0026#39;; } })(); \u0026lt;/script\u0026gt; Y con esto ya tendríamos nuestro buscador finalizado. Para elaborar esta solución he seguido las guías de Joseph Earl y Matt Walters. He adaptado y actualizado el código Javascript y he corregido la manera de lanzar la búsqueda con Lunr, ya que no era del todo precisa y no funcionaba correctamente en todos los casos. Esta es la parte más importante, y la solución la encontré en una issue en el github de Lunr:\n// Run fuzzy search const results = idx.query(function(q) { q.term(lunr.tokenizer(query.trim()), { usePipeline: true, boost: 100 }); q.term(lunr.tokenizer(query.trim()) + \u0026#39;*\u0026#39;, { usePipeline: false, boost: 10 }); q.term(lunr.tokenizer(query.trim()), { usePipeline: false, editDistance: 1 }); }); Puedes consultar mi fichero search.html con el código completo en github y adaptarlo para tu caso de uso.\n","summary":"¿Cómo implementar un buscador con Hugo? Mi primer impulso fue buscar en la documentación oficial, donde encontré una serie de links y guías que me permitieron orientarme un poco, pero no terminaba de convencerme ninguna."},{"url":"/blog/usando-tailwindcss-con-angular/","title":"Usando TailwindCSS con Angular","content":"En este artículo vamos a explicar cómo configurar una aplicación Angular con Angular CLI para poder integrar TailwindCSS. Con esta integración el CSS que tengamos que escribir en los componentes va a ser mínimo pues la mayoría de estilos definidos usarán clases Tailwind.\nAngular CLI Angular CLI es la interfaz de línea de comandos recomendada para generar aplicaciones Angular. Por debajo utiliza webpack, pero no tenemos acceso directamente a la configuración utilizada, por lo que si queremos añadir/modificar algún comportamiento podemos hacer uso de un paquete llamado @angular-builders/custom-webpack, el cual nos permitirá extender la configuración de webpack.\nConfigurando TailwindCSS TailwindCSS va a funcionar independientemente del preprocesador que estemos utilizando en nuestra aplicación (si es que usamos alguno). Por comodidad, configuraremos PurgeCSS para eliminar todas las clases que no estemos utilizando solo para el entorno de producción y no en desarrollo, donde estarán todas las clases disponibles. Vamos a ver paso por paso como añadir Tailwind.\nEl primer paso será instalar las dependencias:\nnpm install tailwindcss --save npm install --save-dev @angular-builders/custom-webpack @fullhuman/postcss-purgecss Generamos un fichero de configuración de Tailwind vacío:\nnpx tailwind init Creamos un nuevo fichero, con la extensión en función del preprocesador que estemos utilizando. En mi caso scss, por lo que el fichero será src/tailwind.scss e insertamos las directivas de Tailwind. En caso de querer generar clases CSS este será el fichero donde añadirlas.\n@tailwind base; @tailwind components; /* Custom CSS */ a.tag { @apply bg-gray-200 rounded-full px-3 py-1 font-semibold text-gray-700; } a.tag:hover { @apply underline; } /* Custom CSS end */ @tailwind utilities; A continuación crearemos un fichero extra-webpack.config.js en la raíz del proyecto con el siguiente contenido:\nconst purgecss = require(\u0026#39;@fullhuman/postcss-purgecss\u0026#39;)({ // Specify the paths to all of the template files in your project content: [\u0026#39;./src/**/*.html\u0026#39;, \u0026#39;./src/**/*.component.ts\u0026#39;], // Include any special characters you\u0026#39;re using in this regular expression defaultExtractor: content =\u0026gt; content.match(/[\\w-/:]+(?\u0026lt;!:)/g) || [] }); module.exports = (config, options) =\u0026gt; { console.log(`Using \u0026#39;${config.mode}\u0026#39; mode`); config.module.rules.push({ test: /tailwind\\.scss$/, use: [ { loader: \u0026#39;postcss-loader\u0026#39;, options: { plugins: [ require(\u0026#39;tailwindcss\u0026#39;)(\u0026#39;./tailwind.config.js\u0026#39;), require(\u0026#39;autoprefixer\u0026#39;), ...(config.mode === \u0026#39;production\u0026#39; ? [purgecss] : []) ] } } ] }); return config; }; angular.json Ahora necesitamos editar el fichero de configuración angular.json para poder personalizar los comandos ng serve y ng build. Iremos a la clave projects.architect.build.builder y reemplazaremos @angular-devkit/build-angular:browser por @angular-builders/custom-webpack:browser. Y en la ruta architect.build.options, añadiremos un objeto customWebpackConfig que tendrá en una clave path el valor extra-webpack.config.js.\nHaremos los mismos cambios en projects.architect.serve.builder reemplazando @angular-devkit/build-angular:dev-server por @angular-builders/custom-webpack:dev-server, y en la ruta architect.serve.options añadiremos nuevamente un objeto customWebpackConfig que tendrá en una clave path el valor extra-webpack.config.js.\nPor último añadiremos nuestra hoja de estilos src/tailwind.scss al array en la ruta architect.build.options.styles. Veamos todos los cambios juntos:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026#34;architect\u0026#34;: { \u0026#34;build\u0026#34;: { \u0026#34;builder\u0026#34;: \u0026#34;@angular-builders/custom-webpack:browser\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;customWebpackConfig\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;extra-webpack.config.js\u0026#34; }, // ... \u0026#34;styles\u0026#34;: [ \u0026#34;src/tailwind.scss\u0026#34;, \u0026#34;src/styles.css\u0026#34; ], // ... } }, \u0026#34;serve\u0026#34;: { \u0026#34;builder\u0026#34;: \u0026#34;@angular-builders/custom-webpack:dev-server\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;customWebpackConfig\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;extra-webpack.config.js\u0026#34; }, // ... } } } Una vez aplicados estos cambios podremos desarrollar ejecutando ng serve, se lanzará nuestra aplicación en modo desarrollo donde dispondremos de todas las clases de Tailwind, lo que nos permitirá ser más ágiles. Al compilar para producción con ng build --prod podremos ver que se generarán solo las clases que hemos utilizado en la carpeta dist.\nchunk {4} styles.847663bf210845648553.css (styles) 5.51 kB [initial] [rendered] PurgeCSS integrado en Tailwind Desde la versión 1.4.0 Tailwind integra la opción de utilizar PurgeCSS directamente desde la propia configuración de Tailwind. De esta manera el proceso puede simplificarse un poco, podríamos eliminar la dependencia @fullhuman/postcss-purgecss de nuestro proyecto y dejar el fichero extra-webpack.config.js con el siguiente contenido:\nmodule.exports = (config, options) =\u0026gt; { console.log(`Using \u0026#39;${config.mode}\u0026#39; mode`); config.module.rules.push({ test: /tailwind\\.scss$/, use: [ { loader: \u0026#39;postcss-loader\u0026#39;, options: { plugins: [ require(\u0026#39;tailwindcss\u0026#39;)(\u0026#39;./tailwind.config.js\u0026#39;) ] } } ] }); return config; }; Y pasaremos las rutas al fichero tailwind.config.js:\nmodule.exports = { purge: [\u0026#39;./src/**/*.html\u0026#39;, \u0026#39;./src/**/*.component.ts\u0026#39;], theme: { extend: {}, }, variants: {}, plugins: [], }; Para que puedan eliminarse las clases que no utiliza nuestro proyecto, debemos compilar con la variable de entorno NODE_ENV con valor production. Para poder dar valor a esta variable y que funcione de manera multiplataforma me gusta utilizar el paquete cross-env. Podemos instalarlo en nuestro proyecto:\nnpm install cross-env --save-dev Y posteriormente podemos crear un script en el package.json para lanzar el build:\n1 2 3 4 5 6 7 8 9 10 11 12 13 { // ... \u0026#34;scripts\u0026#34;: { \u0026#34;ng\u0026#34;: \u0026#34;ng\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;ng serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;ng build\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;ng test\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;ng lint\u0026#34;, \u0026#34;e2e\u0026#34;: \u0026#34;ng e2e\u0026#34;, \u0026#34;build:prod\u0026#34;: \u0026#34;cross-env NODE_ENV=production ng build --prod\u0026#34; }, // ... } Lo ejecutamos para comprobar que todo funciona correctamente:\nnpm run build:prod chunk {4} styles.847663bf210845648553.css (styles) 5.51 kB [initial] [rendered] Con estos sencillos pasos ya estás listo para utilizar Tailwind en tus proyectos Angular.\n","summary":"En este artículo vamos a explicar cómo configurar una aplicación Angular con Angular CLI para poder integrar TailwindCSS."},{"url":"/blog/integrar-tailwindcss-con-hugo/","title":"Integrar TailwindCSS con Hugo","content":"Vamos a ver como configurar nuestro sitio construido con Hugo para que integre TailwindCSS. Hugo es muy flexible y te permite de una manera sencilla configurar tu sitio a tu gusto. En mi caso en particular, tengo el fichero baseof.html como esqueleto de todo mi sitio, y en el tengo un partial (que viene a ser un include) llamado head.html.\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;es\u0026#34;\u0026gt; \u0026lt;head\u0026gt; {{ partial \u0026#34;head.html\u0026#34; . }} \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Realizamos la importación del fichero styles.css de la carpeta css y le pasamos la función absURL de Hugo, de manera que nos devuelve la ruta absoluta.\n\u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1, shrink-to-fit=no\u0026#34;\u0026gt; {{ $css := \u0026#34;css/styles.css\u0026#34; | absURL }} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{ $css }}\u0026#34;\u0026gt; Los archivos estáticos en Hugo se guardan por defecto en la carpeta static, así que ya tenemos el primer paso, tener un fichero styles.css en la ruta /static/css/. Como este fichero va a ser generado, lo que he hecho ha sido crearme una carpeta llamada static-src donde tener los fuentes de mis ficheros estáticos que posteriormente voy a procesar.\nAntes de continuar, vamos a instalar las dependencias que vamos a necesitar con npm.\nnpm install tailwindcss --save npm install postcss postcss-cli @fullhuman/postcss-purgecss autoprefixer watch cross-env cssnano --save-dev Veamos qué son estas dependencias:\ntailwindcss: El framework CSS. postcss postcss-cli: PostCSS se utiliza para compilar Tailwind y además añadiremos algunos plugins para el resultado final de nuestro CSS. @fullhuman/postcss-purgecss: Tailwind genera muchísimas clases, utilizaremos este plugin para eliminar las clases que no utilicemos de Tailwind y reducir el tamaño final de nuestro CSS. autoprefixer: Opcional, para poner prefijos a nuestra hoja de estilos. watch: Paquete de node que nos permite ejecutar tareas cuando algún fichero sea modificado. Viene con un cli que utilizaremos en un script npm. cross-env: Paquete multiplataforma para dar valor a la variable de entorno NODE_ENV. cssnano: Minimizador para CSS. Con todas estas dependencias ya disponemos de las piezas del puzzle necesarias para generar un fichero CSS con Tailwind y solo con las clases que utilicemos, no todo el framework. Generamos un fichero de configuración de Tailwind vacío, para en caso de querer personalizar las opciones que vienen por defecto en el framework podamos. Tan solo ejecutaremos:\nnpx tailwind init Y nos generará un fichero tailwind.config.js vacío en el raíz:\nmodule.exports = { theme: { extend: {} }, variants: {}, plugins: [] } Ya podemos crear nuestro fichero /static-src/styles.css invocando a las directivas de Tailwind. Además podremos añadir otros estilos CSS que queramos, utilicen Tailwind o no.\n@tailwind base; @tailwind components; /* Custom CSS */ a.tag { @apply bg-gray-200 rounded-full px-3 py-1 font-semibold text-gray-700; } a.tag:hover { @apply underline; } /* Custom CSS end */ @tailwind utilities; Tailwind es compilado utilizando PostCSS, por lo que puedes integrar fácilmente otros plugins. En nuestro caso vamos a meter autoprefixer, para que se generen automáticamente los prefijos de las propiedades que lo necesiten y además, cuando compilemos para producción vamos a utilizar purgecss y cssnano para reducir al máximo el tamaño de nuestra hoja de estilos. Veamos el fichero de configuración de PostCSS (postcss.config.js, ubicado en el directorio raíz):\nconst purgecss = require(\u0026#39;@fullhuman/postcss-purgecss\u0026#39;)({ content: [\u0026#39;../../content/**/*.md\u0026#39;, \u0026#39;./layouts/**/*.html\u0026#39;], defaultExtractor: content =\u0026gt; content.match(/[A-Za-z0-9-_:/]+/g) || [] }); module.exports = { plugins: [ require(\u0026#39;tailwindcss\u0026#39;), require(\u0026#39;autoprefixer\u0026#39;), ...(process.env.NODE_ENV === \u0026#39;production\u0026#39; ? [purgecss, require(\u0026#39;cssnano\u0026#39;)] : []) ] }; A la hora de purgar el CSS, buscaremos en todos nuestros ficheros con extensión .md en la carpeta content y .html en layouts. Si trabajas con ficheros javascript u otras rutas donde añadas clases CSS, deberás ajustar el array de rutas. Este snippet considera que estamos trabajando con un theme dentro de la carpeta /themes/nombretheme/, si trabajamos directamente desde la carpeta layouts de Hugo (como he hecho yo en este blog) habría que ajustar las rutas:\nconst purgecss = require(\u0026#39;@fullhuman/postcss-purgecss\u0026#39;)({ content: [\u0026#39;./content/**/*.md\u0026#39;, \u0026#39;./layouts/**/*.html\u0026#39;, \u0026#39;./static/**/*.js\u0026#39;], defaultExtractor: content =\u0026gt; content.match(/[A-Za-z0-9-_:/]+/g) || [] }); Con todo esto ya podemos generar nuestros scripts npm en el fichero package.json:\n{ \u0026#34;name\u0026#34;: \u0026#34;hugo-tailwindcss\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;css:watch\u0026#34;: \u0026#34;node_modules/.bin/watch \\\u0026#34;npm run css:build:dev\\\u0026#34; ./static-src/css\u0026#34;, \u0026#34;css:build:dev\u0026#34;: \u0026#34;cross-env NODE_ENV=development npm run css:build\u0026#34;, \u0026#34;css:build:prod\u0026#34;: \u0026#34;cross-env NODE_ENV=production npm run css:build\u0026#34;, \u0026#34;css:build\u0026#34;: \u0026#34;node_modules/.bin/postcss static-src/css/styles.css -o static/css/styles.css\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;tailwindcss\u0026#34;: \u0026#34;^1.1.4\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@fullhuman/postcss-purgecss\u0026#34;: \u0026#34;^2.0.5\u0026#34;, \u0026#34;autoprefixer\u0026#34;: \u0026#34;^9.7.4\u0026#34;, \u0026#34;cross-env\u0026#34;: \u0026#34;^6.0.3\u0026#34;, \u0026#34;cssnano\u0026#34;: \u0026#34;^4.1.10\u0026#34;, \u0026#34;postcss\u0026#34;: \u0026#34;^7.0.26\u0026#34;, \u0026#34;postcss-cli\u0026#34;: \u0026#34;^7.1.0\u0026#34;, \u0026#34;watch\u0026#34;: \u0026#34;^1.0.2\u0026#34; } } Tenemos principalmente 3 tareas:\ncss:build:dev: Compila el fichero CSS en modo desarrollo, para mayor agilidad tendremos todo Tailwind por defecto sin necesidad de minimizar y purgar clases. css:build:prod: Compila, purga y minimiza el fichero CSS para obtener la hoja de estilos optimizada para producción. css:watch: Observa la carpeta ./static-src/css para en caso de cambios volver a compilar el fichero. Muy útil para no lanzar manualmente la tarea css:build:dev cada vez que hagamos cambios. Con estas tareas ya podemos generar nuestra hoja de estilos. He creado un repositorio en Github con un theme que incorpora estos scripts como punto de partida para poder crear tu propio theme para Hugo. Puedes probarlo con algo de contenido de prueba que he creado en otro repositorio para verlo en acción.\nNOTA: Es posible integrar todo el proceso gracias al pipe postCSS de Hugo. Te obliga a tener instalado globalmente postcss-cli además de los plugins que uses. Yo personalmente prefiero no tener instalados globalmente paquetes y poder personalizar todo el proceso, pero es una opción a tener en cuenta que nos brinda Hugo.\n","summary":"Vamos a ver como configurar nuestro sitio construido con Hugo para que integre TailwindCSS."},{"url":"/blog/nueva-web-con-hugo/","title":"Nueva web con Hugo","content":"Estreno nueva web con un propósito: volver de nuevo a la actividad de mi blog personal en el que crear de vez en cuando algún artículo, donde tener a mano tutoriales con las nuevas cosas que voy aprendiendo.\nAtrás queda mi antiguo blog construido con Wordpress. Siempre quise diseñar mi propio sitio desde cero y finalmente lo he hecho. A través de este y los próximos artículos voy a resumir algunas de las cosas que he aprendido diseñando esta página.\nEn primer lugar tenía que elegir con qué herramienta gestionar mi página personal, en su día tenía en mente desarrollar mi propio tema para Wordpress, pero con el paso del tiempo han ido apareciendo muchas otras alternativas y finalmente me decidí por utilizar alguna herramienta generadora de sitios estáticos (en inglés con las siglas SSG).\nBusqué información de las ventajas de los distintos generadores y de casualidad me topé con una herramienta escrita en Go que es muy rápida, Hugo, así que empecé a trastear y probar. Cuando me quise dar cuenta me encontraba cómodo y avanzaba rápido, así que me decanté por Hugo.\nPara poder trabajar con Hugo, lo primero que hice fué instalarlo y posteriormente seguir esta guía para poder crear un blog con Hugo desde cero. A partir de ahí Hugo te permite hacer prácticamente lo que quieras, es bastante flexible, puedes instalar temas, utilizar shortcodes para sintaxis coloreada de código, embeber contenido de servicios populares como Youtube, Twitter, Instagram, etc.\nComo Hugo genera un sitio estático, la opción para hosting más sencilla es Github pages. Para subir una nueva versión del sitio simplemente copio la carpeta public al repositorio, y al hacer commit y push se despliega automáticamente.\nFinalmente, me quedaba la decisión de cómo iba a organizar la maquetación del sitio. Al ser un sitio pequeño, podría haber maquetado todo desde cero con CSS o SASS, pero llevo un tiempo oyendo hablar de un framework CSS llamado Tailwind CSS que utiliza un concepto denominado \u0026ldquo;utility first\u0026rdquo;. Después de haber trabajado con Bootstrap, no me apetecía aprender un nuevo framework pero me decidí a darle una oportunidad. Al empezar mi primer pensamiento fue que todo quedaba muy sucio con esa ristra de clases por todos lados, pero con el paso del tiempo me fui acostumbrando y le fui cogiendo el gustillo, hasta el punto de que he quedado encantado.\nTailwind no es un framework como Bootstrap, no te da componentes creados con una sintaxis marcada. Tailwind te ofrece un conjunto de utilidades CSS atómicas con las que poder crear tus propios componentes de manera consistente. Te puedes concentrar en crear, no pierdes tiempo en buscar la mejor manera de nombrar las clases, no repites una y otra vez las mismas propiedades CSS que hacen que los ficheros CSS crezcan sin control.\nTailwind te provee de un conjunto de posibilidades entre las que elegir, distintos tamaños de texto, una paleta de colores, sombras, escala para margins y paddings\u0026hellip; Y además es completamente personalizable, Tailwind está construido sobre PostCSS y puedes mediante su fichero de configuración sobrescribir o extender los valores que desees. Tailwind te da una base sobre la que poder crear tu sistema de diseño para una web totalmente personalizada. Pruébalo y no te defraudará, de primeras es normal ser reticente.\nEn próximos artículos voy a ir desgranando cómo me he configurado Hugo a mi gusto, cosas que he aprendido y que he necesitado de mucho tiempo para resolver.\n","summary":"Estreno nueva web con un propósito: volver de nuevo a la actividad de mi blog personal en el que crear de vez en cuando algún artículo, donde tener a mano tutoriales con las nuevas cosas que voy aprendiendo."},{"url":"/blog/activar-https-con-lets-encrypt/","title":"Activar https con Let’s Encrypt","content":"Let’s Encrypt es un proveedor gratuito de certificados TLS/SSL que nos brinda la posibilidad de activar https en nuestro servidor para nuestros dominios. El proceso está automatizado tanto para Apache como Nginx, en mi caso voy a utilizar Cerbot para instalarlo en mi servidor Nginx.\nCertbot es un software que es actualizado bastante a menudo por sus desarrolladores. Si queremos disfrutar de la versión más actualizada, deberemos añadir su repositorio ya que si tiramos de los de Ubuntu, lo más normal es que tengan versiones más antiguas. Para ello:\nsudo add-apt-repository ppa:certbot/certbot Aceptaremos las condiciones del servicio para poder actualizar los repositorios del sistema operativo.\nsudo apt-get update Y finalmente instalaremos Certbot.\nsudo apt-get install python-certbot-nginx Certbot ya está listo, ahora simplemente comprobaremos que tenemos definido en nuestro fichero de configuración de Nginx la clave server_name con el dominio que vamos a utilizar.\nVeremos la configuración del servidor por defecto en el fichero default, o si está en otro dominio configurado, iremos a ese fichero.\nsudo nano /etc/nginx/sites-available/default server_name example.com www.example.com; Si ya está configurado, no es necesario hacer nada. En caso contrario añadimos nuestro dominio y ejecutamos los siguientes comandos para comprobar que la configuración de Nginx introducida no da problemas, y si es así recargamos para refrescar la nueva configuración:\nsudo nginx -t sudo systemctl reload nginx Por último antes de obtener el certificado, vamos a añadir en nuestro firewall ufw que permita el trafico https. Para ello podemos ejecutar los siguientes comandos para añadir el perfil Nginx full, que incorpora tanto http como https y eliminaremos el http que sobra una vez añadido el anterior:\nsudo ufw allow \u0026#39;Nginx Full\u0026#39; sudo ufw delete allow \u0026#39;Nginx HTTP\u0026#39; Comprobamos:\nsudo ufw status Status: active To Action From -- ------ ---- OpenSSH ALLOW Anywhere Nginx Full ALLOW Anywhere OpenSSH (v6) ALLOW Anywhere (v6) Nginx Full (v6) ALLOW Anywhere (v6) Finalmente lanzaremos el proceso para obtener el certificado y que se renueve automáticamente.\nsudo certbot --nginx -d example.com -d www.example.com Se nos pedirá una dirección de correo electrónico y, si todo va bien, nos saldrá una pregunta solicitándonos elegir entre si queremos redireccionar el tráfico http a https o no. Elegimos la deseada, en mi caso elegí la segunda y pulsamos enter.\nPlease choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access. ------------------------------------------------------------------------------- 1: No redirect - Make no further changes to the webserver configuration. 2: Redirect - Make all requests redirect to secure HTTPS access. Choose this for new sites, or if you're confident your site works on HTTPS. You can undo this change by editing your web server's configuration. ------------------------------------------------------------------------------- Select the appropriate number [1-2] then [enter] (press 'c' to cancel): IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at /etc/letsencrypt/live/example.com/fullchain.pem. Your cert will expire on 2017-10-23. To obtain a new or tweaked version of this certificate in the future, simply run certbot again with the \"certonly\" option. To non-interactively renew *all* of your certificates, run \"certbot renew\" - Your account credentials have been saved in your Certbot configuration directory at /etc/letsencrypt. You should make a secure backup of this folder now. This configuration directory will also contain certificates and private keys obtained by Certbot so making regular backups of this folder is ideal. - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let's Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-le De esta manera ya se han descargado e instalado los certificados para el dominio, puedes ir al navegador e introducir el dominio para comprobar si se ha actualizado el indicador de seguridad.\nSi no todo fue correctamente y has obtenido un error como el siguiente:\nError: duplicate listen options for [::]:443 Hay una solución, que consiste en abrir el fichero de configuración de Nginx para el dominio y eliminar listen [::]:80 pero dejando listen 80;\nAl volver a ejecutar de nuevo y eligiendo la opción de reinstalar los certificados debería de funcionar. Los certificados son válidos durante 90 días, certbot se encarga de lanzar un proceso que comprueba automáticamente 2 veces por día si quedan menos de 30 días para la expiración, de ser así los certificados serán renovados. Podemos comprobar que todo funciona correctamente ejecutando:\nbashsudo certbot renew --dry-run\nPuedes comprobar en el directorio /etc/cron.d que hay un script llamado certbot que se encarga de ello. Referencias interesantes:\nCertbot Error al obtener certificados Tutorial en inglés en Digital Ocean Ya puedes disfrutar de conexión https para tu dominio.\n","summary":"Let’s Encrypt es un proveedor gratuito de certificados TLS/SSL que nos brinda la posibilidad de activar https en nuestro servidor para nuestros dominios."},{"url":"/blog/configuraci%C3%B3n-servidor-vps-en-digital-ocean-i/","title":"Configuración servidor VPS en Digital Ocean I","content":"Me he decidido a contratar un VPS en Digital Ocean, a ver si de una vez por todas en mi escaso tiempo libre, puedo ir desarrollando un portfolio y aprendiendo cosas nuevas. Vamos a ver un listado de la configuración de un VPS desde cero, partiendo de una instalación limpia de Ubuntu 16.04. Vayamos por partes:\nConfiguración inicial del servidor En este apartado hablaremos de la configuración inicial básica para que nuestro VPS sea más seguro. Lo primero de todo es conectarnos a nuestro servidor, para ello utilizaremos ssh para establecer conexión remota por consola, con el usuario root, hasta que creemos otro usuario. Podemos conectarnos desde la consola de nuestro sistema operativo (Mac, Linux), o utilizar alguna utilidad como Putty, que es un cliente SSH gratuito y archiconocido para Windows. Para conectarnos deberemos saber la dirección IP pública de nuestro servidor y ejecutar el siguiente comando:\nssh root@your_server_ip Al ser la primera conexión, veremos un mensaje informándonos que no se puede asegurar la autenticidad de la conexión, escribiremos yes para establecer conexión:\nThe authenticity of host '1XX.XXX.XXX.XXX' can't be established. ECDSA key fingerprint is SHA256:71mD5o12895hg7tu85lPFDY1khktRcuPnsfCQFrTaK0. Are you sure you want to continue connecting (yes/no)? Y se nos solicitará cambiar la contraseña root por seguridad. El usuario root tiene todos los privilegios y no es una buena idea hacer un uso regular de él ya que por accidente podemos ejecutar acciones destructivas e irreversibles. Por este motivo, el siguiente paso será crear otro usuario para conectarnos normalmente con él, para ello ejecutamos el siguiente comando y contestamos unas sencillas preguntas:\nadduser mike Tras crear nuestro nuevo usuario, le otorgaremos permisos de super usuario para poder ejecutar comandos con privilegios de root anteponiendo la palabra sudo.\nusermod -aG sudo mike Abriremos una nueva terminal, y probaremos a conectar con nuestro nuevo usuario para verificar que podemos hacer login correctamente:\nssh mike@your_server_ip Todo servidor web que se precie debe contar con un Firewall, hay muchas opciones, una de las más sencillas y que viene ya incluida en Ubuntu es UFW. Con UFW podremos controlar qué servicios tienen acceso a la conexión. Para ver la lista de aplicaciones registradas en el firewall, ejecutamos el siguiente comando:\nsudo ufw app list Obteniendo como resultado:\nAvailable applications: OpenSSH Es muy importante que permitamos el acceso a OpenSSH, de lo contrario la próxima vez que vayamos a conectarnos no podremos, algo que no debe ocurrir. Para ello añadimos OpenSSH:\nsudo ufw allow OpenSSH Y sólo después de esto activaremos el firewall:\nbashsudo ufw enable\nEn cualquier momento podemos comprobar los aplicaciones que hemos permitido o denegado a través del comando:\nbashsudo ufw status\nStatus: active To Action From -- ------ ---- OpenSSH ALLOW Anywhere OpenSSH (v6) ALLOW Anywhere (v6) A partir de ahora será necesario que en futuras aplicaciones y/o servicios instalados, permitamos que realice conexiones añadiéndolas a ufw.\nInstalación de LEMP LEMP son las siglas que indican un servidor con sistema operativo Linux, Nginx como servidor web, PHP como procesador dinámico y MySQL como base de datos para el backend. Algo muy común por ejemplo a la hora de tener una página en WordPress. Vamos a ver como instalar en nuestro VPS estos paquetes:\nInstalar Nginx Nginx es un servidor web de código abierto, uno de los más usados en el mundo junto con Apache. Cada uno tiene sus pros y sus contras, yo he optado por Nginx. Antes de nada, actualizaremos el repositorio apt de nuestro servidor, y posteriormente instalaremos nginx:\nsudo apt-get update sudo apt-get install nginx Una vez instalado se inicia el servicio automáticamente, acto seguido deberemos registrar nginx en ufw:\nsudo ufw allow \u0026#39;Nginx HTTP\u0026#39; sudo ufw status Status: active To Action From -- ------ ---- OpenSSH ALLOW Anywhere Nginx HTTP ALLOW Anywhere OpenSSH (v6) ALLOW Anywhere (v6) Nginx HTTP (v6) ALLOW Anywhere (v6) Hecho esto, ya solo deberemos acceder a la dirección IP pública de nuestro VPS para ver la página de bienvenida de nginx.\nInstalar MySQL Para instalarlo simplemente ejecutamos:\nsudo apt-get install mysql-server Nos pedirá una contraseña para el usuario root. Una vez instalado es altamente recomendable ejecutar un script de seguridad para eliminar configuraciones inseguras, usuarios de ejemplo y bases de datos de prueba.\nsudo mysql_secure_installation Tan sólo hay que seguir el asistente introduciendo el carácter y para contestar que sí.\nInstalar PHP Nginx por defecto no cuenta con procesamiento para PHP. Para ello deberemos instalar php-fpm. Tecleamos en la terminal:\nsudo apt-get install php-fpm php-mysql A continuación editaremos la configuración de PHP para hacerla más segura:\nsudo nano /etc/php/7.0/fpm/php.ini Pulsando F6, buscaremos la siguiente cadena: “cgi.fix_pathinfo”. Pondremos su valor en 0 para desactivarlo, ya que con esta configuración activada podría permitirse a un usuario malintencionado ejecutar scripts a los que normalmente no debería tener acceso. Cerramos, guardamos y reiniciamos el servicio:\nsudo systemctl restart php7.0-fpm Habilitar PHP en Nginx Con Nginx podemos tener distintas configuraciones de servidor para distintos sitios (dominios, subdominios…). Inicialmente solo tendremos un sitio, llamado default. Vamos a habilitar PHP editando el fichero default, además de algunas configuraciones de seguridad:\nsudo nano /etc/nginx/sites-available/default Añadiremos index.php como posible entrada por defecto de un directorio, podremos modificar server_name, para poder acceder a través de dominio en lugar de nuestra IP pública, que es la que vendrá por defecto. Habilitaremos PHP con las líneas marcadas en rojo y evitaremos el procesamiento de archivos .htaccess por motivos de seguridad.\nserver { listen 80 default_server; listen [::]:80 default_server; root /var/www/html; # Add index.php to the list if you are using PHP index index.html index.htm index.nginx-debian.html index.php; # server_name tudominio.com; server_name 1XX.XX.XX.XX; location / { try_files $uri $uri/ =404; } # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \\.php$ { include snippets/fastcgi-php.conf; fastcgi_pass unix:/run/php/php7.0-fpm.sock; } # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # location ~ /\\.ht { deny all; } } Cerramos, guardamos el fichero y haremos un test para verificar que no hay ningún error de sintaxis en la configuración de Nginx:\nbashsudo nginx -t\nSi no hay errores, reiniciamos el servicio para que pueda aplicarse la nueva configuración:\nbashsudo systemctl reload nginx\nPara finalizar, iremos a la carpeta /var/www/html y crearemos un fichero index.php, con el siguiente contenido:\n\u0026lt;?php phpinfo(); ?\u0026gt; Ahora simplemente accediendo a nuestra dirección IP pública o dominio, deberemos ver una página con toda la configuración de PHP. Cuando hayamos verificado que está funcionando, borraremos el fichero y ya tendremos nuestro servidor LEMP con la configuración inicial para poder hacer cosas.\n","summary":"Me he decidido a contratar un VPS en Digital Ocean, a ver si de una vez por todas en mi escaso tiempo libre, puedo ir desarrollando un portfolio y aprendiendo cosas nuevas."},{"url":"/blog/direcci%C3%B3n-ip-fija-para-raspberry-en-raspbian/","title":"Dirección IP fija para Raspberry en Raspbian","content":"Por comodidad a la hora de disfrutar de nuestra Raspberry lo más conveniente es asignarle una IP fija. De esa manera siempre podremos conectarnos a la misma dirección y no dependeremos de que el servidor DHCP nos dé una distinta cada vez. Esta configuración es muy básica, sencilla y muy necesaria a la hora de conectarnos remotamente o configurar otra serie de servicios.\nVamos a ver como en unos sencillos pasos lo hacemos en Raspbian. Los pasos son para la interfaz ethernet, ya que en mi caso es la que veo que tiene mayor sentido, pues tengo conectada la raspberry al lado del router por cable.\nEditaremos el fichero dhcpcd.conf con nano u otro cualquier editor.\nsudo nano /etc/dhcpcd.conf Y añadiremos al final del fichero las siguientes líneas (asegurate de poner una dirección dentro de tu red y la IP de tu router):\ninterface eth0 static ip_address=192.168.1.50 static routers=192.168.1.1 static domain_name_servers=8.8.8.8 static domain_search=8.8.4.4 Guardamos y salimos, para comprobar el fichero interfaces, que tendrá este aspecto:\n# interfaces(5) file used by ifup(8) and ifdown(8) # Please note that this file is written to be used with dhcpcd # For static IP, consult /etc/dhcpcd.conf and \u0026#39;man dhcpcd.conf\u0026#39; # Include files from /etc/network/interfaces.d: source-directory /etc/network/interfaces.d auto lo iface lo inet loopback iface eth0 inet manual allow-hotplug wlan0 iface wlan0 inet manual wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf allow-hotplug wlan1 iface wlan1 inet manual wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf La parte importante es iface eth0 inet manual, donde indicamos que la IP sea manual. Lo más probable es que ya esté bien y no tengas que tocarlo. Guardando y reiniciando ya deberíamos disponer de nuestra IP fija.\n","summary":"Por comodidad a la hora de disfrutar de nuestra Raspberry lo más conveniente es asignarle una IP fija."},{"url":"/blog/configurar-teclado-conexi%C3%B3n-remota-raspberry-pi-con-xdrp-km-040a.ini/","title":"Configurar teclado conexión remota Raspberry Pi con XDRP – km-040a.ini","content":"Si te conectas de manera remota a tu raspberry, a través de la aplicación de Conexión a escritorio remoto de Windows por ejemplo, tarde o temprano te darás cuentas que si no utilizas un teclado inglés, muchos de los símbolos y teclas están cambiados. Puede convertirse en una odisea el simple hecho de introducir el password de conexión si este tiene algún carácter especial.\n¿Pero cómo es esto posible? Si al configurar mi raspberry me preocupé de cambiar la configuración de teclado a español (o el idioma que sea). Bien esto sucede por tener el teclado conectado físicamente, pero si desconectas teclado y ratón y te conectas remotamente, la raspberry tomará por defecto que utilizas un teclado inglés americano. Veamos como solucionarlo.\nSi estás conectado en remoto, ten en cuenta que te deberás conectar físicamente (con un teclado) a la raspberry, de lo contrario los comandos necesarios para iniciar la configuración no funcionarán. Una vez conectado físicamente, veamos paso a paso como proceder:\nEjecuta el siguiente comando, con el cual indicamos que queremos usar un teclado español de España. setxkbmap -layout \u0026#39;es,es\u0026#39; Navega al directorio /etc/xrdp, haz ls y comprueba que no haya un fichero km-040a.ini, que es el correspondiente al teclado español. Si lo hay, no está de más de hacer un backup por si acaso. Lo normal es que no lo haya, asi que a través del siguiente comando lo crearemos. xrdp-genkeymap /etc/xrdp/km-040a.ini Este es el fichero que se encarga de establecer los mapeos a las teclas. Crearemos un backup de él antes de modificarlo. Desde la consola, con sudo ejecutaremos: sudo cp km-040a.ini km-040a.ini.backup Con esto tendríamos ya funcionando el teclado, pero no del todo. Seguramente muchos símbolos ya se hayan corregido, pero combinaciones con la tecla AltGr, y las flechas arriba, abajo, derecha, izquierda puede que no funcionen. Si este es el caso, hay que editar el fichero km-040a.ini y terminar de mapear todo correctamente. Por suerte pude encontrar por internet un fichero que funcionaba bien con mi teclado, y simplemente lo sobrescribí. Si estás buscando algún otro fichero de configuración para otro teclado, puedes probar a ver si lo encuentras desde este repositorio. Si no está, deberás averiguar el nombre de fichero para tu teclado en función del país, y seguramente buscando en Google alguien haya encontrado la solución.\nYo pude solucionarlo gracias a dos artículos en inglés:\nConexión escritorio remoto en Ubuntu. Teclas especiales en XDRP. ","summary":"Si te conectas de manera remota a tu raspberry, a través de la aplicación de Conexión a escritorio remoto de Windows por ejemplo, tarde o temprano te darás cuentas que si no utilizas un teclado inglés, muchos de los símbolos y teclas están cambiados."},{"url":"/blog/conexi%C3%B3n-remota-a-raspberry-pi/","title":"Conexión remota a Raspberry Pi","content":"Una vez finalizada la configuración básica, vamos a ver la manera de conectarnos remotamente, sin necesidad de tener enchufado ratón y teclado a la Raspberry, ni tan siquiera un monitor HDMI (si no quieres). Por defecto raspbian Pixel trae instalado el paquete RealVNC para conexiones remotas. Este paquete es incompatible con xrdp, que es el protocolo que utiliza la herramienta de Conexión a Escritorio remoto que trae instalada Windows por defecto.\nSi no dispones de Windows no te preocupes, vamos a ver varias maneras distintas de conexión en remoto. Para continuar con la configuración instalaremos el paquete tightvncserver, que se encarga automáticamente de desinstalar RealVNC . Para instalar, desde la terminal simplemente ejecutamos:\nsudo apt install -y tightvncserver La opción -y simplemente responde que sí a cualquier pregunta planteada. Finalmente instalamos xrdp:\nsudo apt install -y xrdp Para poder acceder fácilmente a nuestra Raspberry desde Windows, podemos instalar Samba. Así en lugar de recordar la IP, podemos recordar solamente el nombre que le hayamos puesto en el apartado hostname de la pestaña Sistema dentro de la configuración de la raspberry. Especialmente útil si tiene IP dinámica y no fija. En mi caso mi Raspberry se llama \u0026ldquo;rasp\u0026rdquo;. Para instalar samba:\nsudo apt install -y samba Desde ahora, en una máquina Windows podremos acceder fácilmente al mini ordenador. Probamos desde cmd de Windows a hacer ping:\nping rasp Para conectar remotamente, disponemos de 2 opciones:\nDesde Windows no es necesario ningún paso adicional, simplemente abriremos la herramienta de Conexión a Escritorio remoto. Pondremos la IP o el hostname que le hayamos dado, podremos configurar una serie de opciones como Pantalla (tamaño del escritorio remoto, calidad del color…), y una vez esté a nuestro gusto pulsamos en Conectar.\nEs posible que salte un aviso informando de que no se puede comprobar la identidad del equipo remoto, pulsaremos Sí para establecer la conexión. Si todo ha ido bien, veremos una pantalla donde introducir nuestras credenciales de acceso a la Raspberry. Usuario pi y contraseña raspberry, si es que no la has cambiado aún(¡deberías!).\nDespués de escribir usuario y password, al dar OK veremos el escritorio de nuestra Raspberry, y podremos interactuar con ella desde la interfaz gráfica.\nPara conectar desde cualquier plataforma, podemos utilizar VNC. Yo lo utilizo desde mi móvil android, con la aplicación VNC Viewer. Hay distintas aplicaciones para las distintas plataformas, incluso hay una extensión para Google Chrome. Para ello deberemos dar algún paso más, nada complicado.\nEn la consola de nuestra Raspberry, ejecutaremos el comando vncpasswd, y nos pedirá establecer una contraseña que será solicitada en el momento que accedamos por remoto. Además nos dará la posibilidad de crear una contraseña unicamente para ver la Raspberry pero sin manipular, le decimos que no pues no nos interesa.\nAhora crearemos un escritorio remoto simplemente ejecutando vncserver, y en consola veremos el número de escritorio creado, la primera vez será :1, la siguiente :2, etc. Desde nuestra red local simplemente en nuestra herramienta VNC, ponemos la IP de la Raspberry, seguido del número de escritorio. Si es el escritorio 1, y nuestra IP es 192.168.1.50, deberemos conectar a 192.168.1.50:1.\nSi estamos conectando desde fuera de nuestra red, a través de internet, el número de escritorio correspondería con el puerto 5901 para el escritorio 1. 5902 para el 2, etc., ya que el puerto de VNC es el 5900. Pero esto lo explicaré con mayor detalle en otras entradas, para conectar remotamente desde fuera de casa.\nTras pulsar conectar, nos solicitará la password y después de introducirla conectaremos remotamente. Puedes crear distintos tipos de escritorios remotos con VNC, para ver las distintas opciones lo mejor es consultar la ayuda con vncserver --help.\nHasta aquí la manera de conectar a través de interfaz gráfica, si bien no es la conexión que más a menudo uso, puntualmente me viene bien. La manera más habitual de conectar, como hacen muchos usuarios de Linux es a través de SSH, conectaremos a la consola de nuestra Raspberry y dispondremos de la línea de comandos para ejecutar lo que queramos.\nPara ello se puede hacer uso de una herramienta llamada Putty, o de cualquier línea de comandos. En Putty simplemente ponemos la dirección IP de la máquina a la que nos vamos a conectar, elegimos ssh y dejamos el puerto por defecto que es el 22. En consola normal, ejecutaremos el comando ssh seguido de la dirección IP: ssh 192.168.1.50.\nElegimos Open, introducimos nuestras credenciales y ya estaremos en nuestra máquina.\nNOTA: Antes de intentar conectar por SSH o VNC, es importante comprobar en la configuración de la raspberry que dichos servicios están habilitados, recientemente Raspbian ha cambiado y por defecto trae ssh deshabilitado.\n","summary":"Una vez finalizada la configuración básica, vamos a ver la manera de conectarnos remotamente, sin necesidad de tener enchufado ratón y teclado a la Raspberry, ni tan siquiera un monitor HDMI (si no quieres)."},{"url":"/blog/raspberry-pi-primeros-pasos-2/","title":"Raspberry pi, primeros pasos (2)","content":"Una vez tenemos arrancada nuestra Raspberry con Raspbian aparece el escritorio. Lo primero que deberemos hacer será aplicar una configuración básica, para ello la última versión de Raspbian cuenta con una herramienta visual llamada “Configuración de Raspberry pi”, que encuentras en Menú / Preferencias.\nNOTA: He tomado los pantallazos después de configurar mi raspberry, inicialmente todo se encuentra en inglés.\nUna vez arrancamos la aplicación, nos aparecerá la siguiente pantalla:\nDentro de la pestaña sistema.\nClave: Muy importante cambiar la contraseña por defecto para el usuario pi, que es raspberry. Cabe destacar que hace poco los desarrolladores de Raspbian optaron por deshabilitar SSH por defecto, ya que se producen bastantes ataques que logran acceder a raspberries que no han cambiado la contraseña por defecto. Parece de sentido común por seguridad cambiar esta contraseña por otra. Puedes ampliar la información sobre gestión de usuarios en la documentación oficial. Hostname: Para acceder remotamente, en lugar de teclear la ip. Puedes poner lo que más te guste, en mi caso acorté a rasp. Iniciar en: Poco que explicar, para arrancar en escritorio o línea de comandos. Si arrancas en consola siempre puedes iniciar la interfaz gráfica con el comando startx. Como para casi todo me conecto desde remoto, yo he elegido consola. Red al iniciar: Lo he marcado, inicialmente no es necesario, pero para algunos servicios como el servidor web que inicia Transmission (cliente de torrent), es necesario. El resto de parámetros no necesitan explicación. En la imagen no aparece la opción Expandir sistema de ficheros, supongo que es porque ya lo hice. Esta opción es para que se utilice toda la capacidad de la tarjeta microSD en el sistema, si cambias de tarjeta por una de mayor capacidad, no olvides aplicar la expansión para aprovechar todo el espacio. En Interfaces podemos activar/desactivar una serie de servicios, yo activé ssh, que es lo que uso el 90% del tiempo para manejar la raspberry.\nRendimiento\nMemoria GPU, viene por defecto con 64MB, si vas a utilizar Kodi para reproducir HD y/o emuladores de consola, será necesario aumentar este valor. Yo he puesto 128MB para Kodi, no descarto aumentarlo un poco más. Si no tienes estos requerimientos, 64MB es más que suficiente. El valor máximo para Raspberry Pi 3 es de 944, según la documentación oficial (buscar gpu_mem).\nPor último encontramos la pestaña Localización, donde configurar la zona horaria, locale, teclado y país de la Wifi. Puse todo en español. Para configurar el teclado es necesario que esté enchufado físicamente.\nUna vez configurado todo a nuestro gusto, pulsamos Aceptar para que se apliquen los cambios.\nConfiguración de Internet Para obtener salida a Internet tenemos 2 opciones, conectar por cable ethernet o a través de Wifi. Yo tengo el router al lado de la raspberry, asi que está conectada por cable. Si en tu caso no tienes cerca para enchufar por cable, puedes acceder a través de Wifi, en el icono de al lado de Bluetooth puedes configurar tu red Wifi.\nUna vez conectado, puedes abrir el navegador y comprobar la conexión a internet. También puedes abrir una terminal y hacer ping: ping google.com\nConfigurada la salida a Internet, el siguiente paso es actualizar el sistema. Estos comandos deberían ejecutarse de vez en cuando, para estar al día en actualizaciones de seguridad.\nsudo apt-get update sudo apt-get dist-upgrade El primero actualiza el listado de paquetes, el segundo instala las actualizaciones. Si quieres ejecutar ambos y que conteste sí a las preguntas, puedes poner en una sola línea:\nsudo apt-get update \u0026amp;\u0026amp; sudo apt-get -y dist-upgrade Con todo esto ya tenemos la configuración básica inicial. Las posibilidades que brinda este mini ordenador son enormes, a partir de aquí hay que adaptarla a nuestras necesidades. Los usos más comunes son para servidores de descarga, servidor de contenido multimedia, domótica, etc. En próximas entradas explicaré configuración de algunos servicios que estoy usando.\n","summary":"Una vez tenemos arrancada nuestra Raspberry con Raspbian aparece el escritorio."},{"url":"/blog/raspberry-pi-primeros-pasos/","title":"Raspberry Pi, primeros pasos","content":" Recientemente me he animado a adquirir el mini ordenador más famoso actualmente, la archiconocida Raspberry Pi. Seguramente hayas oído hablar de ella, lleva muchos años y dispone de varios modelos. Hay multitud de información en la red, yo actualmente no conozco mucho, pero buscando por internet puedes encontrar de todo, y cada persona va adaptando su Raspberry Pi a sus necesidades. En mi caso tan solo quiero trastear, automatizar ciertas tareas cotidianas y poner en marcha cualquier idea que se me pase por la mente.\nHay multitud de distribuciones, tanto oficiales como no oficiales, yo en mi caso me he decantado por la más completa, Raspbian. Vamos a ver una serie de pasos básicos para instalar Raspbian y arrancar nuestra Raspberry.\nSi aún no tienes tu Raspberry, vamos a repasar brevemente el material necesario.\nRaspberry Pi 3 B, el último modelo. Su precio puede oscilar en función de donde la adquieras, siendo más barata en sitios como Aliexpress, y un poco más cara en tiendas como Amazon. Entre los 25-40€ puedes encontrarla. Este último modelo cuenta con antena Wifi incorporada y Bluetooth, características no disponibles en modelos anteriores. Fuente de alimentación. Recomiendo la oficial, pero si no lo es, asegurate de que sea buena y que cuente con salida de 5.1V a 2.5A. Caja para Raspberry. Es opcional, las hay de distintos tipos, la oficial, transparentes, con hueco para un ventilador, con espacio para incorporar una pantalla y poder convertir tu Raspberry en una tablet, etc. Tarjeta MicroSD. Versiones anteriores de la raspberry funcionan con una tarjeta SD, pero el último modelo ya funciona con MicroSD. Este será el disco duro, recomendable un adaptador de MicroSD a SD para introducirla en el ordenador y grabar la imagen del sistema operativo. A tener en cuenta, la capacidad, yo recomendaría 16 GB mínimo y de clase 10, cuanto mejor sea la velocidad de escritura, mejor será el rendimiento de nuestro mini ordenador. Cable HDMI, para conectarla a la televisión o cualquier monitor. Será necesario para el primer arranque, posteriormente se puede acceder por remoto o SSH. En mi caso elegí la opción más rápida y cómoda, que es comprar un kit en Amazon con todos los componentes oficiales. Puedes ahorrar algunos euros comprando los componentes por separado.\nInstalando Raspbian Vamos a ver como instalar Raspbian en la tarjeta MicroSD en unos sencillos pasos:\nDescargamos Raspbian desde la página web oficial. Raspbian es el sistema operativo oficial y el que mayor soporte tiene. Hay una versión ligera y una full, yo me he decantado por instalar la completa. Insertamos la tarjeta MicroSD en el adaptador SD, y este último a su vez en nuestra tarjeta lectora de SD de nuestro ordenador. Abrimos el explorador y nos aseguramos de la letra que corresponde con la tarjeta. Para escribir la imagen disponemos de dos programas. El primero (el que recomiendo y he usado) es Etcher, es multiplataforma y dispone de la capacidad de grabar la imagen sin necesidad de descomprimirla. Además comprueba al finalizar que se grabó correctamente. La otra opción es Win32 Disk Imager. Simplemente seleccionamos la imagen, la unidad (asegurate de no equivocarte y elegir la de la tarjeta) y flasheamos. Una vez termine (tardará un rato), y compruebe que se ha grabado correctamente, ya dispondremos de la tarjeta lista para insertarla en nuestra raspberry. Primer arranque de la Raspberry Ahora solo toca ensamblar todo el hardware antes de arrancar. Si disponemos de caja, en la parte posterior encontramos la ranura para introducir fácilmente nuestra tarjeta MicroSD. Una vez insertada, hacemos uso de los puertos USB para conectar ratón y teclado, conectamos el cable HDMI de la raspberry al monitor/televisión, y por último conectamos la fuente de alimentación. Con esto se encenderá nuestra raspberry y deberíamos ver en pantalla el arranque de Raspbian.\nHasta aquí la primera parte de primeros pasos con Raspberry. En posteriores artículos describiré como configurar algunos aspectos básicos como Wifi, teclado, idioma, conectarnos remotamente, etc.\nAmplía información sobre Raspberry en su página web oficial.\n","summary":"Recientemente me he animado a adquirir el mini ordenador más famoso actualmente, la archiconocida Raspberry Pi."},{"url":"/blog/reemplazando-atributos-html-con-sublime/","title":"Reemplazando atributos HTML con Sublime","content":"Un tip rápido y fácil aplicable con Sublime o cualquier otro editor de texto que permita reemplazar con expresiones regulares. Me encontraba copiando a una entrada de Wordpess una tabla desde un fichero excel, en el cual había modificado el ancho de algunas celdas. Es una manera fácil de insertar una tabla sin necesidad de estar construyendo todo el código html.\nEl problema era que había un montón de atributos width, cada uno con un número distinto. Corregirlas a mano no es una opción cuando eres vago, y para ello las expresiones regulares acuden al rescate.\nSimplemente pulsando Ctrl + H (o en el menú Find-\u0026gt; Replace), nos aseguramos de marcar la opción de expresiones regulares, y buscamos la siguiente expresión regular.\nwidth=\u0026quot;.*?\u0026quot;\nVemos como se seleccionan todas las ocurrencias (en rojo la opción de búsqueda con expresiones regulares).\nSimplemente va a buscar todas las coincidencias en el fichero del atributo width con contenido entre comillas. Seleccionamos reemplazar por nada, y en un momento ya hemos eliminado todos los atributos width del texto. Fácil y sencillo.\n","summary":"Un tip rápido y fácil aplicable con Sublime o cualquier otro editor de texto que permita reemplazar con expresiones regulares."},{"url":"/blog/arbol-de-intervalos-interval-tree-en-javascript/","title":"Arbol de intervalos (interval tree) en Javascript","content":"Continúo aprendiendo cosas en mi proyecto laboral actual. En este caso, para optimizar el rendimiento de una búsqueda en un objeto enorme en Javascript. El problema es el siguiente, se han de encontrar los nodos que pertenecen a un intervalo dado. En este caso en concreto, se dispone de una lista de canales de televisión, para los cuales disponemos de todos los programas, relativos a varios días de programación.\nEn los navegadores de hoy en día, como Google Chrome o cualquier navegador medianamente moderno, no habría excesivos problemas en iterar por fuerza bruta hasta encontrar todos los eventos cuya fecha de inicio y fin se encontrase dentro del intervalo (ojo, para nada digo que sea lo más óptimo ni recomendado). Los problemas pueden llegar cuando en el target del proyecto podemos encontrar televisiones Smart TV´s antiguas y/o de gama baja, que vienen más justas de memoria.\nAdemás, no es un escenario normal, en mi caso los datos se encuentran en formato binario, y es necesario realizar una descodificación antes de saber si un determinado programa de un canal está dentro del rango horario buscado o no. Para ello podemos elaborar un árbol de intervalos, algo bastante sencillo de hacer en lenguajes como Java, pero más difícil en Javascript. Por suerte, siempre podemos encontrar librerías y código de terceros que ya haya resuelto este y otros algoritmos para Javascript, en este caso yo he utilizado ésta librería, interval-tree2.\nSu uso es muy sencillo, tal y como describen en su sitio de Github. En nuestro proyecto utilizamos RequireJS como cargador de módulos, asi que adapté los distintos ficheros y los convertí en módulos. Si no tienes ni idea de CoffeeScript (lenguaje que compila a Javascript), ni de como compilarlo, puedes instalarte el paquete por npm, que es lo que hice yo y de ahí cogí los ficheros js.\nnpm install interval-tree2 En la carpeta dist se encuentran los ficheros necesarios:\ninterval.js interval-tree.js node.js point.js sorted-list.js util.js Yo he cogido todos, los he modificado para usarlos en entorno web, pongo el código al final de la entrada. Siguiendo el ejemplo puesto por el autor. Para crear un árbol y añadir intervalos:\nvar itree = new IntervalTree(300); // 300 : Centro del árbol // \u0026#39;foo\u0026#39; es el identificador del intervalo itree.add(22, 56, \u0026#39;foo\u0026#39;); // \u0026#39;bar\u0026#39; es el identificador del intervalo itree.add(44, 199, \u0026#39;bar\u0026#39;); // Si no se pone id, se asigna automáticamente uno itree.add(1, 38); Una vez insertados los intervalos, a la hora de buscar disponemos de 2 métodos:\n// Intervalos que coinciden con un punto var intervals = itree.pointSearch(103); // Intervalos que entran en el rango solicitado var intervals2 = itree.rangeSearch(103, 400); Una vez obtenidos, se pueden recorrer todos los intervalos:\nintervals2.forEach(function(interval) { console.log(interval.start); // Posición de inicio console.log(interval.end); // Posición de fin console.log(interval.id); // ID }); Por último, se puede eliminar un intervalo dado su id:\nitree.remove(\u0026#39;foo\u0026#39;); En mi caso, encontré especialmente útil el id de cada intervalo, pues lo usaba para obtener información de la posición dentro del binario donde poder buscar la información de cada programa. Cada canal de televisión dispone de su árbol, y cada evento tenía un id de este estilo:\ndia_deprogramacion|posicion_binario\nEjemplo: “5|250”\nAquí está todo el código de seguido, en formato módulos de Javascript, listo para importar y comenzar a usarse en entorno web.\nvar Node = ( function() { /** @constructor @param {Number} center center of the node */ function Node( center ) { this.center = center; /** another node whose center is less than this.center @property {Node} left */ this.left = null; /** another node whose center is greater than this.center @property {Node} right */ this.right = null; /** sorted list of Intervals, sorting them by their start property @property {SortedList(Interval)} starts */ this.starts = new SortedList( \u0026#39;start\u0026#39; ); /** sorted list of Intervals, sorting them by their end property @property {SortedList(Interval)} ends */ this.ends = new SortedList( \u0026#39;end\u0026#39; ); } /** the number of intervals @method count @return {Number} */ Node.prototype.count = function() { return this.starts.length; }; /** insert an interval @method insert @param {Interval} interval */ Node.prototype.insert = function( interval ) { this.starts.insert( interval ); return this.ends.insert( interval ); }; /** get intervals whose start position is less than or equal to the given value @method startPointSearch @param {Number} val @return {Array(Interval)} */ Node.prototype.startPointSearch = function( val ) { var index; index = this.starts.lastPositionOf( { start: val } ); return this.starts.slice( 0, index + 1 ); }; /** get intervals whose end position is more than or equal to the given value @method endPointSearch @param {Number} val @return {Array(Interval)} */ Node.prototype.endPointSearch = function( val ) { var index; index = this.ends.firstPositionOf( { end: val } ); return this.ends.slice( index ); }; /** gets all registered interval @method getAllIntervals @return {Array(Interval)} */ Node.prototype.getAllIntervals = function() { return this.starts.toArray(); }; /** remove the given interval @method remove @param {Interval} interval @param {SortedList} list */ Node.prototype.remove = function( interval ) { this.removeFromList( interval, this.starts ); return this.removeFromList( interval, this.ends ); }; /** remove the given interval from the given list @method removeFromList @private @param {Interval} interval @param {SortedList} list */ Node.prototype.removeFromList = function( interval, list ) { var candidate, firstPos, i, idx, ref, ref1, results; firstPos = list.firstPositionOf( interval ); results = []; for ( idx = i = ref = firstPos, ref1 = list.length; ref \u0026lt;= ref1 ? i \u0026lt; ref1 : i \u0026gt; ref1; idx = ref \u0026lt;= ref1 ? ++i : --i ) { candidate = list[ idx ]; if ( candidate.id === interval.id ) { list.remove( idx ); break; } else { results.push( void 0 ); } } return results; }; return Node; } )(); var Interval; Interval = ( function() { /** @constructor @param {Number} start start of the interval @param {Number} end end of the interval @param {Number|String} id id of the interval */ function Interval( start, end, id ) { this.start = start; this.end = end; this.id = id; } /** get center of the interval @method center @return {Number} center */ Interval.prototype.center = function() { return ( this.start + this.end ) / 2; }; return Interval; } )(); var IntervalTree = ( function() { /** @constructor @param {Number} center center of the root node */ function IntervalTree( center ) { Util.assertNumber( center, \u0026#39;IntervalTree: center\u0026#39; ); /** center =\u0026gt; node @property {Object(Node)} nodesByCenter */ this.nodesByCenter = {}; /** root node @property {Node} root */ this.root = this.createNode( center ); /** interval id =\u0026gt; interval @property {Object(Interval)} intervalsById */ this.intervalsById = {}; /** interval id =\u0026gt; node @property {Object(Node)} nodesById */ this.nodesById = {}; /** sorted list of whole point @property {SortedList(Point)} pointTree */ this.pointTree = new SortedList( \u0026#39;val\u0026#39; ); /** unique id candidate of interval without id to be added next time @property {Number} idCandidate */ this.idCandidate = 0; } /** add one interval @method add @public @param {Number} start start of the interval to create @param {Number} end end of the interval to create @param {String|Number} [id] identifier to distinguish intervals. Automatically defined when not set. @return {Interval} */ IntervalTree.prototype.add = function( start, end, id ) { var interval; if ( this.intervalsById[ id ] != null ) { throw new Error( \u0026#39;id \u0026#39; + id + \u0026#39; is already registered.\u0026#39; ); } if ( id == null ) { while ( this.intervalsById[ this.idCandidate ] != null ) { this.idCandidate++; } id = this.idCandidate; } Util.assertNumber( start, \u0026#39;1st argument of IntervalTree#add()\u0026#39; ); Util.assertNumber( end, \u0026#39;2nd argument of IntervalTree#add()\u0026#39; ); if ( start \u0026gt;= end ) { Util.assertOrder( start, end, \u0026#39;start\u0026#39;, \u0026#39;end\u0026#39; ); } interval = new Interval( start, end, id ); this.pointTree.insert( new Point( interval.start, id ) ); this.pointTree.insert( new Point( interval.end, id ) ); this.intervalsById[ id ] = interval; return this.insert( interval, this.root ); }; /** search intervals when only one argument is given, return intervals which contains the value when two arguments are given, ... @method search @public @param {Number} val1 @param {Number} val2 @return {Array(Interval)} intervals */ IntervalTree.prototype.search = function( val1, val2 ) { Util.assertNumber( val1, \u0026#39;1st argument at IntervalTree#search()\u0026#39; ); if ( val2 == null ) { return this.pointSearch( val1 ); } else { Util.assertNumber( val2, \u0026#39;2nd argument at IntervalTree#search()\u0026#39; ); Util.assertOrder( val1, val2, \u0026#39;1st argument\u0026#39;, \u0026#39;2nd argument\u0026#39;, \u0026#39;IntervalTree#search()\u0026#39; ); return this.rangeSearch( val1, val2 ); } }; /** removes an interval of the given id @method remove @public @param {Number|String} id id of the interval to remove */ IntervalTree.prototype.remove = function( id ) { var interval, node; interval = this.intervalsById[ id ]; if ( interval == null ) { return; } node = this.nodesById[ id ]; node.remove( interval ); delete this.nodesById[ id ]; return delete this.intervalsById[ id ]; }; /** search intervals at the given node @method pointSearch @public @param {Number} val @param {Node} [node] current node to search. default is this.root @return {Array(Interval)} */ IntervalTree.prototype.pointSearch = function( val, node, results ) { if ( node == null ) { node = this.root; } if ( results == null ) { results = []; } Util.assertNumber( val, \u0026#39;1st argument of IntervalTree#pointSearch()\u0026#39; ); if ( val \u0026lt; node.center ) { results = results.concat( node.startPointSearch( val ) ); if ( node.left != null ) { return this.pointSearch( val, node.left, results ); } else { return results; } } if ( val \u0026gt; node.center ) { results = results.concat( node.endPointSearch( val ) ); if ( node.right != null ) { return this.pointSearch( val, node.right, results ); } else { return results; } } return results.concat( node.getAllIntervals() ); }; /** returns intervals which covers the given start-end interval @method rangeSearch @public @param {Number} start start of the interval @param {Number} end end of the interval @return {Array(Interval)} */ IntervalTree.prototype.rangeSearch = function( start, end ) { var firstPos, i, id, interval, j, lastPos, len, len1, point, ref, ref1, resultsById; Util.assertNumber( start, \u0026#39;1st argument at IntervalTree#rangeSearch()\u0026#39; ); Util.assertNumber( end, \u0026#39;2nd argument at IntervalTree#rangeSearch()\u0026#39; ); Util.assertOrder( start, end, \u0026#39;1st argument\u0026#39;, \u0026#39;2nd argument\u0026#39;, \u0026#39;IntervalTree#rangeSearch()\u0026#39; ); resultsById = {}; ref = this.pointSearch( start ); for ( i = 0, len = ref.length; i \u0026lt; len; i++ ) { interval = ref[ i ]; resultsById[ interval.id ] = interval; } firstPos = this.pointTree.firstPositionOf( new Point( start ) ); lastPos = this.pointTree.lastPositionOf( new Point( end ) ); ref1 = this.pointTree.slice( firstPos, lastPos + 1 ); for ( j = 0, len1 = ref1.length; j \u0026lt; len1; j++ ) { point = ref1[ j ]; resultsById[ point.id ] = this.intervalsById[ point.id ]; } return ( function() { var results1; results1 = []; for ( id in resultsById ) { interval = resultsById[ id ]; results1.push( interval ); } return results1; } )(); }; /** insert interval to the given node @method insert @private @param {Interval} interval @param {Node} node node to insert the interval @return {Interval} inserted interval */ IntervalTree.prototype.insert = function( interval, node ) { if ( interval.end \u0026lt; node.center ) { if ( node.left == null ) { node.left = this.createNode( interval.end ); } return this.insert( interval, node.left ); } if ( node.center \u0026lt; interval.start ) { if ( node.right == null ) { node.right = this.createNode( interval.start ); } return this.insert( interval, node.right ); } node.insert( interval ); this.nodesById[ interval.id ] = node; return interval; }; /** create node by center @method createNode @private @param {Number} center @return {Node} node */ IntervalTree.prototype.createNode = function( center ) { var node; node = new Node( center ); this.nodesByCenter[ center ] = node; return node; }; return IntervalTree; } )(); var Util; Util = ( function() { function Util() {} Util.assertNumber = function( val, desc ) { if ( val == null ) { throw new Error( desc + \u0026#39; is required.\u0026#39; ); } if ( typeof val !== \u0026#39;number\u0026#39; ) { throw new Error( desc + \u0026#39; must be a number.\u0026#39; ); } }; Util.assertOrder = function( start, end, startName, endName, desc ) { if ( start \u0026gt;= end ) { throw new Error( desc + \u0026#34;: \u0026#34; + startName + \u0026#34;(\u0026#34; + start + \u0026#34;) must be smaller than \u0026#34; + endName + \u0026#34;(\u0026#34; + end + \u0026#34;).\u0026#34; ); } }; return Util; } )(); /** extended array of objects, always sorted @class SortedList @extends Array @module interval-tree2 */ var SortedList, extend = function( child, parent ) { for ( var key in parent ) { if ( hasProp.call( parent, key ) ) child[ key ] = parent[ key ]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty; SortedList = ( function( superClass ) { extend( SortedList, superClass ); /** @constructor @param {String} compareKey key name to compare objects. The value of the key must be a number. */ /** key name to compare objects. The value of the key must be a number. @property {String} compareKey */ function SortedList( compareKey ) { this.compareKey = compareKey; } /** insert a value @method insert @param {any} val @return {Number} inserted position */ SortedList.prototype.insert = function( val ) { var pos; pos = this.bsearch( val ); this.splice( pos + 1, 0, val ); return pos + 1; }; /** remove the value in the given position @method remove @param {Number} pos position @return {SortedList} self */ SortedList.prototype.remove = function( pos ) { this.splice( pos, 1 ); return this; }; /** get maximum value in the list @method max @return {Number} */ SortedList.prototype.max = function() { var ref; return ( ref = this[ this.length - 1 ] ) != null ? ref[ this.compareKey ] : void 0; }; /** get minimum value in the list @method min @return {Number} */ SortedList.prototype.min = function() { var ref; return ( ref = this[ 0 ] ) != null ? ref[ this.compareKey ] : void 0; }; /** binary search @method bsearch @param {any} val @return {Number} position of the value */ SortedList.prototype.bsearch = function( val ) { var comp, epos, mpos, mval, spos; if ( !this.length ) { return -1; } mpos = null; mval = null; spos = 0; epos = this.length; while ( epos - spos \u0026gt; 1 ) { mpos = Math.floor( ( spos + epos ) / 2 ); mval = this[ mpos ]; comp = this.compare( val, mval ); if ( comp === 0 ) { return mpos; } if ( comp \u0026gt; 0 ) { spos = mpos; } else { epos = mpos; } } if ( spos === 0 \u0026amp;\u0026amp; this.compare( this[ 0 ], val ) \u0026gt; 0 ) { return -1; } else { return spos; } }; /** leftmost position of the given val @method firstPositionOf @param {any} val @return {Number} leftmost position of the value */ SortedList.prototype.firstPositionOf = function( val ) { var index, num, ref; index = this.bsearch( val ); if ( index === -1 ) { return -1; } num = val[ this.compareKey ]; if ( num === ( ( ref = this[ index ] ) != null ? ref[ this.compareKey ] : void 0 ) ) { while ( true ) { if ( index \u0026lt;= 0 ) { break; } if ( this[ index - 1 ][ this.compareKey ] \u0026lt; num ) { break; } index--; } } else { index++; } return index; }; /** rightmost position of the given val @method lastPositionOf @param {any} val @return {Number} rightmost position of the value */ SortedList.prototype.lastPositionOf = function( val ) { var index, num; index = this.bsearch( val ); if ( index === -1 ) { return -1; } num = val[ this.compareKey ]; if ( index === this.length - 1 \u0026amp;\u0026amp; num \u0026gt; this.max() ) { return index + 1; } while ( true ) { if ( index + 1 \u0026gt;= this.length ) { break; } if ( this[ index + 1 ][ this.compareKey ] \u0026gt; num ) { break; } index++; } return index; }; /** * sorted.toArray() * get raw array * */ SortedList.prototype.toArray = function() { return this.slice(); }; /** comparison function. Compares two objects by this.compareKey @method compare @private @param {any} a @param {any} b */ SortedList.prototype.compare = function( a, b ) { var c; if ( a == null ) { return -1; } if ( b == null ) { return 1; } c = a[ this.compareKey ] - b[ this.compareKey ]; if ( c \u0026gt; 0 ) { return 1; } else if ( c === 0 ) { return 0; } else { return -1; } }; return SortedList; } )( Array ); var Point; Point = ( function() { /** @constructor @param {Number} val number @param {Number|String} id id */ function Point( val, id ) { this.val = val; this.id = id; } return Point; } )(); ","summary":"Continúo aprendiendo cosas en mi proyecto laboral actual. En este caso, para optimizar el rendimiento de una búsqueda en un objeto enorme en Javascript."},{"url":"/blog/suscribirse-de-manera-segura-a-eventos-con-jquery/","title":"Suscribirse de manera segura a eventos con jQuery","content":"Un truco del que me acabo de enterar, que seguro será de gran utilidad a la hora de desarrollar aplicaciones con Javascript. Sobre todo aplicaciones SPA (Single Page Application). A la hora de suscribirnos a eventos de manera global en nuestras ventanas, escenas, vistas (hay multitud de forma de llamarlas según el framework o el entorno en que trabajes) es algo muy normal suscribirnos a eventos en window.\nUn ejemplo sería el evento resize.\n$( window ).on( \u0026#34;resize\u0026#34;, _handleResize ); Muy simple, nos suscribimos al evento resize del navegador para que se ejecute la función _handleResize cada vez que se produce un redimensionado del navegador. Al salir de nuestra vista, para ahorrar en consumo de memoria, es altamente recomendable eliminar todos los listeners que hayamos creado, si no van a ser necesarios, y crearlos nuevamente cuando vayamos a necesitarlos. La duda es, ¿Cómo eliminar nuestra llamada unicamente sin afectar al resto?\n$( window ).off( \u0026#34;resize\u0026#34; ); Si hacemos el off directamente, eliminaríamos todos los callbacks asociados al evento resize, algo que probablemente no es lo que buscamos. Para solucionar este problema, podemos hacer uso de namespaces que nos permitan suscribirnos y desuscribirnos al evento resize dado un namespace. Para ello simplemente escribiremos resize.nombreNameSpace. Así creamos el listener:\n$( window ).on( \u0026#34;resize.config\u0026#34;, _handleResize ); Y de la misma forma, aplicamos el off.\n$( window ).off( \u0026#34;resize.config\u0026#34; ); El mismo truco funciona para otros eventos como keydown. Asi que si no conocías esta valiosa información de jQuery, ya puedes comenzar a utilizarla para evitar “desuscribir” más de la cuenta.\n","summary":"Un truco del que me acabo de enterar, que seguro será de gran utilidad a la hora de desarrollar aplicaciones con Javascript."},{"url":"/blog/obtener-el-valor-de-una-propiedad-css-en-porcentaje/","title":"Obtener el valor de una propiedad CSS en porcentaje","content":"Un tip rápido, trabajando con jQuery no es posible obtener de un nodo por ejemplo, el valor del ancho en porcentaje. Lo primero y más lógico que se nos ocurre sería invocar al método css y pedirle el width (equivalente sería a otras propiedades como top, left, height, etc):\nvar $element = $(\u0026#34;\u0026lt;div id=\u0026#39;nodo\u0026#39; style=\u0026#39;width: 50%\u0026#39;\u0026gt;\u0026lt;/div\u0026gt;\u0026#34;); $(\u0026#34;body\u0026#34;).append( $element ); console.log( $(\u0026#34;#nodo\u0026#34;).css(\u0026#34;width\u0026#34;) ); // 683px Si quisiéramos obtener el valor en porcentaje, habría que hacerlo de otra manera, directamente sin jQuery. Los selectores de jQuery devuelven un array con los elementos del DOM, asi que si tomamos la posición 0 tendremos el elemento del DOM (no la instancia jQuery) y podremos acceder directamente a la clave style:\nvar $element = $(\u0026#34;\u0026lt;div id=\u0026#39;nodo\u0026#39; style=\u0026#39;width: 50%\u0026#39;\u0026gt;\u0026lt;/div\u0026gt;\u0026#34;); $(\u0026#34;body\u0026#34;).append( $element ); console.log( $(\u0026#34;#nodo\u0026#34;)[0].style.width ); // 50% ","summary":"Un tip rápido, trabajando con jQuery no es posible obtener de un nodo por ejemplo, el valor del ancho en porcentaje."},{"url":"/blog/wordpress-no-carga-despu%C3%A9s-de-actualizar/","title":"WordPress no carga después de actualizar","content":"Después de meses sin publicar ni tan siquiera una entrada, me dirigí a abrir el blog para escribir algo, realizar actualizaciones, plugins, temas, traducciones… Tenía la versión de WordPress desactualizada, el propio WordPress te avisa que antes de actualizar realices un respaldo de la base de datos.\nLe dí a actualizar sin más, y de repente el blog comenzó a dar error 500, no cargaba. Comienza el pánico, a pesar de que tengo varios backups hechos del blog, tanto de manera manual desde el panel de administración del hosting, como con un plugin que os animo y recomiendo a probar, Updraftplus, que realiza backups y los envío a alojamientos externos como Dropbox o Google Drive. La versión básica cumple perfectamente mis expectativas, pero para parámetros avanzados y mayores ventajas disponen de una versión premium. Nunca está de más tener distintos backups.\nOs cuento como he resuelto el problema, por si os lo encontráis alguna vez:\nEn primer lugar, intenté ejecutar de nuevo el script encargado de lanzar la actualización, /wp-admin/upgrade.php. En mi caso me apareció el mensaje de que ya estaba actualizado. Como segunda opción, pensé que podía ser el tema que estoy usando. Fui vía FTP a la carpeta /wp-content/themes, y renombré el directorio del theme que estoy usando añadiendo .old al final (hemingway a hemingway.old), y renombré la carpeta de uno de los themes por defecto de WordPress, (se puede probar con uno o con todos, twentytwelve, twentythirteen, twentyfourteen, twentyfifteen) con el nombre del theme que estaba activado (twentytwelve a hemingway). Seguía fallando asi que pensé que podía tratarse de un plugin desactualizado, antes de pensar en restaurar el último backup o seguir buscando. Finalmente desactivé los plugins, para ello fuí a la carpeta wp-content/plugins, y la renombré a plugins.old. Luego puse en la barra de direcciones del navegador la url de plugins, /wp-admin/plugins.php, al detectar que no había plugins (pues estaba renombrada la carpeta), WordPress por defecto desactiva todos. Me salió el mensaje de que no se habían encontrado plugins para mi sitio, un alivio pues ya veía el panel de administración, y si navegaba a la página principal ya me salía. En mi caso creo que el causante era el plugin Crayon Syntax Highlighter, que utilizo para que el código que publico aparezca con sintaxis coloreada. Como ya tenía acotado el problema, actualicé todos los plugins, los fuí activando y ya funcionaba todo correctamente. Si alguna vez os ocurre, probad esta pequeña guía, es un comienzo antes de volveros locos buscando soluciones vía Google.\n","summary":"Después de meses sin publicar ni tan siquiera una entrada, me dirigí a abrir el blog para escribir algo, realizar actualizaciones, plugins, temas, traducciones… Tenía la versión de WordPress desactualizada, el propio WordPress te avisa que antes de actualizar realices un respaldo de la base de datos."},{"url":"/blog/evitar-que-jquery-sea-global-con-requirejs/","title":"Evitar que jQuery sea global con RequireJS","content":"El popular framework de Javascript jQuery, es utilizado ampliamente en el mundo del desarrollo web. Por defecto se instancia en la variable global $, además de jQuery. Esto puede entrar en conflicto con otras librerías que hayan decidido utilizar el $ también. Si estás utilizando el popular cargador de módulos RequireJS, hay una manera muy fácil para evitar que jQuery se instancie globalmente.\nPor ejemplo, desarrollando para las televisiones SmartTV de Samsung, me encontré con ese problema, ya que Samsung incluye internamente su propia versión de jQuery, sobrescribiendo la que añadas. De manera que haciendo uso del método noConflict de jQuery, junto con la opción map de RequireJS, podemos hacer que se guarde la referencia a jQuery, y que solo tengan acceso a ella los módulos que declaren nuestra versión de jQuery como dependencia.\nVeamos como quedaría nuestra configuración de RequireJS:\nrequire.config( { baseUrl: \u0026#34;./\u0026#34;, paths: { \u0026#34;jquery\u0026#34;: \u0026#34;lib/jquery-1.11.2.min\u0026#34;, \u0026#34;noConflict\u0026#34;: \u0026#34;lib/no-conflict\u0026#34;, }, map: { \u0026#34;*\u0026#34;: { \u0026#34;jquery\u0026#34;: \u0026#34;noConflict\u0026#34; }, \u0026#34;noConflict\u0026#34;: { \u0026#34;jquery\u0026#34;: \u0026#34;jquery\u0026#34; } } } ); Y luego simplemente añadiríamos el siguiente código en el módulo noConflict:\ndefine( [ \u0026#34;jquery\u0026#34; ], function( $ ) { return $.noConflict( true ); } ); Pasándole true al método noConflict de jQuery, además de eliminar jQuery de la variable global $, se elimina además de la global jQuery. De esta manera, podríamos tener varias versiones de jQuery de manera privada, o una pública y otra solo usada como dependencia en los módulos que se necesite.\nPara usarlo, se require jQuery como una dependencia, y se le asigna a la variable que solo estará disponible en ese módulo el nombre que queramos:\ndefine( // Módulos requeridos [ \u0026#34;jquery\u0026#34;, ], function( jQueryPrivado ) { } ); Si aún no conoces RequireJS, o no utilizas un cargador de módulos en tus desarrollos Javascript, te recomiendo que aprendas, ya que ayuda a mantener separadas las distintas funcionalidades de una aplicación, evitando crear un monstruo que a la larga sea difícil de mantener.\n","summary":"El popular framework de Javascript jQuery, es utilizado ampliamente en el mundo del desarrollo web."},{"url":"/blog/n%C3%BAmero-de-commits-en-git-por-usuario/","title":"Número de commits en Git por usuario","content":"Para saber el número de commits realizados por usuario en un repositorio Git, simplemente en el terminal:\ngit shortlog -s -n ","summary":"Para saber el número de commits realizados por usuario en un repositorio Git, simplemente en el terminal:"},{"url":"/blog/compilando-ficheros-sass-con-grunt/","title":"Compilando ficheros Sass con grunt","content":" A lo largo de los 2 últimos años, he ido poco a poco mejorando mi nivel de productividad en el trabajo. Primero cambié mi editor de toda la vida, Notepad++ por Sublime Text. Y posteriormente, he ido añadiendo diferentes herramientas que proporciona Node.js, para automatizar distintos procesos y tareas, como ejecución de tests, linters de código, minimizado de Javascript y CSS, etc…\nPara automatizar más aún todos estos procesos, está Grunt, que dispone de plugins fáciles de integrar en nuestros proyectos, para realizar todo tipo de tareas que precisemos en nuestro proyecto. En mi proyecto actual, surgió una necesidad a un compañero de proyecto, que se encarga de la maquetación de la aplicación que estamos desarrollando.\nPara ello está utilizando Sass, uno de los preprocesadores CSS más populares actualmente. Por motivos de simplicidad de código y maximizar la compatibilidad con navegadores no muy modernos (mantenemos soporte a navegadores webKit antiguos, que usan algunas Smart TV anteriores a 2013), a la hora de hacer los elementos reutilizables de la aplicación con Javascript, decidimos que en lugar de que cada widget cargue su hoja de estilos, tener todo el CSS de todos los widgets unificados en un mismo fichero que esté cargado desde el principio (controlar cuando se ha cargado una hoja de estilos, de manera simple y compatible con todos los navegadores es una tarea que ni RequireJS ha incluido en su cargador de módulos).\nGrunt y sus plugins son instalados y gestionados a través de NPM, el gestor de paquetes por consola para Node.js. Asi que si no lo tienes ya, el primer paso es instalar Node.js. Acto seguido, nos dirigiremos a la consola, e instalaremos Grunt globalmente (seguramente necesites sudo en Linux):\nnpm install -g grunt-cli Ya podemos ir a la carpeta donde está nuestro proyecto (cd ruta/proyecto/). Deberemos tener nuestro fichero package.json creado, con el nombre del proyecto, descripción y otros datos importantes. Si no lo tienes creado, desde consola, estando en el directorio raíz del proyecto, puedes ejecutar npm init, y se irán pidiendo datos para crear el fichero, o puedes crearlo directamente con tu editor de texto, con esto bastaría a priori:\n{ \u0026#34;name\u0026#34;: \u0026#34;Nombre del proyecto\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34; } Una vez hecho esto, ya podemos proceder a instalar grunt de manera local en nuestro proyecto. Simplemente iremos a la carpeta de nuestro proyecto, y en ella ejecutaremos el siguiente comando:\nnpm install grunt --save-dev Observaremos que se instala correctamente, y veremos que en el fichero package.json aparece una nueva clave llamada devDependencies, y aparece grunt:\n{ \u0026#34;name\u0026#34;: \u0026#34;Nombre del proyecto\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;devDependencies\u0026#34;: { \u0026#34;grunt\u0026#34;: \u0026#34;^0.4.5\u0026#34; } } Además, en la raíz, está la carpeta node_modules, donde se irán instalando todos los módulos que tenemos como dependencias para nuestro proyecto. Esto facilita que si nos llevamos el proyecto a otro ordenador, o se lo enviamos a alguien, simplemente situándonos en consola en la raíz del proyecto, podremos ejecutar npm e inmediatamente se instalarán todas las dependencias necesarias para el proyecto. ¿Interesante no?\nUna vez aclarado como instalar grunt, y como funcionan de manera básica las dependencias, procederemos a instalar dos plugins para grunt, grunt-contrib-sass, para compilar Sass y grunt-contrib-watch, que nos permite tener una tarea activa, vigilando que determinados ficheros (en este caso los que tienen extensión .scss) cambien, para, en ese momento, ejecutar una determinada tarea. Ejecutamos, sin importar el orden estos comandos para instalar las nuevas dependencias:\nnpm install grunt-contrib-sass --save-dev npm install grunt-contrib-watch --save-dev Ya está todo listo, ahora solo tenemos que crear nuestras tareas grunt. Para ello, en el raíz del proyecto, junto al fichero package.json, crearemos un fichero llamado gruntfile.js, donde definiremos la configuración de las distintas tareas, luego cargaremos los paquetes a usar en las tareas y por último registraremos las tareas. Para nuestro propósito, el fichero quedaría así:\n// Función contenedora module.exports = function( grunt ) { // Configuración de las tareas grunt.initConfig( { /* * Se observan dentro de la carpeta source, * todos los ficheros con extensión scss. * Cuando se produzca un cambio en alguno de * ellos se ejecutará la tarea sass, definida * más abajo. */ watch: { scripts: { files: \u0026#39;source/**/*.scss\u0026#39;, tasks: [ \u0026#39;sass\u0026#39; ], options: { interrupt: true, /* * Importante la opción spawn a false, * para permitir cambiar el contexto de * la tarea. */ spawn: false }, }, }, /* * Dentro de la tarea sass, tenemos dos subtareas: * - dist: compila el fichero main.scss siempre * que se produzca un cambio en cualquier scss. El * fichero main.scss, contiene imports del resto de * ficheros, cada vez que se toca alguno debe de * actualizarse este. * * - changed: Tal cual está definida, compilaría todos * los ficheros del proyecto, pero posteriormente con * un evento vamos a modificar el parámetro files, y * es indiferente lo que contenga inicialmente. */ sass: { dist: { files: { \u0026#39;source/styles/main.css\u0026#39;: \u0026#39;source/styles/main.scss\u0026#39; }, options: { noCache: true } }, changed: { files: [ { src: [ \u0026#39;source/**/*.scss\u0026#39; ], ext: \u0026#39;.css\u0026#39; } ], options: { noCache: true } } } } ); /* * A continuación, podemos escuchar el evento watch, que recibe * información acerca del fichero que ha sido modificado. */ grunt.event.on( \u0026#39;watch\u0026#39;, function( action, filepath, target ) { // Reemplazamos .scss por .css, para indicar el destino var _destiny = filepath.replace( \u0026#34;.scss\u0026#34;, \u0026#34;.css\u0026#34; ), _file = {}; /* * Creamos un objeto, para sobrescribir el parámetro file de * la subtarea changed. */ _file[ _destiny ] = filepath; grunt.log.writeln( \u0026#39;Compilando Sass del fichero cambiado: \u0026#39; + filepath ); /* * Sobrescribimos el parámetro de configuración, para que solo * se compile el fichero modificado. */ grunt.config( \u0026#39;sass.changed.files\u0026#39;, _file ); } ); // Cargamos los plugins grunts necesarios grunt.loadNpmTasks( \u0026#39;grunt-contrib-watch\u0026#39; ); grunt.loadNpmTasks( \u0026#39;grunt-contrib-sass\u0026#39; ); /* * Registramos como tarea por defecto la tarea watch. Cuando en la * consola, estando en el proyecto, pongamos grunt, por defecto se * lanzará la tarea que registremos como default. Podríamos registrar * otra, en cuyo caso tendríamos que poner el comando grunt watch, * para decirle a grunt que ejecuta la tarea watch. */ grunt.registerTask( \u0026#39;default\u0026#39;, [ \u0026#39;watch\u0026#39; ] ); }; Ya simplemente hemos de dirigirnos a la consola, y ejecutar grunt, ya que la tarea watch ha sido añadida por defecto, o bien grunt watch y se lanzará el proceso que estará observando los cambios producidos en los ficheros scss de nuestro proyecto, para acto seguido lanzar la tarea.\nDe esta manera nuestros ficheros Sass son compilados automáticamente, muy útil si nuestro editor de texto no dispone de un plugin que automatice el proceso y queremos evitar tener que estar compilando manualmente desde la consola.\nPrimeros pasos con grunt Configurando tareas ","summary":"A lo largo de los 2 últimos años, he ido poco a poco mejorando mi nivel de productividad en el trabajo."},{"url":"/blog/ellipsis-de-m%C3%BAltiples-l%C3%ADneas-con-javascript/","title":"Ellipsis de múltiples líneas con Javascript","content":"Ellipsis es simplemente un carácter compuesto por tres puntos: “…”. En desarrollo web, se aplica a textos muy largos que son más grandes que su contenedor, y por tanto queremos que sean recortados agregando al final el carácter ellipsis. Con el avance de los estándares css modernos, ya podemos aplicar una solución sin necesidad de echar mano de Javascript:\n.ellipsis { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; -o-text-overflow: ellipsis; } ¿Cual es la limitación? Que sólo funciona en textos con una línea, si tenemos más de una línea no funciona, y es ahí donde entra en juego Javascript. He creado una sencilla función, simplemente es necesario que en css el elemento disponga de un line-height definido para funcionar.\n/** * Acorta strings multilínea añadiendo el símbolo ellipsis. * @param {jQuery} $obj : Objeto jQuery a aplicar si es necesario. * Importante, debe tener line-height definido. * @param {String} val : Texto a insertar. * @param {Number} maxLines : Máximo de líneas permitidas. */ function ellipsis( $obj, val, maxLines ) { if ( maxLines \u0026amp;lt; 2 ) { $obj.text( val ); return; } var _valueAux = val, _lenValueAux = _valueAux.length, _heightLine = parseFloat( $obj.css( \u0026#34;line-height\u0026#34; ) ), /* * Añadimos 2 porque algunos navegadores redondean line-height, * asi que cubrimos el máximo valor en px de line-height redondeado. */ _maxHeight = maxLines * _heightLine + 2; $obj.text( _valueAux ); // Si hay más líneas de las esperadas if ( ( $obj[ \u0026#34;0\u0026#34; ].scrollHeight \u0026gt; _maxHeight ) \u0026amp;\u0026amp; ( _lenValueAux ) ) { // Reducimos el length del string hasta que queden las líneas deseadas while ( $obj[ \u0026#34;0\u0026#34; ].scrollHeight \u0026gt; _maxHeight ) { _valueAux = _valueAux.substr( 0, ( _lenValueAux - 2 ) ) + \u0026#34;…\u0026#34;; $obj.text( _valueAux ); _lenValueAux = _valueAux.length; } } } También hay plugins en jQuery, para un uso más avanzado y complejo no está de más echarle un ojo. Para más información, o una implementación más optimizada, hay un hilo en Stackoverflow donde hablan del tema.\n","summary":"Ellipsis es simplemente un carácter compuesto por tres puntos: “…”. En desarrollo web, se aplica a textos muy largos que son más grandes que su contenedor, y por tanto queremos que sean recortados agregando al final el carácter ellipsis."},{"url":"/blog/jshint-y-formateo-de-c%C3%B3digo-al-hacer-commit-con-git-git-hooks/","title":"JSHint y formateo de código al hacer commit con git (Git hooks)","content":"A la hora de trabajar en equipo, tener una guía de estilos definida es de vital importancia. Estoy trabajando en un proyecto en el cual por diversos motivos que no vienen al caso, se podría mejorar bastante en ese aspecto, y mediante el uso de Node.js disponemos de herramientas que nos pueden ayudar a tener en un equipo un código más uniforme y estándar.\nPara nuestro proyecto he elegido un linter, en este caso JSHint, y un formateador para el código Javascript, que representa el grueso de los desarrollos de nuestra aplicación, js-beautify. Podría incorporarse además una tercera herramienta, muy potente a la hora de definir exactamente los estilos que deseamos aplicar de manera muy minuciosa, JSCS, que se ocupa de muchas opciones de estilo que actualmente mantiene JSHint, pero que pronto pasarán a estar deprecadas. (Actualización: Parece que ESLint es una alternativa equilibrada a JSHint y JSCS, tengo que probarlo más a fondo). Por el momento me limitaré a las 2 mencionadas.\nComo control de versiones, utilizamos Git, y aunque la consola es muy completa, en el día a día para según que tareas, es mucho mejor a la hora de seguir un historial de commits, ver cambios y hacer mergeos una herramienta gráfica como SourceTree, que es la que uso y recomiendo.\nPara estandarizar nuestro código, he decidido crear una serie de reglas a la hora de validar el código Javascript, y una vez validado, el archivo deberá ser formateado de acuerdo a otra serie de reglas, de manera que en el repositorio siempre dispongamos de archivos libres de errores, con un mismo formato y siguiendo el mismo estilo.\nLa idea es simple, quiero que cada vez que alguien vaya a hacer commit de sus cambios al repositorio, se validen los ficheros Javascript de acuerdo a unas reglas comunes de JSHint, y si el archivo no contiene errores será formateado automáticamente antes del commit al repositorio. La idea es hacerlo automático, así nadie tiene ninguna excusa. Veamos primero como instalar a nivel de proyecto las 2 herramientas.\nEn primer lugar vamos a instalar JSHint. Podemos instalarlo a nivel global, o a nivel de proyecto, me quedaré con esta última opción, de esa manera podemos disponer en cada proyecto de una configuración especifica de JSHint con las reglas que deseemos aplicar a cada proyecto. Iremos a la consola, y estando en el directorio raíz de nuestro proyecto, ejecutaremos el siguiente comando:\nnpm install --save-dev jshint Se creará un directorio llamado node_modules donde se instalará JSHint para nuestro proyecto específico. A la hora de definir las reglas para el proyecto, lo mejor será tener un fichero .jshintrc, que contenga todas las reglas y esté también en el repositorio, para que si se modifica alguna cosa, todos se actualicen al hacer pull. Hay muchas opciones, están todas explicadas en la documentación oficial, pongo como ejemplo el archivo que he creado para nuestro proyecto:\n{ \u0026#34;evil\u0026#34; : true, \u0026#34;regexdash\u0026#34; : true, \u0026#34;browser\u0026#34; : true, \u0026#34;wsh\u0026#34; : true, \u0026#34;trailing\u0026#34; : true, \u0026#34;multistr\u0026#34; : true, \u0026#34;sub\u0026#34; : true, \u0026#34;loopfunc\u0026#34; : true, \u0026#34;expr\u0026#34; : true, \u0026#34;jquery\u0026#34; : true, \u0026#34;newcap\u0026#34; : true, \u0026#34;plusplus\u0026#34; : false, \u0026#34;curly\u0026#34; : true, \u0026#34;eqeqeq\u0026#34; : true, \u0026#34;undef\u0026#34; : true, \u0026#34;eqnull\u0026#34; : true, \u0026#34;globals\u0026#34; : { \u0026#34;jQuery\u0026#34;: true, \u0026#34;console\u0026#34;: true } } A continuación instalaremos js-beautify, también localmente en el proyecto, desde la consola en la raíz del proyecto:\nnpm install --save-dev js-beautify Igual que en el caso anterior, crearemos un fichero .beautifyrc con las opciones que queremos que se utilicen a nivel de proyecto para formatear los ficheros javascript. Este es el nuestro:\n{ \u0026#34;indent_size\u0026#34;: 4, \u0026#34;indent_char\u0026#34;: \u0026#34; \u0026#34;, \u0026#34;indent_level\u0026#34;: 0, \u0026#34;indent_with_tabs\u0026#34;: false, \u0026#34;preserve_newlines\u0026#34;: true, \u0026#34;max_preserve_newlines\u0026#34;: 10, \u0026#34;jslint_happy\u0026#34;: false, \u0026#34;space_after_anon_function\u0026#34;: false, \u0026#34;brace_style\u0026#34;: \u0026#34;end-expand\u0026#34;, \u0026#34;keep_array_indentation\u0026#34;: false, \u0026#34;keep_function_indentation\u0026#34;: true, \u0026#34;space_before_conditional\u0026#34;: true, \u0026#34;break_chained_methods\u0026#34;: false, \u0026#34;eval_code\u0026#34;: false, \u0026#34;unescape_strings\u0026#34;: false, \u0026#34;wrap_line_length\u0026#34;: 0, \u0026#34;wrap_attributes\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;wrap_attributes_indent_size\u0026#34;: 4, \u0026#34;end_with_newline\u0026#34;: true } Puedes consultar el listado de opciones para añadir/modificar según tus preferencias. Ya está todo listo, ahora simplemente hemos de hacer que automáticamente al hacer commit, se pase el JSHint a todos los ficheros javascript automáticamente, y si detecta algún error en alguno de los archivos, no será posible hacer commit, ya que git dará error hasta que no se solucionen. ¿Cómo puede automatizarse este proceso?\nA través de lo que se llaman hooks, que no son más que scripts que lanza git automáticamente cuando determinadas acciones ocurren. Puedes ir al directorio .git de tu proyecto, y allí encontrarás una carpeta hooks en la que hay scripts de ejemplo con la extensión .sample. El que nos interesa para este ejemplo, es el script ejecutado antes de hacer commit, que realizará tareas en el momento que hagamos commit. Para ello simplemente crearemos un archivo llamado pre-commit, sin extensión, o bien editaremos el archivo pre-commit.sample y modificaremos su nombre. El script que he creado en cuestión es el siguiente:\n#!/bin/sh # Solo queremos validar y formatear los ficheros Javascript incluidos en el commit files=$(git diff --cached --name-only --diff-filter=ACM | grep \u0026#34;.js$\u0026#34;) # Si no hay ficheros Javascript se continúa normalmente el commit if [ \u0026#34;$files\u0026#34; = \u0026#34;\u0026#34; ]; then exit 0 fi # Variable que comprueba si todas las validaciones fueron correctas pass=true echo \u0026#34;Validando Javascript con JSHint:\u0026#34; # Recorremos todos los archivos for file in $files; do excluded=false # Recorre las líneas del fichero exclude-hook.txt ubicado en el raíz del proyecto # en busca de ficheros o patrones a excluir. No interesa formatear y validar por # ejemplo, librerías externas como Jasmine, que no tienen por qué seguir la misma # guía de estilo de nuestro proyecto. while read line || [ -n \u0026#34;$line\u0026#34; ] do # Coincidencia encontrada. Se excluye el fichero. if [ \u0026#34;${file#*$line}\u0026#34; != \u0026#34;$file\u0026#34; ]; then echo \u0026#34;Excluido $file\u0026#34; excluded=true break fi # \u0026#39;\u0026lt; exclude-hook.txt\u0026#39; es el equivalente a \u0026#39;cat exclude-hook.txt\u0026#39; done \u0026lt; exclude-hook.txt if [ \u0026#34;$excluded\u0026#34; = true ]; then continue fi result=$(jshint $file | egrep \u0026#34;error\u0026#34;) echo $result if [ \u0026#34;$result\u0026#34; != \u0026#34;\u0026#34; ]; then echo \u0026#34;JSHint fallido: $file\u0026#34; echo \u0026#34;$(jshint $file)\u0026#34; pass=false else echo \u0026#34;JSHint validado: $file\u0026#34; beautify=$(js-beautify $file -r -P --config .beautifyrc) add=$(git add $file) fi done echo \u0026#34;Validación de Javascript completa\u0026#34; if ! $pass; then echo \u0026#34;Es necesario corregir los errores mostrados por JSHint. Abortando commit.\u0026#34; exit 1 else echo \u0026#34;Validación y formateado satisfactorios.\u0026#34; exit 0 fi En primer lugar filtraremos los archivos que se están commiteando, y nos quedaremos solo con los que tienen extensión .js. Además, en el raíz del repositorio, en un fichero llamado exclude-hook.txt, añadiremos patrones, que si son encontrados en las rutas del fichero, hará que se excluya al fichero del proceso. Ficheros que por ejemplo no queremos que sean validados y formateados, librerías externas de terceros, como Jasmine, jQuery, archivos minimizados, etc. Un ejemplo de fichero:\n.min.js jasmine source/lib De esta manera ignoraremos todo lo que esté en source/lib, contenga la palabra jasmine o contenga los caracteres .min.js.\nIremos pasando fichero por fichero JSHint, si hay algún error se mostrará en la consola, si no hay ningún error en el fichero este se formatea automáticamente, y se hace git add para añadir los cambios hechos en el fichero. Una vez validados todos, comprobaremos si hubo algún error en alguno, si lo hubo saldremos con código 1, que impide que se haga el commit. En caso de que todo esté bien, se sale con código 0 y nuestro commit será enviado al repositorio correctamente.\nDebo decir que formatear el código Javascript no es para lo que está pensado el hook pre-commit, en él, siendo estrictos, solo deberían llevarse a cabo tareas que no modificasen el código, como son validar el código, ejecución de pruebas unitarias, etc. Por ejemplo este script no funcionaría correctamente, en un caso más avanzado, como sería commitear sólo una parte de un fichero.\nLo ideal sería que cada desarrollador tuviese configurado su editor para formatear el código, pero bueno, en este caso, por el bien de que todos los ficheros tengan la misma guía de estilos, este aspecto representa un mal menor.\nUn script de mucha utilidad, que evitará que subamos archivos con errores de sintaxis o de estilo. Puedes ampliar información sobre hooks en la página de Git, o en Git Hooks.\n","summary":"A la hora de trabajar en equipo, tener una guía de estilos definida es de vital importancia."},{"url":"/blog/concatenar-llamadas-a-m%C3%A9todos-en-javascript/","title":"Concatenar llamadas a métodos en Javascript","content":"Vamos a ver de una manera rápida, como podemos concatenar llamadas a distintos métodos sobre un mismo objeto en Javascript (en inglés, Method Chaining in JavaScript). Este patrón, es utilizado en el popular framework jQuery, en el cual pueden llamarse a varios métodos sobre un selector jQuery. Por ejemplo:\n$(\u0026#34;#selector\u0026#34;).find(\u0026#34;.square\u0026#34;).css(\u0026#34;height\u0026#34;, \u0026#34;100px\u0026#34;).show(); // En caso de concatenar muchos métodos $(\u0026#34;#selector\u0026#34;) .find(\u0026#34;.square\u0026#34;) .css(\u0026#34;height\u0026#34;, \u0026#34;100px\u0026#34;) .show(); ``` Que es más corto, o más legible (para gustos los colores) que esto: ```js var $selector = $(\u0026#34;#selector\u0026#34;); $selector.find(\u0026#34;.square\u0026#34;); $selector.css(\u0026#34;height\u0026#34;, \u0026#34;100px\u0026#34;) $selector.show(); Bien, vamos a ver como implementar este patrón en Javascript puro, supongamos un objeto tonto, con 2 métodos sencillos como el siguiente:\nvar Widget = function(param1, param2) { this.msg1 = param1; this.msg2 = param2; }; Widget.prototype.method1 = function() { alert(this.msg1); }; Widget.prototype.method2 = function() { alert(this.msg2); }; var instancia = new Widget(\u0026#34;Hola\u0026#34;, \u0026#34;Mundo\u0026#34;); Si quisiéramos llamar a los 2 métodos, deberíamos hacerlo de la siguiente manera:\ninstancia.method1(); instancia.method2(); Y si intentamos concatenar directamente las llamadas, ejecutará el primer método, pero fallará el segundo:\ninstancia.method1().method2(); // Uncaught TypeError: Cannot read property \u0026#39;method2\u0026#39; of undefined ¿Como hacerlo funcionar? Es sencillo, tan solo deberemos añadir en los métodos return this; , de esta manera cuando se llame a method1 se devolverá el objeto, y al llamar al siguiente método ya no dará undefined, puesto que al haberse devuelto el objeto en el método anterior, ya encuentra la referencia para poder llamar a method2. Así queda el código:\nvar Widget = function(param1, param2) { this.msg1 = param1; this.msg2 = param2; }; Widget.prototype.method1 = function() { alert(this.msg1); return this; }; Widget.prototype.method2 = function() { alert(this.msg2); return this; }; var instancia = new Widget(\u0026#34;Hola\u0026#34;, \u0026#34;Mundo\u0026#34;); instancia.method1().method2(); ¿Sencillo verdad? Este patrón de diseño se conoce como Fluent interface. Usarlo o no ya es cuestión de gustos.\n","summary":"Vamos a ver de una manera rápida, como podemos concatenar llamadas a distintos métodos sobre un mismo objeto en Javascript (en inglés, Method Chaining in JavaScript)."},{"url":"/blog/width-de-jquery-sin-redondeo/","title":"Width() de jQuery sin redondeo","content":"Un tip muy rápido y muy sencillo, pero que no conocía. Por defecto si haces uso de los métodos .width() y .height() de jQuery, los valores devueltos se encuentran redondeados. Si en alguna ocasión necesitas con precisión conocer los decimales, puedes utilizar el método getBoundingClientRect() incorporado en ES4 y soportado por todos los navegadores. Por ejemplo el width se obtendría de la siguiente manera:\n$(\u0026#34;#selector\u0026#34;)[0].getBoundingClientRect().width ","summary":"Un tip muy rápido y muy sencillo, pero que no conocía."},{"url":"/blog/lanzar-fichero-batch-.bat-sin-mostrar-la-consola-en-windows/","title":"Lanzar fichero batch (.bat) sin mostrar la consola en Windows","content":"En mi día a día suelo trabajar en entorno Windows, y hay ciertos atajos de teclado y acciones, como backups de algunos proyectos, que tengo automatizadas con un simple fichero .bat, que ejecuto a través de un comando a través de Autohotkey (algún día escribiré un poco sobre esta utilidad para mejorar la productividad en Windows).\nPor si te resulta molesto que esté la consola abierta mientras se ejecuta el script, hay una manera sencilla de impedirlo, como pude encontrar en esta pregunta de Superuser. Copia el siguiente mini script en un fichero con extensión .vbs en la misma carpeta que tu bat, y ejecutalo en lugar del .bat\nSet oShell = CreateObject (\u0026#34;Wscript.Shell\u0026#34;) Dim strArgs strArgs = \u0026#34;cmd /c testing.bat\u0026#34; oShell.Run strArgs, 0, false Simplemente cambia testing.bat por el nombre de tu fichero y listo.\n","summary":"En mi día a día suelo trabajar en entorno Windows, y hay ciertos atajos de teclado y acciones, como backups de algunos proyectos, que tengo automatizadas con un simple fichero ."},{"url":"/blog/trim-trailing-white-space-en-un-shortcut-en-sublime/","title":"Trim trailing white space en un shortcut en Sublime","content":"Sublime permite definir por medio de sus ficheros de configuración, una opción que cuando trabajo solo suelo tener activada, pero que en ocasiones trabajando en equipo no es muy recomendable.\nLa opción es la de eliminar los espacios sobrantes en un archivo. Por defecto en sublime viene desactivada, pero es posible activarla para que Sublime se encargue de eliminar esos innecesarios espacios al guardar un archivo. Si esto es lo que buscas, simplemente abre tu archivo de Settings – User, y añade la siguiente opción: \u0026quot;trim_trailing_white_space_on_save\u0026quot;: true\n¿Por qué no tenerlo siempre activado? Actualmente estoy trabajando en equipo, y cada persona trabaja con su editor favorito configurado a su gusto. De hecho en nuestro proyecto cada uno usamos un editor distinto (NetBeans, Brackets, Notepad++, Eclipse). Puede resultar bastante confuso tocar el fichero de un compañero, guardar y subir con los espacios en blancos eliminados. Quizás cuando ese compañero vaya a hacer commit de sus cambios y necesite mergear, no le haga mucha gracia ver cambios por todos lados y tener que revisar todas las líneas para ver si hay cambios. Hay mecanismos para que al comparar no salten esas diferencias, pero no todo el mundo las conoce ni las quiere conocer.\nPor eso me propuse poder ejecutar el limpiado de espacios, pero en lugar de al guardar, en un atajo de teclado, así podría limpiar mis archivos sin interferir en los del resto. La opción más fácil era instalar una extensión (Trailing Spaces), pero ya tengo Sublime cargado de extensiones y me parecía innecesario cargarlo con una más, con muchas opciones que probablemente no use y un gasto innecesario de recursos.\nLa solución es sencilla, Sublime tiene un plugin por default que realiza la acción, asi que solamente hay que modificarlo para que ejecute la acción en un atajo de teclado en lugar de al guardar el archivo. Podemos ver el plugin en la siguiente ruta: \\Sublime\\Data\\Packages\\Default\nEl archivo es trim_trailing_white_space.py.\nimport sublime, sublime_plugin class TrimTrailingWhiteSpace(sublime_plugin.EventListener): def on_pre_save(self, view): if view.settings().get(\u0026#34;trim_trailing_white_space_on_save\u0026#34;) == True: trailing_white_space = view.find_all(\u0026#34;[\\t ]+$\u0026#34;) trailing_white_space.reverse() edit = view.begin_edit() for r in trailing_white_space: view.erase(edit, r) view.end_edit(edit) class EnsureNewlineAtEof(sublime_plugin.EventListener): def on_pre_save(self, view): if view.settings().get(\u0026#34;ensure_newline_at_eof_on_save\u0026#34;) == True: if view.size() \u0026gt; 0 and view.substr(view.size() - 1) != \u0026#39;\\n\u0026#39;: edit = view.begin_edit() view.insert(edit, view.size(), \u0026#34;\\n\u0026#34;) view.end_edit(edit) Podéis modificar ese mismo fichero, yo preferí crearme otro distinto, por no tocar nada de lo que trae Sublime por defecto, y le puse un nombre super original: trim_trailing_white_space2.py, en la misma carpeta. El código es el siguiente:\nimport sublime, sublime_plugin def trim_trailing_white_space2(view): trailing_white_space2 = view.find_all(\u0026#34;[\\t ]+$\u0026#34;) trailing_white_space2.reverse() edit = view.begin_edit() for r in trailing_white_space2: view.erase(edit, r) view.end_edit(edit) class TrimTrailingWhiteSpace2Command(sublime_plugin.TextCommand): def run(self, edit): trim_trailing_white_space2(self.view) Para terminar, abrimos el archivo Key Bindings – User y añadimos el siguiente shortcut:\n{ \u0026#34;keys\u0026#34;: [\u0026#34;ctrl+alt+shift+t\u0026#34;], \u0026#34;command\u0026#34;: \u0026#34;trim_trailing_white_space2\u0026#34; } Con la combinación de teclas que os sea más cómoda. Et voilà! Eso es todo.\nLo anterior para la versión 2 de Sublime, si lo queremos funcionando en la 3 el código es el siguiente:\nimport sublime, sublime_plugin class TrimTrailingWhiteSpace2Command(sublime_plugin.TextCommand): def run(self, edit): trailing_white_space = self.view.find_all(\u0026#34;[\\t ]+$\u0026#34;) trailing_white_space.reverse() for r in trailing_white_space: self.view.erase(edit, r) class TrimTrailingWhiteSpace2(sublime_plugin.EventListener): def run(self, view): view.run_command(\u0026#34;trim_trailing_white_space2\u0026#34;) Solución encontrada en: Stackoverflow (3ª respuesta)\n","summary":"Sublime permite definir por medio de sus ficheros de configuración, una opción que cuando trabajo solo suelo tener activada, pero que en ocasiones trabajando en equipo no es muy recomendable."},{"url":"/blog/depuraci%C3%B3n-remota-en-smart-tv-con-console.io/","title":"Depuración remota en Smart TV con console.io","content":"Hace algún tiempo hablé de Weinre, como opción para depurar de forma remota nuestras aplicaciones Javascript. Era una opción bastante buena para dispositivos Android y Smarts TV de LG, pero cuando fuí a depurar la aplicación que estamos desarrollando en una Smart TV de Samsung, me llevé la sorpresa de que las televisiones Samsung, deben hacer algo por dentro que sobrescribe el método console del navegador, y con Weinre no podía ver ninguno de los logs que había puesto en el código.\nRápidamente mis compañeros y yo pensamos en elaborar un propio debugger muy simple con un script en PHP, pero pronto comenzaron a surgir los inconvenientes y desechamos la idea. Fue de esta manera como nos topamos con Console.io, una consola web remota que cumplía de largo con todas nuestras necesidades. Además es totalmente compatible con diferentes modelos de Smart TV de distintos años, entre ellos la mencionada Samsung que usamos para pruebas. Según su página web:\nToshiba TV (2011, 2012, 2013) LG NetCast TV (2011, 2012, 2013) Philips NetTV (2011, 2012, 2013) Samsung TV (2010, 2011, 2012, 2013) Panasonic TV (2012, 2013) Technika Avtrex STB Sony (BDP-S4100) Hopper Dish (Hopper) Firefox, Safari, Opera, Chrome, Maple, PhantomJS and IE iPhone, iPod, iPad, Android browser, windows 8 phone etc Vamos a ver en unos sencillos pasos como instalar Console.io rápidamente. Se instala como un módulo de Node.js, así que deberemos instalar Node.js si no lo tenemos ya instalado. Antes de nada, vamos a descargar todos los archivos necesarios, podéis descargarlo en formato TAR, ZIP o descargarlo vía git desde la página web de github del proyecto. En principio no serán necesarios los archivos, ya que con el siguiente paso debería ser suficiente, pero por si acaso no lo es, luego explico como hacerlo funcionar. Una vez descargado, abrimos la consola e instalamos Console.io como paquete npm mediante el siguiente comando:\nnpm install -g xconsole.io De esta manera una vez terminen de realizarse todas las operaciones en la consola, se habrá instalado correctamente y podremos comenzar a usarlo. Para ello simplemente abriremos la consola, y ejecutaremos el siguiente comando:\nconsoleio Y aparecerá en consola el siguiente mensaje:\nStarting Console.IO Console.IO is run at http://localhost:8082 Con esto ya estaría instalado, simplemente abrimos la dirección del servidor y comprobamos que todo cargue correctamente. Deberíamos ver algo así:\nEn mi portátil personal fue suficiente con estos pasos, en el del trabajo por alguna razón que no he investigado, no debió añadirse correctamente la ruta hasta el Console.io, y al abrir la url del servidor, me apareció un error de este tipo:\nError: ENOENT, stat 'C:\\Users\\dist\\app\\index.html'\nEsto sucede porque se intenta buscar el Console.io en el directorio en el cual estoy situado actualmente en la consola, y no encuentra los archivos necesarios para ejecutarse. Lo que hice fue copiarme todas las carpetas del Console.io en mi servidor wamp (puede ser en cualquier directorio, Mis Documentos, en el escritorio). Y en la barra de tareas tengo un acceso directo a un .bat muy sencillo, que se coloca en dicha carpeta y una vez allí lanza el Console.io:\ncd C:\\wamp\\www\\jsconsole consoleio Una vez funcionando de la manera que sea, ya solo nos queda añadir un script a nuestra aplicación, para poder recibir en Console.io los mensajes de depuración. Siendo 192.168.1.15, nuestra máquina con nuestra ip (en vuestro caso deberéis usar la IP que tenga vuestro ordenador), añadiríamos lo siguiente:\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;http://192.168.1.15:8082/console.io.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Ya solo nos queda lanzar nuestra aplicación, desde el dispositivo que queramos, y podremos ver desde la url de Console.io todos los logs que van saliendo. Podemos ver la estructura de los objetos, y utilizar los distintos método de la consola, info, error, warning, hasta funciona console.time y console.timeEnd.\nEn la parte superior izquierda, veremos los dispositivos conectados (los que podemos debuggear), en este caso tenemos una ejecución de una televisión LG Smart TV de 2013, que hemos abierto para depurar, y otra ejecución desde un ordenador con un chrome versión 38, que aparece con una bolita verde. Para conectar con la ejecución de un dispositivo, simplemente hacemos doble click sobre la bolita verde, y empezaremos a ver y recibir logs del dispositivo seleccionado.\nSe pueden guardar los logs, pausar la ejecución, filtrar los tipos de logs que queremos ver, podemos ver el código fuente de la página, realizar capturas de pantalla, recargar la aplicación sin tener que lanzarla de nuevo, ver las características del dispositivo, objeto navigator…\nEn fin muchas cosas, es cuestión de investigar y trastear por su interfaz gráfica, que es bastante intuitiva y nos iremos encontrando cosas que en un determinado momento pueden sernos de gran utilidad. En la siguiente imagen vemos algunos logs, un Hola mundo, el valor de un objeto, las propiedades de un array. Además desde el editor podemos ejecutar código Javascript, muy útil para conocer propiedades de elementos del DOM, manipularlos o lanzar cualquier función que nos haga falta de manera manual.\nEn resumen Console.io es una herramienta muy potente, que nos puede arrojar luz cuando probamos en distintos tipos de dispositivo desde donde no es posible consultar una consola de errores, o en caso de poder consultarla ésta es muy limitada. A mí me ha sacado las castañas del fuego más de una vez, probando en las Smart TV. No dudéis en ampliar información en la documentación oficial.\nConsole.io Página en Github ","summary":"Hace algún tiempo hablé de Weinre, como opción para depurar de forma remota nuestras aplicaciones Javascript."},{"url":"/blog/depurar-maquetaci%C3%B3n-css-con-una-l%C3%ADnea-de-c%C3%B3digo/","title":"Depurar maquetación CSS con una línea de código","content":"Llevo aproximadamente 8 años trabajando como desarrollador Javascript principalmente, y la verdad es que cada día uno sigue descubriendo cosas que no dejan de sorprenderle. En este caso, un código de una línea, que sirve para visualizar el layout de todos los elementos CSS de una página.\nEs un código ideal para depurar, ver donde se te descuadra un div, donde se te ha colado un margen, controlar al milímetro todo. El código en cuestión es el siguiente. Versión para consolas, que cuentan con el siguiente alias: $$('*') equivalente a document.querySelectorAll('*')\n[].forEach.call($$(\u0026#34;*\u0026#34;),function(a){ a.style.outline=\u0026#34;1px solid #\u0026#34;+(~~(Math.random()*(1\u0026lt;\u0026lt;24))).toString(16) }) Asi que si deseas incorporarlo desde código, en lugar de desde la consola, simplemente:\n[].forEach.call(document.querySelectorAll(\u0026#34;*\u0026#34;),function(a){ a.style.outline=\u0026#34;1px solid #\u0026#34;+(~~(Math.random()*(1\u0026lt;\u0026lt;24))).toString(16) }) Podemos ver como con solo este código, podemos tener un generador de colores aleatorio en formato hexadecimal: (~~(Math.random()*(1\u0026lt;\u0026lt;24))).toString(16)\nDe este tipo de código en una línea, se puede aprender bastante Javascript. Recomiendo la lectura del artículo creado por Arqex en su blog, pues me parece interesante y yo al menos aprendí cosas.\nEnlace: Código original de Addy Osmani\n","summary":"Llevo aproximadamente 8 años trabajando como desarrollador Javascript principalmente, y la verdad es que cada día uno sigue descubriendo cosas que no dejan de sorprenderle."},{"url":"/blog/cambia-el-separador-de-palabras-en-sublime-text/","title":"Cambia el separador de palabras en Sublime Text","content":"Una de las cosas más tontas, pero que descubrí hace poco. Por defecto, Sublime Text tiene definido determinados caracteres como separador de palabras. El punto, la coma, el signo del dólar, etc. En determinadas ocasiones, para determinados lenguajes (o para todos), podemos querer modificar los caracteres considerados como separador de palabra. Por ejemplo, en CSS, es muy común utilizar en las clases nombres separando las palabras con guiones, es una convención bastante extendida. Creas tu nuevo estilo en CSS, vas a copiarlo y te ves obligado a seleccionarlo ya que con doble click no se selecciona todo.\nEs una buena idea por tanto, al menos para CSS eliminar el carácter “-” como separador. Para ello, en Sublime vamos al menú Preferences -\u0026gt; Settings – Default. Y buscamos la siguiente propiedad:\n// Characters that are considered to separate words \u0026#34;word_separators\u0026#34;: \u0026#34;./\\\\()\\\u0026#34;\u0026#39;-:,.;\u0026lt;\u0026gt;~!@#$%^\u0026amp;*|+=[]{}`~?\u0026#34;, La copiamos, y podemos cambiarla globalmente en Preferences -\u0026gt; Settings – User, o para un lenguaje en específico. En este caso optamos por esta última opción, abrimos un archivo CSS cualquiera, y vamos a Preferences -\u0026gt; Settings – More -\u0026gt; Syntax – Specific – User. Si no has definido ninguna preferencia para el lenguaje específico, aparecerá un archivo vacío. Pegaremos la propiedad y la encerraremos entre llaves de la siguiente manera, eliminando el carácter “–“:\n{ \u0026#34;word_separators\u0026#34;: \u0026#34;./\\\\()\\\u0026#34;\u0026#39;:,.;\u0026lt;\u0026gt;~!@#$%^\u0026amp;*|+=[]{}`~?\u0026#34; } Puedes utilizar un proceso similar para otros lenguajes, por ejemplo si utilizas jQuery en Javascript y/o PHP, puede resultarnos interesante eliminar el carácter “$” como separador de palabra. Por este tipo de detalles personalizables son por los que me encanta Sublime.\n","summary":"Una de las cosas más tontas, pero que descubrí hace poco."},{"url":"/blog/detectar-fin-de-una-transici%C3%B3n/animaci%C3%B3n-css3-con-javascript/","title":"Detectar fin de una transición/animación CSS3 con Javascript","content":"Nunca me había visto en la necesidad de detectar cuando una transición CSS3 termina, pero el otro día en el trabajo, para desplegar cierta información, estamos utilizando 2 contenedores, y al añadir una clase se activa una animación CSS3 que va aumentando el margen izquierdo del div hasta que aparece el siguiente. Para ello estamos utilizando eventos de teclado, si pulsamos flecha derecha va hacia la derecha, en caso de pulsar la flecha izquierda, hacia la izquierda, muy sencillito.\n¿Y qué pasa si pulsamos varias veces antes de que la animación termine? Pues que parece que va a tirones, y lo que es un efecto de transición muy elegante se convierte en un efecto muy desagradable. No estaba al tanto, pero cuando un elemento presenta una animación puramente en CSS3, en función del navegador, podemos suscribirnos a un evento que nos informará cuando la transición ha terminado. En este proyecto estamos utilizando jQuery, asi que la solución es bien sencilla:\nSolución para transiciones:\nvar ended = false; $(\u0026#34;#selector\u0026#34;).bind(\u0026#34;transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd\u0026#34;, function(){ ended = true; }); Solución para animaciones:\nvar ended = false; $(\u0026#34;#someSelector\u0026#34;).bind(\u0026#34;animationend webkitAnimationEnd oAnimationEnd MSAnimationEnd\u0026#34;, function(){ ended = true; }); Si no deseas usar jQuery, en Modernizr tienen esto:\nfunction transitionEndEventName () { var i, undefined, el = document.createElement(\u0026#39;div\u0026#39;), transitions = { \u0026#39;transition\u0026#39;:\u0026#39;transitionend\u0026#39;, \u0026#39;OTransition\u0026#39;:\u0026#39;otransitionend\u0026#39;, // oTransitionEnd in very old Opera \u0026#39;MozTransition\u0026#39;:\u0026#39;transitionend\u0026#39;, \u0026#39;WebkitTransition\u0026#39;:\u0026#39;webkitTransitionEnd\u0026#39; }; for (i in transitions) { if (transitions.hasOwnProperty(i) \u0026amp;\u0026amp; el.style[i] !== undefined) { return transitions[i]; } } //TODO: throw \u0026#39;TransitionEnd event is not supported in this browser\u0026#39;; } Y se utiliza de la siguiente manera:\nvar transitionEnd = transitionEndEventName(); element.addEventListener(transitionEnd, theFunctionToInvoke, false); Encontré la solución en StackOverflow:\nCallback when CSS3 transition finishes How do I normalize CSS3 Transition functions across browsers? ","summary":"Nunca me había visto en la necesidad de detectar cuando una transición CSS3 termina, pero el otro día en el trabajo, para desplegar cierta información, estamos utilizando 2 contenedores, y al añadir una clase se activa una animación CSS3 que va aumentando el margen izquierdo del div hasta que aparece el siguiente."},{"url":"/blog/depurar-remotamente-aplicaciones-html-con-weinre/","title":"Depurar remotamente aplicaciones HTML con Weinre","content":"Nunca me había visto en la necesidad de hacer uso de esta funcionalidad, normalmente desarrollo aplicaciones y páginas web y las pruebo directamente en el navegador, para depurar el código Javascript suelo utilizar las herramientas de desarrollador de Chrome. ¿En qué casos podemos necesitar depurar remotamente? La respuesta es sencilla, en dispositivos en los cuales no podemos acceder a herramientas de depuración del navegador. Desde la llegada de HTML5 y sus funcionalidades, es posible desarrollar aplicaciones para móviles, Smart TV… Actualmente estoy trabajando en desarrollo de aplicaciones para Smart TV, y me ví en la necesidad de depurar remotamente al realizar pruebas en las teles directamente.\n¿Como depurar remotamente? Para ellos podemos utilizar Weinre, que se instala como un módulo de Node.js. Lo primero de todo, como es lógico será instalar Node.js si no lo tenemos ya instalado. Una vez lo tenemos, podremos instalar Weinre a través de npm, tan solo debemos ir a la consola y ejecutar el siguiente comando:\nnpm -g install weinre Yo utilizo Windows, aunque también tengo Ubuntu, en sistemas Linux deberemos ejecutar el comando precedido de sudo probablemente. Así de simple y así de fácil, ya tenemos instalado weinre. Weinre ejecutará un servidor en nuestra máquina, que será la interfaz a través de la cual depuraremos nuestro aplicación HTML5, que se ejecutará en otro dispositivo (móvil, tablet, Smart TV, etc).\nLa interfaz es prácticamente la misma que las developer tools de Chrome, asi que si sueles usarla te desenvolverás con soltura en ella, aunque tiene algunas limitaciones.\nPara ejecutar el servidor de weinre, vamos a la consola y ejecutamos:\nweinre --boundHost 192.168.1.2 En en este caso he utilizado la IP que tengo asignada en mi ordenador en mi red local, 192.168.1.2. Podríamos ejecutar en localhost, pero en ese caso solo podríamos hacer pruebas desde nuestro ordenador, que podría ser util quizás para depurar desde algún emulador. De esta manera, podremos depurar aplicaciones de otros dispositivos que se ejecuten en nuestra misma red local. El comando es el más simple, puedes teclear weinre –help y ver otro tipo de opciones, como el puerto por el que se lanza, pero en mi caso la configuración por defecto me vale. Si es la primera vez que ejecutas weinre, y estás en windows, probablemente el Firewall pida permisos para que weinre acceda a la red. Veremos un mensaje que confirma que se lanza el servidor:\nYa podemos abrir en el navegador la url, en mi caso: http://192.168.1.2:8080/ El siguiente paso es muy simple, tan solo deberemos incluir un script en nuestra aplicación, para que podamos depurar remotamente. Para el ejemplo en concreto, nuestra SmartTV está conectada en la misma red local, por lo que simplemente añadimos la siguiente línea en nuestra aplicación:\n\u0026lt;script src=\u0026#34;http://192.168.1.2:8080/target/target-script-min.js#instancia\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Observemos que se ha concatenado #instancia, ¿Qué quiere decir esto? Que podemos crear distintas instancias para depurar remotamente, podríamos montar weinre en un ordenador, y conectarnos varias personas a él, y no sufriremos interferencias en los logs si cada uno tenemos un hashtag diferente. Siguiendo con el ejemplo, para poder conectar con la interfaz desde la que depuraremos, iremos a la siguiente url: http://192.168.1.2:8080/client/#instancia Y nos encontraremos con una interfaz bastante familiar:\nYa solo nos queda realizar pruebas, ejecutaremos nuestra aplicación con el script incluido, y donde pone Target comenzaremos a ver las ejecuciones. Al igual que en Chrome, podemos ir a la pestaña Elements, ver el código fuente cargado, editarlo, añadir o quitar estilos css. También disponemos de Resources, Network, Timeline y Console, desde donde podremos visualizar los console.log. Por lo que he probado weinre tarda un poco en inicializarse, por lo que es conveniente que ejecutes los console.log con un timeout, de lo contrario puede que no aparezcan:\nsetTimeout(function() { console.log(\u0026#34;Hola Mundo\u0026#34;); }, 2000); En este caso lo he ejecutado desde mi mismo ordenador, pero en el trabajo pruebo sin problemas con un televisor LG. Así vemos que hay una conexión, una vez ejecutamos la aplicación:\nEste es el ejemplo, un simple Hola Mundo con un console.log al cargar la página:\nEn la pestaña consola observamos que recibimos el console.log:\nDesde la pestaña Elements, podemos modificar la página, los estilos, en este caso cambiamos el color de fondo para el body:\nY efectivamente, vemos que se cambia correctamente:\nDesde la consola podemos inspeccionar el valor de las variables javascript. ¿Qué limitaciones tiene? Por ejemplo, al editar estilos CSS, y al escribir, no te va sugiriendo para autocompletar las propiedades. Tampoco podemos ejecutar debugger, para depurar y añadir puntos de parada e ir inspeccionando paso por paso nuestros scripts. Eso sería ya simplemente increíble, pero con todo lo expuesto, weinre parece una de las mejores herramientas a la hora de hacer remote debugging. Toda esta información y más está en la página web de Weinre, asi que si se te queda corta esta entrada, no dudes en consultar toda la información en su web.\nEnlaces: Web oficial de Weinre\n","summary":"Nunca me había visto en la necesidad de hacer uso de esta funcionalidad, normalmente desarrollo aplicaciones y páginas web y las pruebo directamente en el navegador, para depurar el código Javascript suelo utilizar las herramientas de desarrollador de Chrome."}]